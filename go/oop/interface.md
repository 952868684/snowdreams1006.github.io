# 初识接口

## 到底是要猫还是要狗

在上篇文章中编撰了一则简短的小故事,顺便讲解了什么是面向对象的继承特性以及 `Go` 语言如何实现继承语义.

不知道你是不是只停留在那则故事的表面,有没有继续深入思考挖掘更多有价值的信息?

为了照顾没有看到买宠物的故事,这里再简单复述一下故事,如需详细了解,请关注公众号[雪之梦技术驿站]查看[go 学习笔记之是否支持以及如何实现继承](https://mp.weixin.qq.com/s/w9ZfTAMr-mnQ9RK_Va-mEg)

A: 猫是一种宠物,淘气可爱会卖萌,看家本领抓老鼠,偶尔还会喵喵喵.
B: 狗是一种宠物,忠实听话能看家,嗅觉灵敏会破案,一言不合汪汪汪.
C: 我想要买一个宠物,文能卖萌,武可退敌,明个一早给我送来吧!

第二天,A和B各自带着自己的宠物来拜见C,并附上各自的理由,说的头头是道,C觉得有些哪里不对,可是竟无言反驳,只能悻悻收下了猫和狗,白白多花了一分钱!

上则故事很简单,现在的要求是,作为市场监督者,请问应该如何设计市场规则才能保证公平公正地进行交易?

在上篇文章中也给出了一种解决方案,那就是提炼出宠物的公共特性,猫和狗默认是宠物,对外展示时只需要暴露各自的特色,这样需要宠物的用户只需要关注差异亮点而不必在乎共同之处,交易双方沟通更加顺畅,相对公平!

-  宠物默认自带能文能武技能

```go
type Pet struct {
}

func (p *Pet) Skill() {
    fmt.Println("能文能武的宠物")
}
```

-  猫是宠物,还是抓老鼠.

```go
type Cat struct {
    p *Pet
}

func (c *Cat) Catch() {
    fmt.Println("老鼠天敌喵喵喵")
}
```

- 狗是宠物,还能认路导航.

```go

type Dog struct {
    p *Pet
}

func (d *Dog) Navigate() {
    fmt.Println("自带导航汪汪汪")
}
```

某一天,C要能文能武的宠物,最好还可以顺便帮我抓老鼠,于是C选择了喵喵喵!

```go
func TestExtendInstance(t *testing.T) {
    p := new(Pet)
    c := new(Cat)
    c.p = p

    // 老鼠天敌喵喵喵
    c.Catch()
    // 能文能武的宠物
    c.p.Skill()
}
```

过了一阵子,C觉得猫除了抓老鼠别的什么都不会,别人遛狗,我遛猫?于是,想要自带导航功能的宠物狗.

```go
func TestExtendInstance(t *testing.T) {
    p := new(Pet)
    d := new(Dog)
    d.p = p

    // 自带导航汪汪汪
    d.Navigate()
    // 能文能武的宠物
    d.p.Skill()
}
```

上述示例,简而言之就是通过组合的方式实现了面向对象中的继承特性,解决了猫和狗除了是宠物还是自己的问题.

## 猫狗随便是宠物就行

面对猫和狗两种宠物,C犯了选择困难症,于是第一次全盘接收买下了两种宠物.

紧接着市场部门开始介入,利用面向对象的继承特性,用 `Go` 语言实现了猫和狗的个性化与宠物的共同性,从此C再也不会面临选择困难症,每一次根据独特的需求,最终只会选择其中一种宠物,要么是猫,要么是狗.

不知过了多久,这种相安无事的情景最终被一群急性子的顾客所打破,一上来就吵吵嚷嚷说快给我宠物,快一点!

销售人员不紧不慢地说: "别着急,我们这里的宠物有很多种,有猫,有狗,有兔子,有金鱼,有乌龟,有蜗牛..."

"别整那些虚头巴脑的,我只要宠物,赶紧给我宠物就行,别尽扯没用的"

果然是一群急性子的顾客,还没等销售人员介绍完各个宠物的差异性亮点直接被打断了.

宠物市场吵吵闹闹引来了市场监督人员的注意,顾客和商家均上官方诉苦,期望能给出解决办法!

市场监督人员心想: 商家和顾客原本和谐相处的,今天怎么会吵闹起来?双方都没有过错,看来真的是市场赶不上需求,还是得尽快研究新的解决办法啊!

"冷静一下,你们的意见我们这边已经收到了,这样吧,给我们三天的时间,我们一定会想出一个万全之策,到时候再公布新的交易规则,现在我宣布暂时关闭交易,省的再惹出不必要的争端!"

原本吵吵嚷嚷的市场顿时冷却了不少,毕竟谁也不敢违抗市场老大的命令,众人只得悻悻而去,期待三天后的重新开市.

视角切换到市场监督大会上,轮值主席首先开始发言:各位,现在市场面临的问题想必大家都有所耳闻吧,我们已经郑重承诺,三天后必须给市场一个答复,时间紧,任务重,大家要集思广益,一起解决这个难题!

"现在的顾客到底是怎么了,连自己到底想要什么都搞不清楚,还急冲冲地跑来买宠物,自己都不知道要买啥,鬼才知道!",资历老练的继承经理发言道.

"经理说得对,他们自己都不知道到底想要啥宠物,怎么能埋怨商家太罗里吧嗦呢?人家那么卖力介绍宠物的特点,不也是帮助顾客更好的选择嘛!",这次发言的是继承经理的小弟.

"..."

"咳咳,我理解大家的心情,继承项目组确实在解决宠物分类上立下了很大功劳,大家为他们抱不平也是情理之中的事情,过去的就让他过去吧!当务之急,还是要解决现实问题!",主席首先安抚前几位激动情绪,又挑出重点提醒在场的各位回归到主题的讨论上,不要再揪住过去的功劳簿.

"我觉得,心急顾客的真正需求只是想要一种宠物,而不再关注宠物的种类,管他是猫是狗,只要是宠物就行.所以我们应该提供一种新的机制,对外宣传时只说这是宠物,至于这种宠物到底是猫还是狗,都可以!"

"猫和狗明明已经是宠物了啊,难道不可以直接卖给顾客吗?为啥还要提供新机制?"

"猫和狗虽然是宠物,但对于用户来说,这种宠物有点浪费了,用户实际使用到可能只是宠物的功能,并不会用到也不能用到具体子类的功能"

"哦哦,明白了,这就像是顾客需要的宠物是能卖萌的,是要送给女朋友作为礼物的,并不关心这个宠物能不能抓老鼠.所以对于抓老鼠的技能就是没用的,对于买家并不公平!"

经过一番激烈的讨论,大家基本上达成一致,先前存在的继承模型确实有些不足,不能适应快速变化的市场,过于强调差异性而非共性.

这样就导致无法满足急性子顾客批量购买的需求,所以需要提供类似于继承那种抽象的概念来表达约定,主要满足这种约定的动物就是宠物.

## 让继承变得更加抽象

透过现象看本质,从纷繁冗杂的事务中抽象出精简的模型是各个编程语言都必不可少的一个环节,`Go` 语言也不例外.

面向对象中的继承表达的语义是一种上下级的抽象关系,也就是说某一个封装对象是从属于某一个上级的封装对象的,它默认拥有父类的行为方法,这里的父类就是对所有子类共性的抽象实现.

当研究问题是具体的子类实现时,使用继承的概念,语义上比较清晰,子类只需要关注自己的特性,共性部分由父类去完成.

但是当我们研究的问题不再关注具体的子类实现而是着眼于父类的共性时,再提供具体的子类实现也能用,但是杀鸡焉用牛刀?

我仅仅需要一滴水,你却给了我整个海洋!

本来,只需要父类的某一个方法,你却提供给我一个具体的子类,这个子类不但有目标方法还是更多的其他方法.

你说浪费不浪费,不相当于捆绑销售嘛!

所以,我们需要对继承的概念进一步抽象,使其抽象到极致以至于只存在非常少量的行为方法,凡是继承自这种极致抽象的子类都是它的子民.

为了之后讨论方便,这种抽象到极致的继承称之为接口,看似只是称呼的改变,实际上思维方式上已经产生了翻天覆地的变化.

继承的概念是描述子类和父类的关系,子类继承自父类,关注点在子类,共性的方法由父类提供.

而接口的概念衍生于继承,抽象到了不能再抽象的部分,所有子类都要有一个最终的父类,这个父类拥有最公共性的行为方法,这种极致的抽象根本就无法体现出子类的共性行为的具体表现.此时这种极致的抽象没有太大的意义,非常非常宽泛的概念等于什么都没说,也适合绝大部分封装对象.

所以,干脆取消极致抽象中对于行为共性的实现,转而仅仅定义共性的行为,具体如何实现这种共性由具体子类自行决定.

这样做有两个显而易见的好处,一是解决了太宽泛概念等于没说的尴尬,同时保留了对共性行为的描述.二是将控制权转移到具体的子类实现,实现了体制内的个性化!

所以这种专业名词的转变背后是思维方式的转变,而接口更是很好地描述了这种转变的语义.

回忆一下生活总随处可见的 `USB` 数据线,对于计算机来说,对外暴露的是 `USB` 插口,行为描述是只要插入就能连接到电脑,同电脑进行交流.

基于接口设计,`USB` 数据线提供了访问电脑的能力,一端连着电脑,另一端连着手机,双方进行数据交换.
有线鼠标的数据线也提供了访问电脑的能力,实现鼠标的左击还是又击都能反馈到电脑.

诸如此类的案例不胜枚举,生活中不缺少计算机哲学,缺少的只是你的思考.

所以,如果让我来给这种机制进行命名的话,我可能会将其称呼为插口,意思是只要能适配指定的插口,那么就说满足插口要求,对外暴露的抽象概念是插口,真正的实现可能是数据线或者工具等.

不过,这只是我的一厢情愿,因为面向对象中这种机制叫做接口,满足接口的规范叫做实现了接口.

接口这种概念比较专业,提出这个概念的人也挺厉害的,基本上所有的面向对象语言中都采用了接口的概念,即使不是面向对象语言但支持面向对象编程风格的语言也采用了接口概念.

由此可见,接口的概念通俗易懂,可移值性比较强也获得相当高的认可度.

除了面向对象编程风格外,与接口相关的编程风格中还有一种叫做面向接口编程.

个人理解封装和继承的概念讲的就是面向对象编程,关注点在于具体的对象实现以及对象之间的层次关系.

而接口的出现则是另外一种维度的思考,当关注点不再是具体的子类而是抽象的父类时,这种情况下就抽象出接口的概念,高内聚部分仍然是封装的特性,低耦合则是接口的强项.

所以面向接口编程在应用而生,由此可见,不同的应用场景关注点不同,面向对象和面向接口也并不是互斥关系,是互补关系.

在未来的某种需求继续发生改变时,可能还会产生新的概念,进而提出新的一套理论,到时候是面向需求编程还是面向思维编程亦或是面向搜索编程就不得而知了!

## 如何设计又怎么实现



duck typing

大黄鸭是鸭子吗?

"像鸭子走路,像鸭子叫(长得像鸭子),那么就是鸭子"

描述事物的外部行为而非内部结构

严格说 go 属于结构化类型系统,类似 duck typing,动态绑定才是 duck typing

python 运行
c++ 编译

接口的实现

接口的实现是隐式的
只要实现接口的方法

接口变量里面哟什么

实现者的类型和实现者的值,或者实现者的指针

接口变量自带指针

接口变量同样采用值传递,几乎不需要使用接口的指针.

指针接收者实现只能以指针方式调用,值接收者均可
