# 初识接口

## 到底是要猫还是要狗

在上篇文章中编撰了一则简短的小故事,顺便讲解了什么是面向对象的继承特性以及 `Go` 语言如何实现继承语义.

不知道你是不是只停留在那则故事的表面,有没有继续深入思考挖掘更多有价值的信息?

为了照顾没有看到买宠物的故事,这里再简单复述一下故事,如需详细了解,请关注公众号[雪之梦技术驿站]查看[go 学习笔记之是否支持以及如何实现继承](https://mp.weixin.qq.com/s/w9ZfTAMr-mnQ9RK_Va-mEg)

A: 猫是一种宠物,淘气可爱会卖萌,看家本领抓老鼠,偶尔还会喵喵喵.
B: 狗是一种宠物,忠实听话能看家,嗅觉灵敏会破案,一言不合汪汪汪.
C: 我想要买一个宠物,文能卖萌,武可退敌,明个一早给我送来吧!

第二天,A和B各自带着自己的宠物来拜见C,并附上各自的理由,说的头头是道,C觉得有些哪里不对,可是竟无言反驳,只能悻悻收下了猫和狗,白白多花了一分钱!

上则故事很简单,现在的要求是,作为市场监督者,请问应该如何设计市场规则才能保证公平公正地进行交易?

在上篇文章中也给出了一种解决方案,那就是提炼出宠物的公共特性,猫和狗默认是宠物,对外展示时只需要暴露各自的特色,这样需要宠物的用户只需要关注差异亮点而不必在乎共同之处,交易双方沟通更加顺畅,相对公平!

-  宠物默认自带能文能武技能

```go
type Pet struct {
}

func (p *Pet) Skill() {
    fmt.Println("能文能武的宠物")
}
```

-  猫是宠物,还是抓老鼠.

```go
type Cat struct {
    p *Pet
}

func (c *Cat) Catch() {
    fmt.Println("老鼠天敌喵喵喵")
}
```

- 狗是宠物,还能认路导航.

```go

type Dog struct {
    p *Pet
}

func (d *Dog) Navigate() {
    fmt.Println("自带导航汪汪汪")
}
```

某一天,C要能文能武的宠物,最好还可以顺便帮我抓老鼠,于是C选择了喵喵喵!

```go
func TestExtendInstance(t *testing.T) {
    p := new(Pet)
    c := new(Cat)
    c.p = p

    // 老鼠天敌喵喵喵
    c.Catch()
    // 能文能武的宠物
    c.p.Skill()
}
```

过了一阵子,C觉得猫除了抓老鼠别的什么都不会,别人遛狗,我遛猫?于是,想要自带导航功能的宠物狗.

```go
func TestExtendInstance(t *testing.T) {
    p := new(Pet)
    d := new(Dog)
    d.p = p

    // 自带导航汪汪汪
    d.Navigate()
    // 能文能武的宠物
    d.p.Skill()
}
```

上述示例,简而言之就是通过组合的方式实现了面向对象中的继承特性,解决了猫和狗除了是宠物还是自己的问题.

## 猫狗随便是宠物就行

面对猫和狗两种宠物,C犯了选择困难症,于是第一次全盘接收买下了两种宠物.

紧接着市场部门开始介入,利用面向对象的继承特性,用 `Go` 语言实现了猫和狗的个性化与宠物的共同性,从此C再也不会面临选择困难症,每一次根据独特的需求,最终只会选择其中一种宠物,要么是猫,要么是狗.

不知过了多久,这种相安无事的情景最终被一群急性子的顾客所打破,一上来就吵吵嚷嚷说快给我宠物,快一点!

销售人员不紧不慢地说: "别着急,我们这里的宠物有很多种,有猫,有狗,有兔子,有金鱼,有乌龟,有蜗牛..."

"别整那些虚头巴脑的,我只要宠物,赶紧给我宠物就行,别尽扯没用的"

果然是一群急性子的顾客,还没等销售人员介绍完各个宠物的差异性亮点直接被打断了.

宠物市场吵吵闹闹引来了市场监督人员的注意,顾客和商家均上官方诉苦,期望能给出解决办法!

市场监督人员心想: 商家和顾客原本和谐相处的,今天怎么会吵闹起来?双方都没有过错,看来真的是市场赶不上需求,还是得尽快研究新的解决办法啊!

"冷静一下,你们的意见我们这边已经收到了,这样吧,给我们三天的时间,我们一定会想出一个万全之策,到时候再公布新的交易规则,现在我宣布暂时关闭交易,省的再惹出不必要的争端!"

原本吵吵嚷嚷的市场顿时冷却了不少,毕竟谁也不敢违抗市场老大的命令,众人只得悻悻而去,期待三天后的重新开市.



duck typing

大黄鸭是鸭子吗?

"像鸭子走路,像鸭子叫(长得像鸭子),那么就是鸭子"

描述事物的外部行为而非内部结构

严格说 go 属于结构化类型系统,类似 duck typing,动态绑定才是 duck typing

python 运行
c++ 编译

接口的实现

接口的实现是隐式的
只要实现接口的方法

接口变量里面哟什么

实现者的类型和实现者的值,或者实现者的指针

接口变量自带指针

接口变量同样采用值传递,几乎不需要使用接口的指针.

指针接收者实现只能以指针方式调用,值接收者均可
