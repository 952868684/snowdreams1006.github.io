# 再说封装

在上篇文章中,我们尝试了 `Go` 语言中面向对象的写法,通过已有的运用已有的编程经验逐步试错接近 `Go` 的面向对象实现.

由于是探索式学习,只在乎过程和结果并没有特别注重知识的相关性.

如果用走迷宫来比喻的话,一条道走到黑,直到走到终点这种策略就是深度优先算法.如果边走边看,四处观望周围的风景也能走到终点,这种策略就是广度优先算法.

深度优先目标明确,正如探索面向对象编程,首先设计对象的存储结构,然后实例化结构,有了对象就能使用相应的数据.当然这个对象可能不仅仅只有数据还有对象的行为,那就探索如何实现行为,发现了只需要将函数稍稍改变一下就能实现方法.这样对象的属性和方法都探索完成,一个对象也就完成了,走到了迷宫的终点.

可是从始至终,我们都没有留意周围的花香,只要找到一条正确的路就继续往下走,完全不管有没有其他的路可以走,所以最终结我们只知道一条正确的路,有没有其他的路就不知道了.

等回过神来,有个闲情逸致可以好好欣赏周围的风景,闻一闻周围的花香,不在乎找到路而注重总共能找到多少条路.

广度优先算法告诉我们,边走边看地毯式推进,这样能收获最大,可想而知耗费的精力也越多.

## 定义结构体

定义结构体的方式只有这么一种,不存在其他的简化形式?我觉得不会不存在,结构体存在多个属性的话用下面的方式定义是合理的,如果属性只有一个的话,此时这种形式的结构体应该可以进行简化.

```go
type MyDynamicArray struct {
    ptr *[10]int
    len int
    cap int
}
```

所谓的结构体只不过是实现封装的一种手段而已,当封装的对象只有一种属性,这个属性也就不存在属性名或者说这个唯一的属性名应该就可以由编译器级别进行定义,属性的类型自然是不可以少的,这么想的话,对于封装只有一个属性对象来说,只需要考虑的是这个唯一属性的类型.

所以,我觉得是这种猜想是合理的,但是按照已有的知识能否实现呢?

```go
type MyDynamicArray struct {
    ptr *[10]int
    len int
    cap int
}
```
