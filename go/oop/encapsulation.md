# 再说封装

在上篇文章中,我们尝试了 `Go` 语言中面向对象的写法,通过已有的运用已有的编程经验逐步试错接近 `Go` 的面向对象实现.

由于是探索式学习,只在乎过程和结果并没有特别注重知识的相关性.

如果用走迷宫来比喻的话,一条道走到黑,直到走到终点这种策略就是深度优先算法.如果边走边看,四处观望周围的风景也能走到终点,这种策略就是广度优先算法.

深度优先目标明确,正如探索面向对象编程,首先设计对象的存储结构,然后实例化结构,有了对象就能使用相应的数据.当然这个对象可能不仅仅只有数据还有对象的行为,那就探索如何实现行为,发现了只需要将函数稍稍改变一下就能实现方法.这样对象的属性和方法都探索完成,一个对象也就完成了,走到了迷宫的终点.

可是从始至终,我们都没有留意周围的花香,只要找到一条正确的路就继续往下走,完全不管有没有其他的路可以走,所以最终结我们只知道一条正确的路,有没有其他的路就不知道了.

等回过神来,有个闲情逸致可以好好欣赏周围的风景,闻一闻周围的花香,不在乎找到路而注重总共能找到多少条路.

广度优先算法告诉我们,边走边看地毯式推进,这样能收获最大,可想而知耗费的精力也越多.

## 定义结构体

定义结构体的方式只有这么一种,不存在其他的简化形式?我觉得不会不存在,结构体存在多个属性的话用下面的方式定义是合理的,如果属性只有一个的话,此时这种形式的结构体应该可以进行简化.

```go
type MyDynamicArray struct {
    ptr *[10]int
    len int
    cap int
}
```

所谓的结构体只不过是实现封装的一种手段而已,当封装的对象只有一种属性,这个属性也就不存在属性名或者说这个唯一的属性名应该就可以由编译器级别进行定义,属性的类型自然是不可以少的,这么想的话,对于封装只有一个属性对象来说,只需要考虑的是这个唯一属性的类型.

所以,我觉得是这种猜想是合理的,但是按照已有的知识能否实现呢?先审视一下上篇文章中关于动态数组的声明.

```go
type MyDynamicArray struct {
    ptr *[10]int
    len int
    cap int
}
```

如果一定要从三个属性中选择一个属性,那只能是保留内部数组,排除其余两个属性,可能实现不了动态数组的功能,语义上有所欠缺.

但是这仅仅是实验,实际情况中可能存在只有一个属性的例子,只不过用动态数组举例不太适合.

只保留内部数组,于是动态数组变成这样,由于失去了动态数组的语义,命名上也做了改变,姑且称之为 `MyArray` 吧!

```go
type MyArray struct {
    arr [10]int
}
```

很明显,现在仍然是结构体的标准语法形式,思考一下如何简化这种形式,因为这种简化形式的内部属性只有一个,所以属性名必须省略而属性类型可能不同,因此应该在简化形式中只保留声明内部属性类型的部分.

```go
type MyArray struct {
    [10]int
}
```

多个属性才需要换行分割,一个属性自然是不需要换行的,因此大括号也是没必要存在的,这也是符合 `Go` 设计中尽可能精简的情况下保证语义清晰的原则.

当然是否真的有什么原则的话,可能会有也可能没有,我也不知道,只是感觉处处体现了这么一种哲学思想,不用较真,只是个人立场看法.

```go
type MyArray struct [10]int
```

现在这种形式应该可以算是只有一种属性的结构体的简化形式,`struct` 语义上指明了 `MyArray` 是结构体,紧随后面的 `[10]int` 语义上表示结构体的类型,整体上就是说 `MyArray` 结构体的类型是 `[10]int` .

现在让我们在编辑器中测试一下,看一看 `Go` 的编译会不会报错,能否支持我们的猜测呢?

![go-oop-encapsulation-struct-sole-error.png](../images/go-oop-encapsulation-struct-sole-error.png)

编辑器告诉我们 `[10]int` 不合法,必须是类型或类型指针!

可 `[10]int` 确实是我们需要的类型,既然报错也就是说不支持这种简化形式,可能是 `struct` 关键字不支持,那就去掉这个关键字好了!

![go-oop-encapsulation-struct-sole-success.png](../images/go-oop-encapsulation-struct-sole-success.png)

没想到真的可以!至少现在看来编译器是支持的,至于这种支持的形式是不是和我们预期实现的语义一致还不好说,继续做实验探索.

![go-oop-encapsulation-struct-sole-test.png](../images/go-oop-encapsulation-struct-sole-test.png)

通过简单的声明变量后直接打印输出初步证明了我们这种简化形式是可以正常工作的,输出结果也是我们定义的内部数组.

接下来看一看能不能对这个所谓的内部数组进行操作呢,这种简化形式只有一个属性,指明了属性的类型,不需要属性名或者说不能要属性名,访问该属性应该直接通过结构体的变量访问,这种思路对不对呢?

```go
type MyArray [10]int

func TestMyArray(t *testing.T) {
	var myArr MyArray

	// [0 0 0 0 0 0 0 0 0 0]
	t.Log(myArr)

	myArr[0] = 1
	myArr[9] = 9

	// [1 0 0 0 0 0 0 0 0 9]
	t.Log(myArr)
}
```

猜想得到验证,`Go` 编译器也是通过结构体变量直接操作内部属性的,看来这一次是猜对了!

先别急着高兴,将唯一的属性换成其他类型多测试几遍看看是否依然正常?

```go
type MyBool bool

func TestMyBool(t *testing.T) {
	var myBool MyBool

	// false
	t.Log(myBool)

	myBool = true

	// true
	t.Log(myBool)
}
```

一番测试后并没有报错,很有可能这是 `Go` 所支持的结构体简化形式,和我们的预期一致.

关于结构体属性的语法规则暂时没有继续探索的新角度,只有一个属性的结构体也确实存在简化形式,那结构体的定义上还剩下方法.

接下来我们尝试着探索方法有没有隐藏技能,完全利用已知知识去推测未知,探索的过程中要尽可能的设身处地思考 `Go` 语言应该如何设计才能方便使用者.

![go-oop-encapsulation-struct-sole-method.png](../images/go-oop-encapsulation-struct-sole-method.png)

结构体的简化形式下并不支持方法,仔细想一想这样做也是有理可循的,完全可以推测出来.

首先单纯地进行语法层面分析,为什么单属性的结构体不支持方法?

还记得我们想要简化单属性结构体遇到的报错提示吗?

```go
type MyArray struct [10]int
```

直接将单属性的类型放到 `struct` 关键字后面,编译器会报错,当我们省略 `struct` 关键字时上述报错就消失了.

从编译器的角度上来讲,`struct` 是系统关键字,告诉编译器只要遇到这个字就解析成结构体的语法,现在没有遇到结构体关键字也就意味着不是结构体语法.

关键字和结构体是一一对应,充分必要条件,由关键字可以推测到结构体,由结构体也可以推测到关键字.

再回来看一看,我们的单属性结构体定义上是怎么写的?

```go
type MyArray [10]int
```

因为没有关键字 `struct` ,所以编译器推断 `MyArray` 不是结构体,既然不是结构体,也不能用结构体的接收者函数去定义方法.

```go
func (myBool *MyBool) IsTrue() bool{
	return myBool
}
```

所以这种方法就会报错,并不支持单属性结构体的方法.

从语法层面解释了为什么不支持,现在我们从语义的角度上解释一下为什么不支持方法?

回到探索的初衷,当正在定义的结构体有多个属性时应该按照标准写法为每个属性指定属性的名称和类型,假如该属性有且只有一个时,再按照标准写法定义当然可以,但也应该提供更加简化的写法.

只有一个属性的结构体,属性的名称是没有意义的也是不应该出现的,因为完全可以用结构体变量所代替,此时这个结构体有存在价值的就是属性的类型.

类型包括内建类型和用户自定义类型,因而这种形式的结构体的语义完全由该结构体到属性类型所决定,而属性类型还需要方法吗?

自然是不需要的!属性类型应该是该属性类型自己定义的,这样才能确保职责清晰,彼此分离!

综上,个人觉得 `Go` 的设计还是有章可循的,是可以进行推测性学习,单属性的结构体不能也不应该能定义方法.

单属性的结构体不支持方法,此路不通,原路返回,接着继续探索方法.



## 声明结构体

 