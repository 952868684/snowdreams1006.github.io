{"./":{"url":"./","title":"简介","keywords":"","body":"简介 教程分享均是笔者亲身学习经验总结,涉及到的知识点均亲身试验,但有时为了知识完整性,可能并未亲自确认,对于这部分内容会明确指出,到时由读者确认试验. 如果读者实际运行效果和教程演示效果有出入,很可能是版本问题,系统环境等原因,希望能及时反馈,避免更多人踩坑,谢谢! 特点 面向初学者,适合零基础入门; 面向常用操作,技能实用性强; 情景教学,理清事情来龙去脉; 章节重点知识小结,精华集锦; 要求 保持哲学三问,是什么,为什么,怎么样?希望最终能有你自己的答案; 好记性不如烂笔头,亲自动手操作一遍,你会发现你的理解更上一层楼; 授人以鱼不如授人以渔,希望带给你不仅仅是知识更多的是学习的方法; 知识重在分享才有价值,鼓励知识传播与分享,创造收益更有价值; 因本人能力有限,如有出入,敬请指正,请联系我 snowdreams1006 说明 本教程源码托管在 snowdreams1006.github.io ,在线访问地址 https://snowdreams1006.github.io/ 如果你觉得本教程对你有所帮助,请不吝 Star. 如果你想贡献一份力量,欢迎提交 Pull Request. © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-28 10:07:12 "},"markdown/":{"url":"markdown/","title":"markdown 快速入门","keywords":"","body":"markdown 快速入门 markdown 不止是 HTML 的简化版,更重要的是 txt 的升级版,word 的轻量版,是笔记的最佳载体. markdown 作为一种简单的格式标记语言,不同于 txt 的无格式,不同于 HTML 的复杂标记,也不同于 word 的鼠标调整样式. markdown 通过简单的几个字符键入,就可以快捷的定义文档的样式. 掌握 markdown,你可以完全抛弃 txt 和笔记软件的编辑器,并且在大多数场景下替代掉复杂臃肿的 word.享受简洁之美、享受效率提升. 下面列举了 markdown 语法及对应的示例： 标题 在标题文字前面加#,并且加上空格分割. 一个#是一级标题,两个#是两级标题,以此类推,最多支持六级标题. 示例: # 标题1 ## 标题2 ### 标题3 #### 标题4 ##### 标题5 ###### 标题6 效果: 标题1 标题2 标题3 标题4 标题5 标题6 列表 包括有序列表和无序列表,支持列表嵌套. 有序列表 有序列表就是有顺序的列表,依靠行前的数字加.标记顺序,序号和内容之间以空格 分开. 示例: 1. 有序列表1 2. 有序列表2 3. 有序列表3 效果: 有序列表1 有序列表2 有序列表3 无序列表 无序列表就是列表不排序,支持- * + 3种前缀,可用于表示1级列表,2级列表,3级列表. 示例: - 无序列表1 * 无序列表2 + 无序列表3 效果: 无序列表1 无序列表2 无序列表3 列表嵌套 上一级和下一级列表之间空两个空格 即可表示列表嵌套. 示例: - 无序列表1 * 无序列表11 * 无序列表12 * 无序列表13 + 无序列表131 + 无序列表132 + 无序列表133 - 无序列表2 - 无序列表3 效果: 无序列表1 无序列表11 无序列表12 无序列表13 无序列表131 无序列表132 无序列表133 无序列表2 无序列表3 引用 在引用文字前加一个>即可,支持引用嵌套. 示例: > 引用1 >> 引用11 >>> 引用111 效果: 引用1 引用11 引用111 字体 粗体 要加粗的文字左右两边分别用两个 * 号或者 _ 号包围起来 斜体 要倾斜的文字左右两边分别用一个 * 号或者 _ 号包围起来 粗体+斜体 要加粗并倾斜的文字左右两边分别用三个 * 号或者 _ 号包围起来 删除线 要删除的文字左右两边分别用两个 ~ 号包围起来 示例: **粗体1** __粗体2__ *斜体1* _斜体2_ ***粗体+斜体1*** ___粗体+斜体2___ ~~删除线~~ 效果: 粗体1 粗体2 斜体1 斜体2 粗体+斜体1 粗体+斜体2 删除线 分割线 三个或三个以上的- *即可表示分割线 示例: --- *** 效果: 图片 其中,图片alt表示图片的解释文字,图片src是图片地址,支持本地路径和网络路径,图片title是图片的标题,可选. 示例: ![preview.png](images/preview.png \"preview.png\") 效果: 超链接 超链接text 其中,超链接text表示超链接的解释文字,超链接url支持本地路径和网络路径,超链接title是超链接的标题,可选. 示例: [https://snowdreams1006.github.io](https://snowdreams1006.github.io \"snowdreams1006\") 效果: https://snowdreams1006.github.io 表格 第一行定义表头,单元格内定义标题; 第二行定义样式,单元格内部至少一个-,文字默认居左对齐,单元格内部-两侧均加:表示居中,只有右侧加:表示居右对齐; 第三行定义数据; 示例: |默认居左|文字居中|文字居右| |-|:-:|-:| |居左对齐1|居中对齐1|居右对齐1| |居左对齐2|居中对齐2|居右对齐2| |居左对齐3|居中对齐3|居右对齐3| 效果: 默认居左 文字居中 文字居右 居左对齐1 居中对齐1 居右对齐1 居左对齐2 居中对齐2 居右对齐2 居左对齐3 居中对齐3 居右对齐3 代码 单行代码 代码两侧分别用一个反引号包围起来 示例: `code` 效果: code 多行代码 代码块首尾分别用三个反引号包围起来,且两边的反引号独占一行 示例: (```) function fun(){ echo \"这是一句非常牛逼的代码\"; } fun(); (```) 注：为了防止转译,前后三个反引号处加了小括号,实际是没有的. 效果: function fun(){ echo \"这是一句非常牛逼的代码\"; } fun(); 注释 示例: 效果: 看不到注释就对了! 都学会了吗? 那考考你,你猜当前文档是如何书写的,看看你的答案和我实际书写规则是否一致呢! 答案请参考snowdreams1006.github.io 参考文献 https://daringfireball.net/projects/markdown/syntax http://www.markdown.cn/ https://www.appinn.com/markdown/index.html © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"markdown/juejin.html":{"url":"markdown/juejin.html","title":"掘金入门指南","keywords":"","body":"掘金入门指南 用掘金－Markdown 编辑器写文章 欢迎使用 掘金－Markdown 编辑器撰写技术文章，只专注于内容和技术，不再费心排版的问题。这是一份简要的 Markdown 引导指南，希望可以帮助您顺利的开始使用 Markdown 编辑器。 丰富的快捷键 本 Markdown 编辑器支持丰富的格式快捷键，可以非常便捷、轻松的使用 Markdown 语言，形成优美的排版和内容格式。 支持的快捷键有： 加粗： Ctrl/Cmd + B 标题： Ctrl/Cmd + H 插入链接： Ctrl/Cmd + K 插入代码： Ctrl/Cmd + Shift + C 行内代码： Ctrl/Cmd + Shift + K 插入图片： Ctrl/Cmd + Shift + I 无序列表： Ctrl/Cmd + Shift + L 撤销： Ctrl/Cmd + Z 常用语法 标题 语法格式： '#'+'空格'+'文本' 一级标题 二级标题 三级标题 四级标题 五级标题 六级标题 列表 无序列表语法格式： '-' + '空格' ＋ '文本' 文本一 文本二 文本三 有序列表语法格式： '数字' + '.' + '空格' + '文本' 文本一 文本二 文本三 任务列表语法格式： '-' + '空格' + '[ ]' + '文本' [x] 文本一 [ ] 文本二 [ ] 文本三 链接和图片 在 Markdown 中插入链接不需要其他按钮，你只需要使用［显示文本］(链接地址)这样的格式语法即可。例如： 稀土掘金 插入图片的语法与插入链接的语法很像，只是前面多了一个 !.语法如下： ![图片的标注](图片链接地址) 引用 语法： '>'+'空格'+'文本' 例如： Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 代码 如下是代码段的语法： ```编程语言 这是代码段 ``` 例如： def bubbleSort(alist): for passnum in range(len(alist)-1,0,-1): #print alist,passnum for i in range(passnum): if alist[i]>alist[i+1]: temp = alist[i] alist[i] = alist[i+1] alist[i+1] = temp return alist 表格 Markdown　Extra　表格语法： 项目 价格 iPhone $560 iPad $780 iMac $1000 可以使用冒号来定义对齐方式： 项目 价格 数量 iPhone 6000 元 5 iPad 3800 元 12 iMac 10000 元 234 结语 以上是最常见的 Markdown 的语法和格式，如果你还希望深入的学习 Markdown，可以参考这里Markdown语法，非常感谢使用 掘金－Markdown 编辑器,希望为您提供舒适的写作体验。 © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"markdown/imooc.html":{"url":"markdown/imooc.html","title":"慕课网语法演示","keywords":"","body":"慕课网语法演示 欢迎使用慕课网 - Markdown 编辑器 Markdown 编辑器使用一套简单实用的标记语言来实现简单的文本排版，可以让你专注于键盘码字而非排版，化繁为简，回归写作本质，带来前所未有的书写体验！ 我们在工具栏提供了丰富的快捷键，可以使用它们标记不同的标题，将一些文字标记为粗体或者斜体，也可以创建一个链接或者插入一张很有气质的图片。如需了解更多语法请使用快捷键“Ctrl + /”查看帮助。 常用语法使用说明 标题 规范的语法格式：“#+空格+文本” 举例如下： 一级标题 二级标题 三级标题 四级标题 五级标题 六级标题 引用 规范的语法格式：“>+空格+文本” 举例如下： 我是一段被引用的文本，请熟记它的语法格式 图片 规范的语法格式：“![图片描述](图片链接地址)” 我们推荐你是用快捷工具来添加图片 超链接 规范的语法格式：“[链接描述](链接地址)” 举例如下： 欢迎使用慕课网手记 无序列表 规范的语法格式：“- + 空格 ＋ 文本” 文本一 文本二 文本三 有序列表 规范的语法格式：“数字 + 空格 ＋ 文本” 文本一 文本二 文本三 代码 规范的语法格式： ```代码语言（填写了代码语言才会显示代码高亮） 在这里输入代码 ``` 举例如下： def quick_sort(qlist): if qlist == []: return [] else: qfirst = qlist[0] qless = quick_sort([l for l in qlist[1:] if l = qfirst]) return qless + [qfirst] + qmore qlist = quick_sort([4,5,6,7,3,2,6,9,8]) print qlist 表格 规范的语法格式如下： 姓名 身高 体重 小明 175CM 75KG 小李 168CM 70KG 小张 185CM 80KG 使用冒号设置表格内容对齐方式： 品牌 价格 售出 奥迪Q7 900000 元 5000辆 大众GOLF6 150000 元 70000辆 哈佛M6 70000 元 200000辆 感谢阅读慕课网 - Markdown 编辑器使用说明。马上开始前所未有的编辑体验吧。 © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"markdown/HBuilderX.html":{"url":"markdown/HBuilderX.html","title":"HBuilderX语法帮助","keywords":"","body":"HBuilderX语法帮助 markdown - 更简洁、更高效 ================================================= 强烈建议开发者认真阅读本文档，掌握md及HBuilderX对md的强大支持。 如果没有点右键设置自动换行，可按Alt+滚轮横向滚动查看。 很多人只把markdown用于网络文章发表，这糟蹋了markdown。 markdown不止是HTML的简化版，更重要的是txt的升级版、word的轻量版、笔记的最佳载体。 作为一种简单的格式标记语言，不同于txt的无格式，不同于HTML的复杂标记，也不同于word的鼠标调整样式。markdown通过简单的几个字符键入，就可以快捷的定义文档的样式。 比如在行首敲一个“#”，就把这行定义为了1级标题，并且在HBuilderX里有直观完善的着色，这样无需发布为web页面，可直接当word用。 掌握markdown，你可以完全抛弃txt和笔记软件的编辑器，并且在大多数场景下替代掉复杂臃肿的word。享受简洁之美、享受效率提升。 而HBuilderX，可以被称为最强大的markdown书写工具了。 下面的示例列举了markdown语法及对应的HBuilderX使用技巧： 开始前，可以先按下文档结构图的快捷键Alt+w（Mac是Ctrl+w），浏览本文的大纲。 标题语法 markdown的标题是行首以#号开头，空格分割的，不同级别的标题，在HX里着色也不同。如下： 标题1 标题2 标题3 标题4 标题5 标题6 标题使用技巧： Emmet快速输入：敲h2+Tab即可生成二级标题【同HTML里的emmet写法，不止标题，HX里所有可对应tag的markdown语法均支持emmet写法】。仅行首生效 智能双击：双击#号可选中整个标题段落 智能回车：行尾回车或行中Ctrl+Enter强制换行后会自动在下一行补#。而连续2次回车后将自动补的#去掉。(体验同word) 回车后再次按Tab可递进一层标题，再按Tab切换列表符 在# 后回车，可上插一个空标题行【同word】，或任意位置按Ctrl+Shift+Enter也可以上插空标题行 折叠： 点标题前的-号可折叠该标题段落，快捷键是Alt+-（展开折叠是Alt+=） 多层折叠时折叠或展开子节点，快捷键是Alt+Shift+-或= 全文全部折叠或展开，快捷键是Ctrl+Alt+Shift+-或= 折叠其他区域，快捷键是Alt+Shift+o。这对长文档管理非常有用，可以专注于当前章节 可以在菜单-跳转-折叠中随时找到这些功能 列表 markdown的列表支持有序列表、无序列表以及特殊的任务列表。 同样也是在行前加一个特殊符号，并空格后再跟列表文字内容。 有序列表 有序列表就是有顺序的列表，依靠行前的数字标记顺序。 有序列表1 【设置或取消有序列表符的快捷键：Ctrl+Alt+1，可选中多行批量设置序号；支持多光标批量设置列表符，即按Ctrl+鼠标左键添加多光标】 有序列表2 【列表后回车会自动补序号】 有序列表3 【智能双击：双击前面的数字，可重新对数字排序，修正序号错误，并选中有序列表段落（左边的4是故意写错让你体验的）】 无序列表 无序列表就是列表不排序，无序列表因书写随意而被更广泛的使用。 无序列表有3种前缀，HX里分别用于表示1级列表、2级列表、3级列表。 无序列表1 【快捷键：Ctrl+Alt+-；智能双击：双击-号可选中整段无序列表；再次按Tab会更换二级列表符】 无序列表2 Emmet：li后敲Tab可生成*号列表符，行首生效 快捷键：Ctrl+Alt+8【8即*对应的数字】，支持多光标批量设置列表符，即按Ctrl+鼠标左键添加多光标 智能双击：双击*号可选中整段无序列表 智能回车：行尾回车或行中Ctrl+Enter强制换行后会自动续列表；连续按回车会清除列表符；再次按Tab会更换列表符；在列表符后回车或行尾Shift+回车，上一行留出列表符 *号常用于二级列表，列表符后继续Tab，可切换列表符 无序列表3 【快捷键：Ctrl+Alt+=；常用于三级列表；其他同上】 任务列表 任务列表非常实用，管理待办已办非常便利。 [ ] 任务列表-未完成任务 【快捷键：Ctrl+Alt+[】 [x] 任务列表-已完成任务 【快捷键：Ctrl+Alt+]】 1. 智能双击：双击方括号内可切换勾选状态，把任务标记为完成或未完成；双击方括号右侧可选中任务列表段落 2. 智能回车：回车后自动补任务列表前缀符号；连续按回车清除前缀符号；在列表符后回车或行尾Shift+回车，上一行留出列表符 以上三种列表，均支持批量修改列表符，有如下方式建议依次学习尝试： 选中多行，按快捷键Ctrl+Alt+“1”或“-”或“[”或“]”，批量设置列表符 如果需要跳行设置有序或无序列表，通过Ctrl+鼠标左键点中目标多行（可不连续），产生多光标，然后按快捷键Ctrl+Alt+“1”或“-”或“[”或“]”，可跳行设置列表符，尤其是有序列表，数字也会跳行加1 按Alt+鼠标选中行首那列（列选择），这样每行行首都有光标，然后再键入或删除列表符即可批量操作 选中多行，按快捷键Ctrl+Shift+\\（其实就是Ctrl+|），可以在每行行首添加一个光标 引用列表 引用1 引用2 快捷键：Ctrl+Alt+Shift+. 智能双击：双击>号可选中整段引用列表 智能回车：行尾回车或行中Ctrl+Enter强制换行后会自动续列表；连续按回车会清除列表符；在列表符后回车或行尾Shift+回车，上一行留出列表符 文字样式语法 加粗 【快捷键：Ctrl+B，支持多光标；Emmet：b后敲Tab】 加粗2 倾斜【Emmet：i后敲Tab；前后包围：选中文字按Ctrl+\\是在选区两侧添加光标，可以继续输入】 倾斜 删除线 单行代码 包围插入：先选中文字内容，然后按*~`等符号，会自动在2侧加包围 智能双击：双击语法区前面的定义符号，选中包含定义符的整段文字 去包围：选中整段文字后，按Ctrl+Shift+]，可去除2侧包围符号 引号括号虽然不属于markdown语法，但也支持相同的包围、选择、去包围操作。 引号括号智能双击选择时略特殊的是：双击引号括号内侧，选中引号括号里的内容(不含引号括号)；按下Alt+双击引号括号内侧，则选中包含符号的整段文字 HBuilderX还支持以下对2侧文本高效处理的手段 选中文字按Ctrl+\\是在选区两侧添加光标，可以继续输入~~，会在2侧同时输入 向2侧扩大选择：【Win:Alt+Shit+→ 、Mac:Ctrl++Shit+→】；由2侧向内减少选择：【Win:Alt+Shit+← 、Mac:Ctrl++Shit+←】 链接文字 Emmet：a后敲Tab 打开链接：Alt+鼠标单击；如果是本地文件，可通过Shift+Alt+单击，在另一分栏打开文件 智能粘贴：粘贴URL会自动变成超链接格式；粘贴本地文件进来也会自动创建引用链接 智能双击：双击语法区开头，即[左侧，选中包含定义符的整段文字 Emmet：img后敲Tab 智能粘贴：粘贴剪切板里的图形时会自动保存为本md文档的附件；删除文档中的图片语法，保存md文档时会自动删除对应的图片附件；粘贴图片文件时自动变成链接引用格式； 悬浮预览：鼠标移到图片语法上，本地图片会自动显示出来 智能双击：双击语法区开头，即!左侧，选中包含定义符的整段文字 表格 Emmet：table3*3后敲Tab，表示生成3行3列的表格，行首生效 md表格对齐是传统md的痛点，HBuilderX按下Ctrl+K可以自动整理表格格式（暂未兼容不同缩放模式和字体的情况） 支持从excel、wps、word、number的表格中复制粘贴表格进来（不支持合并单元格和单元格换行） 分割线 ------------- 【Emmet：hr后敲Tab】 * 代码区 var a = document Emmet：code后敲Tab，行首生效 智能双击：双击语法区开头，即!左侧，选中包含定义符的整段文字 注释 快捷键：Ctrl+/ 智能双击：双击注释首尾的定义符，选中整段注释 其他emmet快捷输入 day后敲Tab，当前日期。注意day需在行首或前面有空格 time后敲Tab，当前时间。注意time需在行首或前面有空格 文档结构图 文章很长时，word里有文档结构图，HBuilderX也有。 菜单视图-文档结构图，快捷键Alt+W(mac是ctrl+W)，轻松管理长文档 运行、预览和打印PDF 对md文件点工具栏或菜单里的浏览器运行，可以使用外部浏览器预览此md文件，会自动渲染为HTML。 点右上角的预览【快捷键Alt+p】，可在HBuilderX右侧预览该md文档的HTML渲染结果。 在浏览器中点打印，选择打印到PDF，可将md输出为PDF格式。（注意在打印选项里去掉页眉页脚） 其他常用但你可能不知道的快捷操作技巧 Ctrl+鼠标左键添加多光标，然后敲字或粘贴，可批量处理。Ctrl+鼠标左键拖选，可选中多个选区。 Ctrl+鼠标右键删除多光标 不选内容按Ctrl+C或X可复制或剪切整行 选中2个选区后，按Ctrl+Shift+X，可互换选区内容。如无选区，只是2个光标，则互换2行 Ctrl+上下键可上下移动行 Ctrl+Insert可重复插入当前行，如果有选中内容，可重复插入选中内容 Ctrl+Shift+K可合并多行（是格式化Ctrl+K的反操作） 删除 按Ctrl+D可删除选中行，支持多光标 Shift+Del删除到行尾 Shift+Backspace删除到行首 选择 Ctrl+E选相同词(mac是Command+D)，连续按可选中多词进一步操作，比替换更方便 Ctrl+L可连选多行，Ctrl+Shift+L也是选择行，但不选行首尾的空白字符 Ctrl+=可逐级放大选区 双击标题、列表符可选中相应段落 双击英文引号、括号内侧，可选中内部内容 双击缩进符，可选中同缩进段落 双击连字符比如-或_，可选中相连的词，比如双击这里试试，uni-app 查找 Ctrl+P查找文件 Ctrl+Alt+F可在当前目录的所有文档中搜索指定关键字(mac是Command+Shift+f) 选中文字按F3，查找下一个，Shift+F3找上一个 云同步：HBuilderX+markdown用于云同步笔记的技巧，请参考http://ask.dcloud.net.cn/article/13097 都学会了吗？ markdown语法其实很简单，认真学半小时就能掌握。 HBuilderX的极客操作则需要不停反复练习，熟练掌握这些技巧，你将成为高效极客！ © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"markdown/csdn.html":{"url":"markdown/csdn.html","title":"csdn帮助文档","keywords":"","body":"csdn帮助文档 快捷键 撤销：Ctrl/Command + Z 重做：Ctrl/Command + Y 加粗：Ctrl/Command + B 斜体：Ctrl/Command + I 标题：Ctrl/Command + Shift + H 无序列表：Ctrl/Command + Shift + U 有序列表：Ctrl/Command + Shift + O 检查列表：Ctrl/Command + Shift + C 插入代码：Ctrl/Command + Shift + K 插入链接：Ctrl/Command + Shift + L 插入图片：Ctrl/Command + Shift + G 标题 1级标题 2级标题 3级标题 四级标题 五级标题 六级标题 文本样式 强调文本 强调文本 加粗文本 加粗文本 ==标记文本== 删除文本 引用文本 H~2~O is是液体。 2^10^ 运算结果是 1024。 列表 项目 项目 项目 项目1 项目2 项目3 [ ] 计划任务 [x] 完成任务 链接 链接: https://snowdreams1006.github.io. 图片: 代码片 下面展示一些 内联代码片。 // A code block var foo = 'bar'; // An highlighted block var foo = 'bar'; 表格 项目 Value 电脑 $1600 手机 $12 导管 $1 Column 1 Column 2 centered 文本居中 right-aligned 文本居右 自定义列表 Markdown : Text-to-HTML conversion tool Authors : John : Luke 注脚 一个具有注脚的文本。1 1. 注脚的解释 ↩ 注释 Markdown将文本转换为 HTML。 *[HTML]: 超文本标记语言 LaTeX 数学公式 Gamma公式展示 $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ 是通过 Euler integral $$ \\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt\\,. $$ 插入甘特图 gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section 现有任务 已完成 :done, des1, 2014-01-06,2014-01-08 进行中 :active, des2, 2014-01-09, 3d 计划中 : des3, after des2, 5d 插入UML图 sequenceDiagram 张三 ->> 李四: 你好！李四, 最近怎么样? 李四-->>王五: 你最近怎么样，王五？ 李四--x 张三: 我很好，谢谢! 李四-x 王五: 我很好，谢谢! Note right of 王五: 李四想了很长时间, 文字太长了不适合放在一行. 李四-->>张三: 打量着王五... 张三->>王五: 很好... 王五, 你怎么样? 插入Mermaid流程图 graph LR A[长方形] -- 链接 --> B((圆)) A --> C(圆角长方形) B --> D{菱形} C --> D 插入Flowchart流程图 flowchat st=>start: 开始 e=>end: 结束 op=>operation: 我的操作 cond=>condition: 确认？ st->op->cond cond(yes)->e cond(no)->op © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"git/":{"url":"git/","title":"git 入门教程","keywords":"","body":"git 入门教程 git 是分布式版本控制系统,是文本文档管理的利器,是帮助你管理文件动态的好帮手. 如果你曾经手动管理过文档,一定有这样的经历,比如你正在编辑文档,想删除某段落,又担心不久后可能会恢复,此时你可能会先备份然后再删除,或者想要修改某段落,几经修改后发现还是最初的比较好,这是就哭笑不得了... 从最初的新建文档,经过反反复复的修改,最终定稿文档的过程极其繁琐冗长,这就是手动式管理文档的痛点. 如果有这么一种工具,能帮我自动记录每次文档的改动,想要查看文档变更详情只需要打开软件就能一目了然告诉我发生了哪些改变?岂不美哉! 版本 文件 用户 说明 时间 1 README.md snowdreams1006 初始化简介文档 2019-03-01 08:00 2 README.md snowdreams1006 增加特点说明 2019-03-01 10:00 3 README.md snowdreams1006 增加要求说明 2019-03-01 12:00 事实上,还真有这样的软件,专业术语称为版本控制系统,而git就是最先进的分布式版本控制系统; 特点: 文件的变更从此有迹可循,再也不怕丢失文件; 有网无网均可工作,数据交换不需再相互拷贝; 人人平等的开放环境,有机会贡献自己的智慧; 本书发表在 https://snowdreams1006.github.io/git/ © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"git/base/about.html":{"url":"git/base/about.html","title":"初识 git","keywords":"","body":"初识 git git 是一个开源的分布式版本控制系统,用于敏捷高效地处理任何或小或大的项目. 背景 我们都知道,Linus 在1991年创建了开源的linux系统,随着不断发展壮大,目前已发展成为最大的服务器系统软件. Linus 虽然创建了 linux,但 linux 的发展壮大是靠全世界热心的志愿者参与贡献的,这么多人在世界各地为linux系统编写代码,那么linux的代码是如何管理呢? 事实上,在2002年以前,世界各地的志愿者直接将源代码通过 diff 的方式发送给Linus,然后由Linus本人通过手动方式合并代码! ... Linus花了两周时间自己用 C语言 写了一个分布式版本控制系统，这就是Git！ 一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下. 分布式 和 集中式 先说集中式版本控制系统,版本库是集中存放在专门的中央服务器中,而平时使用过程中需要时刻处于联网状态才能和中央服务器保持联系.日常工作流程是这样的,上班前先从中央服务器拉取最新工作内容,本地修改完毕后推送到中央服务器,第二天上班再拉取最新内容,修改后再推送给中央服务器... 集中式版本控制系统的特点就是必须要有一个专门的中央服务器,工作中必须联网才能进行版本控制,试想一下如果正在在外地出差或者没有网络条件下,还怎么进行版本控制,岂不是又重新回到原始时代了吗? 那再说说分布式版本控制系统,版本库是存放在各自使用者的电脑的,不需要专门的中央服务器,每个人电脑中就是一份完整的版本库,因此不需要联网也能工作,工作流程和其他的版本控制系统大致相同. 由此可见,集中式的版本控制系统依赖于中央服务器,要求使用者一直保持通信,而分布式的版本控制系统并不依赖中央服务器,不必强制联网. 万一出现意外,集中式版本控制系统中充当中央服务器的电脑宕机了,那么所有人就没法工作了,再也不能享受版本控制带来的便利了! 同样的情况发生在分布式版本控制系统身上会如何呢?一台电脑宕机没关系,所有人的电脑不可能同时都宕机吧,因为每个人电脑中都是一份完整的版本控制,那么找到其中一个人的版本手动复制到宕机电脑中瞬间不久恢复运行了么?所以说分布式比集中式更安全! 可能会有疑问了,既然分布式版本控制系统中每个人都拥有完整的版本库,那么两个人到底如何交流以谁的版本为准呢?一个版本,两个版本还好,假设有100个版本库呢? 实际上,这并不重要,假设有100个人在合作开发一个项目,而你作为项目负责人,你可能并不关心100人的全部工作细节,在乎的只是最终成果,而这些成果是由10个项目组长提交维护的,所以你关心的只是10个版本,假设没有集中式的中央服务器角色,那么你需要手动合并10个版本库,最终完成项目. 这样看起来中央服务器确实还是有存在的必要,为了方便不同版本库之间进行交流,通常分布式版本控制系统也有一台充当中央服务器角色的电脑,需要理解的是,此时中央服务器的作用仅仅是方便大家交换各自的修改而已,没有它,大家还是可以照常工作的,只是彼此间交换修改不太方便而已! 不论是分布式还是集中式,存在即合理,如何取舍有着各自应用场景,分别代表民主和专制. git 和 svn git 是分布式版本控制系统的代表,除此之外还有BitKeeper,Mercurial,Bazaar 等分布式控制系统,每种分布式控制系统均有自身特点,毋容置疑的是git是最简单最流行! svn 是集中式版本控制系统的代表,是目前使用最广泛的集中式版本控制系统,cvs ClearCase等均属于集中式. 不论是分布式还是集中式,不论是免费还是收费,不一昧追求最好的,只需要最适合自己的即可. git 是分布式控制系统,svn 是集中式版本控制系统 git 将内容按元数据方式存储,svn 是按文件方式存储 git 的内容完整性优于svn,因为 git 内容存储基于sha-1哈希算法,确保内容的完整性. 小结 git 是Linus为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件. © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"git/base/install.html":{"url":"git/base/install.html","title":"安装 git","keywords":"","body":"安装 git git 目前支持 Linux/Unix、Solaris、Mac和 Windows 平台上运行,根据自身环境选择安装. Linux 系统 linux 系统安装软件大致有两种途径,一种是利用安装包管理工具安装,另一种采用源码包安装方式. 安装前先确认下是否之前已安装过,在命令行窗口输入git --version ,如果打印出版本号则表示已安装,否则参考一下内容进行安装. 查看 git 版本 git --version Debian/Ubuntu # 安装 git 依赖 apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\ libz-dev libssl-dev # 安装 git apt-get install git # 查看 git 版本 git --version Centos/RedHat # 安装 git 依赖 yum install curl-devel expat-devel gettext-devel \\ openssl-devel zlib-devel # 安装 git yum -y install git # 查看 git 版本 git --version git-core 和 git 历史渊源: 以前有个软件也叫GIT(GNU Interactive Tools),所以git只能叫git-core了,后来由于git名气实在太大以至于GNU Interactive Tools改名成gnuit,而git-core正式改为git. 源码安装 先从git 官网下载指定版本源码,然后解压,依次输入：./config,make, sudo make install 这几个命令安装到指定目录即可. Debian/Ubuntu # 安装 git 相关依赖 apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\ libz-dev libssl-dev # 下载指定版本源码包 wget https://github.com/git/git/archive/v2.21.0.tar.gz # 解压 tar -zxf v2.21.0.tar.gz # 切换到 git目录 cd git-2.21.0 # 安装 make prefix=/usr/local all # 安装 sudo make prefix=/usr/local install Centos/RedHat # 安装 git 相关依赖 yum install curl-devel expat-devel gettext-devel \\ openssl-devel zlib-devel # 解压 tar -zxf v2.21.0.tar.gz # 切换到 git目录 cd git-2.21.0 # 安装 make prefix=/usr/local all # 安装 sudo make prefix=/usr/local install Windows 系统 直接从git 官网下载安装程序,然后按默认选项安装即可. 安装完成后,在开始菜单里找到Git->Git Bash,弹出命令行窗口,则说明安装成功！ Mac 系统 一般有两种安装方式,一种是利用 mac 的homebrew管理工具安装git,具体安装方法参考homebrew官方文档 另一种方法安装xcode默认集成git,首先从 App Store下载 xcode ,下载完成后运行Xcode，选择菜单Xcode->Preferences，在弹出窗口中找到Downloads，选择Command Line Tools，点Install就可以完成安装了 © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"git/base/config.html":{"url":"git/base/config.html","title":"配置 git","keywords":"","body":"配置 git 安装完成后,还需要最后一步配置就可以愉快使用了,在命令行输入： git config --global user.name \"your username\" git config --global user.email \"example@example.com\" 因为Git是分布式版本控制系统,所以每个机器都必须自报家门:你的名字和Email地址. 配置文件 git 提供git config工具,专门用来配置相应的工作环境变量,支持三种不同的位置. /etc/gitconfig 配置文件 (优先级最低) 系统中对所有用户都生效的配置,效果等同于git config --system ~/.gitconfig 配置文件 (优先级其次) 系统中仅仅对当前登录用户生效的配置,效果等同于git config --global $(pwd)/.git/config 配置文件 (优先级最高) 仅仅对当前项目生效,效果等同于git config 每一级别的配置都会自动覆盖上级相同配置,当前项目配置优先于其余配置 查看配置 如果要查看已有的配置信息,可以输入 git config --list 命令,如果看到重复变量名,表示来自不同配置文件(比如/etc/gitconfig 和 ~/.gitconfig),实际上git会采用最后一个! # 查看已有配置信息 git config --list # 查看当前用户配置信息 cat ~/.gitconfig # 查看系统级别配置信息 cat /etc/gitconfig 也可以直接查看某项环境变量值,比如 # 查看用户名称变量 git config user.name © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"git/usage/about.html":{"url":"git/usage/about.html","title":"实战 git","keywords":"","body":"实战 git git 是一款分布式版本控制系统,可以简单概括: 不要把鸡蛋放在一个篮子里,你的一举一动都在监视中. 实战场景 你作为某项目的其中一员或者负责人,和小伙伴们一起开发,大家既有着各自分工互不干扰,也有着相互合作,最终每个人的劳动成果汇聚成最后的项目,愉快完成项目! 要求 理解 git 的工作流程,懂得实际工作中如何交流合作 掌握 git 常用操作,工具为我所有,进而提高工作效率 独当一面,最好能够独自解决使用git 过程中遇到的问题 主动分享经验,能够教会别人如何使用 git 更上一层楼 推荐 最好的教程在官网 git 官网 在线练习常用操作 Learning Git Branching 廖雪峰的官方网站 git教程 © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"git/usage/local-repository.html":{"url":"git/usage/local-repository.html","title":"本地仓库","keywords":"","body":"本地仓库 背景 创建工作目录 平时工作时我们习惯对文档分门别类进行管理,.doc .txt 等文本类型的文件习惯存在 doc文件下,开发java js 等源代码文件存在在 src 目录下,这一点很好理解,那么讲解 git的项目我们也要创建一个文件夹,姑且新建一个demo的文件夹吧! # 在工作空间创建指定目录 mkdir demo # 切换至工作目录 cd demo 创建本地仓库 既然已经创建了工作文件夹,那么我们自然是希望该文件下的所有文件都能被 git 管理,也就是说在当前文件下的创建新文件,修改原文件内容或者删除文件等操作都能纳入版本控制中,不然为什么要用git 呢? 下面这个命令就是告诉git 这个 demo 目录要纳入版本控制了. # 初始化本地仓库 git init 一旦运行git init 命令,细心的读者可能会发现在原来的 demo 目录下多了.git隐藏文件,正因如此,原来被我们称为工作目录的 demo 才能纳入版本控制,我们将.git目录称之为版本库. 由于当前项目 demo 只在我们自己电脑上,其他人无法访问,所以我们称这种形式的版本库为本地仓库. 添加文件到版本库 首先明确的是,所有的版本控制系统只能追踪文本文件的改动,文本文件就是平常熟悉的.txt .html .js .css .java .xml等等文件,非文本文件的其他格式有哪些? 例如二进制文件,像我们平时听音乐的.mp3,看视频的.mp4,浏览图片的.png等这些都是二进制文件,需要专门的软件才能正常打开,不信的话,你用记事本看看能不能打开视频? 了解文本文件和二进制文件的区别,那是不是说二进制文件没法进行版本控制了,刚才你不是还说demo 目录下的所有文件吗?这不是自相矛盾吗! 非也非也,git 当然也能够管理二进制文件,对于文本文件的追踪,可以细粒度到哪个文件在哪一行发生了哪些变化,而二进制文件只能粗粒度知道哪个文件变化了,并不知道具体变化. 不幸的是,Microsoft 的Word格式是二进制格式,因此,版本控制系统是没法跟踪Word文件的改动的,前面我们举的例子只是为了演示,如果要真正使用版本控制系统,就要以纯文本方式编写文件. 因为文本是有编码的,比如中文有常用的GBK编码,日文有Shift_JIS编码,如果没有历史遗留问题,强烈建议使用标准的UTF-8编码,所有语言使用同一种编码,既没有冲突,又被所有平台所支持. 言归正传,现在我们在demo 目录下创建一个test.txt 演示文件,内容如下git test # 创建新文件 touch test.txt # 编辑新文件,输入 git test echo \"git test\" > test.txt 接下来我们还需要两步操作才能将test.txt纳入git管理: 第一步,使用git add 命令将文件添加到本地仓库: # 添加到本地仓库: 第一步指定要添加的文件 git add test.txt 第二步,使用git commit -m 命令将文件提交到本地仓库: # 添加到本地仓库: 第二步指定添加文件备注 git commit -m \"add test.txt\" 经过上述两步操作,test.txt 文件已经纳入到版本控制中了,这里你可能会有疑问了为什么需要add commit两步呢? 因为commit 可以一次性提交很多文件,所以你可以多次add不同的文件,比如: # 创建三个文件file1.txt file2.txt file3.txt touch file1.txt file2.txt file3.txt # 添加一个文件file1.txt git add file1.txt # 添加两个文件file2.txt file3.txt git add file2.txt file3.txt # 一次性提交全部文件 git commit -m \"add 3 files.\" 小结 初始化本地仓库 git init 添加文件到本地仓库分两步 git add 和 git commit -m 实际工作中,大致以下流程 # 在工作空间创建指定目录 mkdir demo # 切换至工作目录 cd demo # 初始化本地仓库 git init # 创建新文件 touch test.txt # 编辑新文件,输入 git test echo \"git test\" > test.txt # 添加到本地仓库: 第一步指定要添加的文件 git add test.txt # 添加到本地仓库: 第二步指定添加文件备注 git commit -m \"add test.txt\" ... # 继续编辑目标文件,追加 git init echo \"git init\" >> test.txt # 将目标文件添加到本地仓库 git add test.txt # 添加本次新增文件的备注 git commit -m \"add git init\" © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"git/usage/version-manage.html":{"url":"git/usage/version-manage.html","title":"版本管理","keywords":"","body":"版本管理 背景 在上一节中我们已经成功创建版本库并且已经添加test.txt等文件,这一节我们继续讲解如何进行版本控制. 首先我们先查看test.txt 文件有什么内容吧! # 查看文件内容 $ cat test.txt git test git init git diff $ 接下来模拟正常工作,接着输入一下内容: # 追加新内容到 test.txt 文件 echo \"understand how git control version\" >> test.txt # 查看当前文件内容 $ cat test.txt git test git init git diff understand how git control version $ 紧接着运行 git status 看一下输出结果: # 查看文件状态 $ git status On branch master Changes to be committed: (use \"git reset HEAD ...\" to unstage) modified: test.txt Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: test.txt $ 从上述 git status 命令输出的结果可以看出,test.txt 已经被修改但还没提交,但是具体发生了什么变化却没能告诉我们,如果能够告诉我们具体修改细节那就好了! 运行git diff命令可以实现上述需求 $ git diff diff --git a/test.txt b/test.txt index 729112f..989ce33 100644 --- a/test.txt +++ b/test.txt @@ -1,3 +1,4 @@ git test git init git diff +understand how git control version $ git diff 命令即查看差异(difference),从输出结果可以看出我们在最后一行新增了understand how git control version 文字. 通过git status 知道文件发生了改动,git diff 让我们看到了改动的细节,现在我们提交到版本库就放心多了,还记得上节课如何添加版本库的命令吗? 分两步操作: git add 和 git commit -m 第一步: git add $ git add test.txt $ 等一下,在执行 git commit 命令之前,我们再运行 git status 命令查看一下当前仓库状态: $ git status On branch master Changes to be committed: (use \"git reset HEAD ...\" to unstage) modified: test.txt $ 此时 git status 命令告诉我们 test.txt 文件已被修改等待提交,好了,那么接着第二步的commit吧! 第二步: git commit -m # 提交到版本库并添加备注 $ git commit -m \"add understand how git control version\" [master 36f234a] add understand how git control version 1 file changed, 2 insertions(+) $ 提交后,我们此时再次运行git status 命令查看当前仓库状态: $ git status On branch master nothing to commit, working tree clean $ 输出结果显示没有需要提价的改动,工作目录是干净的. 小结 查看工作区状态 git status 比较修改差异 git diff © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"git/usage/reset.html":{"url":"git/usage/reset.html","title":"回到过去","keywords":"","body":"回到过去 背景 现在你已经掌握git的基本操作了,文件发生更改首先使用 git add 添加更改,然后 git commit 提交全部更改,当本地文件再次发生更改时,仍然需要git add 和 git commit 两步操作,中途如何想查看文件是否发生更改,使用git status 查看版本库状态,git diff 命令帮助我们查看更改详情. 像这样重复的操作其实每次都会产生一个快照,用于保存文件状态,只不过这个快照不是完整的文件,被称为提交或者版本commit .一旦发生意外,假如文件修改乱了或者误删了文件,我们可以从最近的一个 commit 中进行恢复,然后继续工作,这就是git 管理的好处之一. 每一次重大更新或者你认为比较重要的时刻,我们总会留作纪念,添加些什么特殊标记来区分平时的提交,还记得我们每次提交都会添加备注吗?git commit -m 这条命令现在就可以大显身手了,我们现在要做的就是找到我们提交的历史记录,而历史记录中有我们提交的详情,这样即使过了一个月或者更长时间,我们也能清楚知道当时的情景! 查看提交历史记录 git log,接下来我们赶紧试一下吧 $ git log commit 36f234a60d858871f040cb0d7ca3e78251df82f7 (HEAD -> master) Author: snowdreams1006 Date: Thu Mar 7 22:19:00 2019 +0800 add understand how git control version commit 2006f72ffe2ce2278b5974313b8598847cf445e4 Author: snowdreams1006 Date: Tue Mar 5 13:27:46 2019 +0800 add 3 files. commit eaa4850070354ae987dc5108a9fd57fda9d64730 Author: snowdreams1006 Date: Tue Mar 5 12:18:57 2019 +0800 add git init commit 6ad8956bc09a6a62c731711eabe796690aa6471c Author: snowdreams1006 Date: Tue Mar 5 12:17:51 2019 +0800 add test.txt git log 命令默认显示最近到最远的提交历史,这一点也很好理解,毕竟我们是在命令行操作,输入git log 完毕后自然先要定位到命令处,看到最新提交记录方便我们确认是否符合我们预期,还有一点就是如果提交历史过多,从头开始到最新提交记录岂不是眼花缭乱,简直不敢想象啊! 下面以最新的一次提交 commit 为例,简单解释一下输出内容: # 提交唯一标示id: 36f234a60d858871f040cb0d7ca3e78251df82f7 commit 36f234a60d858871f040cb0d7ca3e78251df82f7 (HEAD -> master) # 作者: snowdreams1006 邮箱: Author: snowdreams1006 # 日期: Thu Mar 7 22:19:00 2019 +0800 Date: Thu Mar 7 22:19:00 2019 +0800 # 提交备注: add understand how git control version add understand how git control version 默认输出内容有点多,不仅有提交 id ,提交备注还有作者时间之类的,由于每个 commit 都如此,这样一来,满屏都展示不下,那能不能简化些呢? 一行显示提交日志 --pretty=oneline ,即git log --pretty=oneline $ git log --pretty=oneline 36f234a60d858871f040cb0d7ca3e78251df82f7 (HEAD -> master) add understand how git control version 2006f72ffe2ce2278b5974313b8598847cf445e4 add 3 files. eaa4850070354ae987dc5108a9fd57fda9d64730 add git init 6ad8956bc09a6a62c731711eabe796690aa6471c add test.txt $ 相比无参数git log,是不是简短了一些呢? 和之前日志相比少了作者和时间等信息,仍然保留提交 id 和提交备注. 因为提交 commit 是 git 的基础,当然不能省略,而提交备注能够帮助我们理解commit 的含义,毕竟提交备注使我们自定义的内容,这也是我们为什么提交时要写提交备注的原因! 现在我们已经了解到版本库存放了我们的提交,接下来让我们验证一下是否能够回到过去吧! 回到上一个提交,上一个提交自然是相对当前提交而言,只有知道当前提交才能知道上一个提交以及上一个提交的上一个提交. 提交id 36f234a60d858871f040cb0d7ca3e78251df82f7,那么上一个提交HEAD^,上上一个提交是HEAD^^.如果此时我想回到往上数100个版本,那么是不是可以这么写? HEAD^^^^...^^^ 其中^ 有100个,如果需要手动打出100个^的话,那么绝对是疯了! 既然有这种相对定位方式,自然也有绝对定位方式,用绝对定位方式解决就是这样: HEAD~100 $ git log commit 36f234a60d858871f040cb0d7ca3e78251df82f7 (HEAD -> master) Author: snowdreams1006 Date: Thu Mar 7 22:19:00 2019 +0800 add understand how git control version 回到上一个版本 git reset --hard HEAD^ 在操作之前我们先看一下当前文件 test.txt 的内容: $ cat test.txt git test git init git diff understand how git control version 现在让我们开始回到过去,运行 git reset --hard HEAD^ 命令: $ git reset --hard HEAD^ HEAD is now at 2006f72 add 3 files. $ 现在让我们再看一下,test.txt 的内容有没有被还原: $ cat test.txt git test git init 果然被还原了!这就是git的神奇之处,说明我们已经能够回到过去了! 现在我们先用git log 查看下提交历史: $ git log commit 2006f72ffe2ce2278b5974313b8598847cf445e4 (HEAD -> master) Author: snowdreams1006 Date: Tue Mar 5 13:27:46 2019 +0800 add 3 files. commit eaa4850070354ae987dc5108a9fd57fda9d64730 Author: snowdreams1006 Date: Tue Mar 5 12:18:57 2019 +0800 add git init commit 6ad8956bc09a6a62c731711eabe796690aa6471c Author: snowdreams1006 Date: Tue Mar 5 12:17:51 2019 +0800 add test.txt $ 和上次相比,少了一条提交记录: commit 36f234a60d858871f040cb0d7ca3e78251df82f7 (HEAD -> master) Author: snowdreams1006 Date: Thu Mar 7 22:19:00 2019 +0800 add understand how git control version 这样是正常的,毕竟你已经处于 过去 了,当然看不到 未来 的提交记录. 正如影视穿越剧那样,主人公意外穿越过去,总是想要回到未来,怎么办,没有法器没有未来的确切目标怎么行?! git 的穿越剧也需要这样一种法器,能准确告诉时光机把我们带到具体的那个时间点,当然这个时间点不一定是未来时刻,过去时刻也行,反正就是一个准确的坐标. 聪明的你肯定已经猜测到这个任务是由commit 担任的,所有我们现在要找到未来的时间点,也就是commit id,就是那一长串 hash 字符串. 只要当前命令行窗口还没有关闭,慢慢往上翻,总是能找到当初我们的穿越点commit的,即36f234a60d858871f040cb0d7ca3e78251df82f7 回到当初提交 git reset --hard 万事俱备只欠东风,已经成功定位到未来坐标,等待穿越到未来! $ git reset --hard 36f234a60d858871f040cb0d7ca3e78251df82f7 HEAD is now at 36f234a add understand how git control version $ 现在我们再次查看 test.txt 内容: $ cat test.txt git test git init git diff understand how git control versi 果然成功穿越回到未来! 上述穿越回到未来的场景是我们知道目标 commit ,也就是在当前命令行窗口没有关闭的情况下,手动查找穿越点 commit.那如果命令行窗口已关闭或者没办法通过查阅历史命令来定位穿越点 commit 情况下怎么办呢? 这种情况下也是有补救措施的,git 提供了命令历史 git reflog,记录了我们操作的命令历史. 翻阅历史命令 git reflog $ git reflog 36f234a (HEAD -> master) HEAD@{0}: reset: moving to 36f234a60d858871f040cb0d7ca3e78251df82f7 2006f72 HEAD@{1}: reset: moving to HEAD^ 36f234a (HEAD -> master) HEAD@{2}: commit: add understand how git control version 2006f72 HEAD@{3}: commit: add 3 files. eaa4850 HEAD@{4}: commit: add git init 6ad8956 HEAD@{5}: commit (initial): add test.txt 确实记录了我们操作的关键命令,从上述输出结果可以看出,穿越点 commit 正是36f234a60d858871f040cb0d7ca3e78251df82f7,剩下的事情应该不必多说了吧! 小结 HEAD 是当前提交的指针,指向的提交就是当前提交,上一个提交是 HEAD^,上上个提交是 HEAD^^,前100个提交是HEAD~100. git log 查看提交历史,git log --pretty=oneline 简短化输出提交历史. git reflog 查看命令历史,以便我们重拾关键步骤信息. git reset --hard 穿越到指定提交,比如上一个提交就是 git reset --hard HEAD^ . © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"git/usage/concept.html":{"url":"git/usage/concept.html","title":"基本概念","keywords":"","body":"基本概念 了解工作区,暂存区和版本库的区别和联系有助于我们更好理解 git 的工作流程,了解命令的操作意图. git 和其他版本控制系统如 svn 的不同之处就是有暂存区的概念. 基本概念 工作区 | Working Directory 正常情况下能看到的目录(不包括隐藏文件),也就是用户主动创建的目录 暂存区 | Stage 工作区下的隐藏.git目录下的.index文件,因此也称为索引. 版本库 | Repository 工作区下的隐藏目录.git目录 通过前几节我们知道,将文件纳入版本控制,需要分两步操作: 第一步 git add 添加文件,实际上是将文件更改添加到暂存区. 第二步 git commit 提交更改,实际上是将暂存区所有内容提交到当前分支. 我们使用 git init 命令初始化创建 git 仓库时,git 会自动创建唯一一个 master 分支,默认所有操作是在 master 分支上进行的,所以 git commit 就是徃 master 分支上提交更改的. 通俗地讲,文件更改可以多次添加到暂存区,即允许多次执行 git add 命令,然后一次性提交暂存区的全部更改到版本库,即只需要执行一次 git commit 命令即可. 说说个人理解 git 为何分成三部分进行版本控制操作,二部分行不行? 答案是肯定的,没有暂存区概念的 svn 同样可以进行版本控制,所以 git 增加暂存区必然是有存在的意外也就是所谓的好处的. 第一,暂存区的概念允许将本地文件的更改添加进来,也就是说本地文件的更改只有添加到暂存区才能进行下一步的提交更改,所以说那些更改添加到暂存区是由开发者本人决定的,这其实有了一定灵活性,并不是所有的更改都需要被记录! 第二,暂存区作为中间过程,暂存区的内容是打算提交更改的内容,也就是说暂存区可以视为一种临时缓存,用来记录预提交更改.实际工作中,新功能的开发并不是一蹴而就的,是由一系列的更改一起组成的,如果将这些更改分散开来单独提交,那势必会产生很多commit,如果等待全部工作完成再提交的话,解决了过多commit的问题,但是又遇到新问题就是你可能很长时间才能提交一次更改,失去了版本控制的意义.综上所述,暂存区的出现一种很好的解决方案,它允许将相关性代码添加在一起,方便后续提交更改时提交的都是相关性代码! 第三,作为分布式版本控制系统,不像集中式控制系统那样,对网络强相关,失去网络的 svn 是没办法再进行版本控制的,但失去网络的 git 仍然可以进行版本控制,只不过不能远程操作了而已,不过这部分也是无可厚非的,正所谓\"巧妇难为无米之炊\",你总不能要求断网下继续访问百度吧! 好了,我们继续回到 git 常用操作上,看一下工作区,暂存区和版本库三者如何协同工作的. 首先,先修改test.txt文件. # 查看 test.txt 文件内容 $ cat test.txt git test git init git diff understand how git control version # 追加 how git work 到 test.txt 文件 $ echo \"how git work\" >> test.txt # 再次查看 test.txt 文件内容 $ cat test.txt git test git init git diff understand how git control version how git work $ 紧接着新建newFile.txt 并随便输入内容: # 查看当前文件夹下全部文件 $ ls . file1.txt file2.txt file3.txt test.txt # 创建新文件 newFile.txt $ touch newFile.txt # 再次查看当前文件夹下全部文件 $ ls file1.txt file2.txt file3.txt newFile.txt test.txt # 输入 add newFile.txt 文件内容 到 newFile.txt 文件 $ echo \"add newFile.txt\" > newFile.txt # 查看 newFile.txt 文件内容 $ cat newFile.txt add newFile.txt $ 现在运行git status 命令查看当前文件状态: $ git status On branch master Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: test.txt Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store newFile.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") $ 从输出结果中得知,test.txt 文件已修改(modified),还没添加到暂存区,而newFile.txt 文件还没被跟踪(Untracked). 现在我们使用git add 命令将 test.txt 和 newFile.txt 都添加到暂存区,再用 git status 查看文件状态: # 添加 test.txt 文件 git add test.txt # 添加 newFile.txt 文件 git add newFile.txt # 查看文件状态 git status On branch master Changes to be committed: (use \"git reset HEAD ...\" to unstage) new file: newFile.txt modified: test.txt Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store $ 现在输出结果和上次就不一样了,显示的是即将被提交文件,其中newFile.txt 是新文件(new file),test.txt 是修改文件(modified). 所以,git add 命令作用是将需要提交的更改文件临时放到暂存区中,然后执行git commit 命令就可以一次性将暂存区的所有内容提交到当前分支. $ git commit -m \"understand how stage works\" [master a5cd3fb] understand how stage works 2 files changed, 2 insertions(+) create mode 100644 newFile.txt $ git status On branch master Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store nothing added to commit but untracked files present (use \"git add\" to track) $ 暂存区的所有内容提交到版本库,所以运行git status 时,工作区是干净的,即此时暂存区没有内容了! .DS_Store 是 mac 电脑自动生成的文件,可以暂不理会,等到后面的.gitignore 文件时再处理. 图解 下图展示了工作区,暂存区,版本库之间的关系: 图中左侧是工作区,右侧是版本库,版本库中标记index 的区域是暂存区,标记 master 的是 master 分支所代表的目录树. HEAD 是指向 master 分支的指针,标记 objects 的区域是 git 的对象库,真实路径位于.git/objects目录下,用于表示创建的对象和内容. 意图说明 git add 添加文件 工作区的修改或者新增的文件执行git add 命令后,暂存区(index)的目录树会自动更新,同时引发这次变化的文件内容会被记录下来,即生成对象库(objects)中的新对象,而对象的 id会被记录到暂存区的文件索引(index)中. git commit 提交文件 暂存区的目录树写入到对象库(objects),master 分支的目录树自动更新. git reset HEAD 撤销文件 暂存区的目录树被重写,被master 分支的目录树所替换,但是工作区不受影响. git rm --cached 删除缓存文件 删除暂存区文件,工作区不受影响. git checkout . 检出文件 暂存区的文件替换工作区文件,注意:当前尚未添加到暂存区的改动会全部丢失! git checkout HEAD . 检出文件 HEAD 指针指向的 master 分支中的文件替换暂存区以及工作区文件,注意:不仅清除工作区未提交的改动,连暂存区未提交的改动也会被清除! 小结 以上就是常用命令的背后意图,主要是工作区,暂存区和版本库之间文件同步策略的关系. git add 是工作区更新到暂存区 git commit 是暂存区更新到版本库 git reset HEAD 是版本库更新到暂存区 git checkout -- 是暂存区更新到工作区 git checkout HEAD 是版本库同时更新暂存区和工作区 git rm --cached 清空暂存区 © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"git/usage/version-control.html":{"url":"git/usage/version-control.html","title":"版本控制","keywords":"","body":"版本控制 我们知道 git 是分布式版本控制系统,所以称被控制对象是版本本身没错,但是从git 命令中发现,并没有版本这个名词,有的只是commit,所以前几节我一直称其为提交. 为了避免后续教程引发歧义,特意说明,无论是版本也好,提交也罢,都是中文翻译而已,不必太过较真,直接原汁原味称commit也可以啊! 假设你已掌握暂存区的相关概念,简单来说,暂存区就是更改文件的缓存集合,等待一次性全部提交到版本库,正因如此,方便我们批量操作相关性文件,打包提交到版本库,这正是暂存区的独特魅力. 我们反复在说 git 是分布式版本控制系统,分布式的概念已经粗略讲过多次了,下面我们讲一下版本控制,谈谈 git 的版本控制和其他系统的版本控制有什么不同,为什么 git 这么优秀,如此流行? git 跟踪并管理的是更改,而非文件本身.正如linux 一切皆文件,java 一切皆对象一样,git 一切皆更改.新增文件是一个更改,新增文件内容是一个更改,修改文件内容是一个更改,删除文件内容也是一个更改,换言之,git 管理的正是这一个个的更改,并不是文件本身. 下面我们用事实说话,证明 git 管理的是更改而不是文件本身: 第一步,追加 git tracks changes 到 test.txt 文件 # 查看 test.txt 文件内容 $ cat test.txt git test git init git diff understand how git control version how git work # 追加 git tracks changes 文件内容到 test.txt 文件 $ echo \"git tracks changes\" >> test.txt # 再次查看 test.txt 文件内容 $ cat test.txt git test git init git diff understand how git control version how git work git tracks changes $ 第二步,添加test.txt 文件到暂存区并查看文件状态 $ git add test.txt sunpodeMacBook-Pro:demo sunpo$ git status On branch master Changes to be committed: (use \"git reset HEAD ...\" to unstage) modified: test.txt Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store $ 对于上述内容应该不必再解释了吧,无外乎说test.txt 文件已修改(modified),即将被提交(to be committed). 但是,此时偏偏不提交,继续修改 test.txt 文件:(这种情况实际工作中也有可能出现,比如你正在研发某功能,本以为已经开发完毕,满心欢喜添加到暂存区,然后意外发现一个小bug,分分钟就修复了,时间间隔很短以至于你根本不记得还需要再次添加到暂存区.) 第三步,继续修改文件内容,忘记再次添加到暂存区 # 编辑 test.txt 文件,将 git tracks changes 更改为 git tracks changes of files vim test.txt # 查看 test.txt 文件内容 $ cat test.txt git test git init git diff understand how git control version how git work git tracks changes of files $ 第四步,正常提交暂存区的全部更改到版本库 $ git commit -m \"git tracks changes\" [master 2daa74a] git tracks changes 1 file changed, 1 insertion(+) 此次提交后,我们再看一下文件状态: $ git status On branch master Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: test.txt Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store no changes added to commit (use \"git add\" and/or \"git commit -a\") $ 发现有什么不同吗?以往提交后再次查看文件状态,工作区都是干净的,这次居然提示我们 test.txt 文件已经修改但未添加到暂存区?! 等一下,我们先回忆一下我们的操作流程: 第一次修改(git tracks changes) -> git add -> 第二次修改(git tracks changes of files) -> git commit 这样就很好理解了,git 管理的是更改而不是文件本身,如果是文件本身的话,应该将文件的内容全部提交才对,所以管理的是更改. 第一次修改过后使用 git add 命令将工作区的第一次修改内容放到暂存区准备提交,但是此时工作区发生了第二次修改,注意,这次修改并没有放到暂存区,所以下一步的git commit 命令提交的暂存区内容中自然也就没有第二次修改的内容了!所以git commit 完毕后运行git status命令才会发现此时工作区和暂存区还存在版本差异,即此时工作区不是干净的! 这一次的实验很好理解,工作区的修改需要主动告诉暂存区,暂存区的全部更改再提交到版本库.所以版本库的提交取决于暂存区,而暂存区又取决工作区是否主动将更改添加进去了吗! 理论再多不如亲身体验,让我们直接比较一下工作区和版本库的差异吧! # 比较 test.txt 文件在工作区和版本库的差异 $ git diff HEAD -- test.txt diff --git a/test.txt b/test.txt index d31bdd2..56c76b7 100644 --- a/test.txt +++ b/test.txt @@ -3,4 +3,4 @@ git init git diff understand how git control version how git work -git tracks changes +git tracks changes of files $ 由此可见,工作区比版本库多了git tracks changes of files,少了git tracks changes,所以说第二次修改内容 git tracks changes of files 并没有被提交. 现在我们再解释一下-git tracks changes 和 +git tracks changes of files 的问题: 首先查看工作区 test.txt 文件内容 $ cat test.txt git test git init git diff understand how git control version how git work git tracks changes of files $ 根据上述分析,我们知道第一次的修改git tracks changes 已被提交到版本库,第二次的修改git tracks changes of files 没有被提交而是继续留在工作区. 因此,可以推断出目前版本库的文件应该是这样的: git test git init git diff understand how git control version how git work git tracks changes 既然如何,工作区和版本库相比岂不刚好是少了一个git tracks changes,多了git tracks changes of files,其余文件内容完全相同! 透过现象看本质,已经分析了现象也解释了产生现象的原因,是时候分析一下本质了. 抛出问题:因为git tracks changes of fiels 和 git tracks changes 被视为不同的更改,所以才会造成上述现象.如果git tracks changes of fiels 被认为是git tracks changes + of fiels 两者叠加产生的更改,还会产生上述现象吗? 答案是否定的,如果两个更改可以叠加的话,按照版本控制的思路,第二次的修改即便没有提交也只是 of fiels 没有加入到版本库而已,如此一来,工作区和版本库的差异将不再是少了一个git tracks changes,多了git tracks changes of files,而仅仅是多了of files! 由此可见,git 版本控制系统其实是全量更新的思维模式,并不是差量更新模式. 小结 工作区的更改需要git add 添加到暂存区,git commit 将暂存区的全部更改提交到版本库. 工作区,暂存区,版本库三者既相关独立又密切关联,三者是传递性依赖的关系. git 版本控制的是文件的更改,而不是文件本身,是全量更新模式,而不是差量更新模式. © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"git/usage/checkout-reset.html":{"url":"git/usage/checkout-reset.html","title":"撤销更改","keywords":"","body":"撤销更改 相信你已经了解了 git 的基本概念,也清楚了工作区,暂存区和版本库的关系,现在让我们用所学的知识继解决实际问题吧! 背景 正常看得见的目录是我们最为熟悉的工作区,在工作中不可能总是100%的精力,难免会犯错,尤其是下午犯困,晚上加班更是如此.下面列举了常见的一些场景 场景一: 工作区出现意外更改且尚未添加到暂存区 北京时间现在是晚上10点钟,你正在赶制一份工作报告,尽管心中一万个不愿意,还是不得不做. 开始模拟意外更改前,先查看一下 test.txt 文件相关信息: # 列出当前目录的文件 $ ls file1.txt file2.txt file3.txt newFile.txt test.txt # 查看 `test.txt` 文件内容 $ cat test.txt git test git init git diff understand how git control version how git work git tracks changes of files # 查看 `test.txt` 文件状态 $ git status On branch master Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: test.txt Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store no changes added to commit (use \"git add\" and/or \"git commit -a\") # 查看 `test.txt` 文件差异 $ git diff diff --git a/test.txt b/test.txt index d31bdd2..56c76b7 100644 --- a/test.txt +++ b/test.txt @@ -3,4 +3,4 @@ git init git diff understand how git control version how git work -git tracks changes +git tracks changes of files $ 还记得在上一节中我们讲解 git 版本控制的到底是什么,为了证明 git 管理的是更改而不是文件本身,我们特意在第二次更改时没有添加到暂存区,现在我们先把这个遗留问题解决掉. # 工作区更改添加到暂存区 $ git add test.txt # 暂存区内容提交到版本没哭 $ git commit -m \"git tracks changes of files\" [master b7bda05] git tracks changes of files 1 file changed, 1 insertion(+), 1 deletion(-) # 查看文件状态 $ git status On branch master Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store nothing added to commit but untracked files present (use \"git add\" to track) $ 现在正在加班加点干活,一不小心将心中的不满表露出来了,于是有了下面的内容: # 意外更改正是这么犯傻的一句话 $ echo \"My stupid boss still prefers svn\" >> test.txt # 当前文件内容 $ cat test.txt git test git init git diff understand how git control version how git work git tracks changes of files My stupid boss still prefers svn $ 虽然强打精神,可还是很困,于是打算喝杯咖啡提提神,猛然发现 stupid boss 可能会让你丢掉这个月的奖金! 暗自庆幸,咖啡果然是个好东西,既然发现了问题,那就事不宜迟赶紧修复,因为不适宜的话正是 stupid boss ,所以你完全可以手动删除,但是假如你说了一大堆不合适的话,或者复制粘贴时弄错了,这就不是删除一两行那么简单了! 既然手动解决比较麻烦,那git 有没有什么好方法来解决这类问题呢?在寻求git 帮助前,首先再看一下当前文件状态(git status).正所谓\"知己知彼方能百战百胜\",还是看一眼吧! # 查看文件状态 $ git status On branch master Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: test.txt Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store no changes added to commit (use \"git add\" and/or \"git commit -a\") $ git 不负众望,果然给了我们希望,(use \"git checkout -- ...\" to discard changes in working directory) 这句话的告诉我们可以丢弃工作区的更改! 脑海中在快速回忆一下工作区,暂存区,版本库三者之间的关系,其实git checkout -- 命令的意思是用暂存区的内容替换掉工作区内容,因此也就是丢弃掉工作区的更改了. 事不宜迟,运行 git checkout -- 命令试试看吧: # 丢弃工作区的更改 $ git checkout -- test.txt # 查看文件内容: My stupid boss still prefers svn 终于不见了 $ cat test.txt git test git init git diff understand how git control version how git work git tracks changes of files # 查看文件状态 $ git status On branch master Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store nothing added to commit but untracked files present (use \"git add\" to track) $ 一顿操作猛如虎,撤销掉意外更改,回到上一次版本控制状态,世界如此美好... 注意: git checkout -- 中的 -- 至关重要,没有它就是切换分支了! 场景二: 工作区出现意外更改且已经添加到暂存区,但尚未提交到版本库 时间一分一秒过去了,转眼间已经11点了,假设你不但写了一些胡话,还添加到暂存区了(git add).可想而知,这次意外比场景一要糟糕. # 模拟正常提交(不然岂不是从场景一到场景二你什么都没做,那还能叫做赶制工作报告吗?!) $ echo \"someone prefers svn,but i don't care it\" >> test.txt $ cat test.txt git test git init git diff understand how git control version how git work git tracks changes of files someone prefers svn,but i don't care it $ git add test.txt $ git commit -m \"normal commit\" [master ab1cbd2] normal commit 1 file changed, 1 insertion(+) # 意外更改的前夕 $ cat test.txt git test git init git diff understand how git control version how git work git tracks changes of files someone prefers svn,but i don't care it # 意外更改内容: my teammate is stupid too. $ echo \"my teammate is stupid too.\" >> test.txt $ cat test.txt git test git init git diff understand how git control version how git work git tracks changes of files someone prefers svn,but i don't care it my teammate is stupid too. # 意外操作: 将意外更改内容提交到暂存区 $ git add test.txt 不过庆幸的是,在提交到版本库(git commit)之前及时发现问题,还是看一下现在的文件状态(git status)吧! # 查看文件状态: 救命稻草 (use \"git reset HEAD ...\" to unstage) $ git status On branch master Changes to be committed: (use \"git reset HEAD ...\" to unstage) modified: test.txt Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store $ git 同样告诉我们,可以使用 git reset HEAD 命令撤销暂存区更改. 其实 git reset HEAD 命令是用版本库的内容替换掉暂存区的内容,也就是说原来暂存区的内容已被丢弃了! 所以说这个命令并不会影响工作区内容,不如我们现在再看一眼工作区内容,方便执行 git reset HEAD 命令后证实我们的结论. # 查看文件内容: my teammate is stupid too. $ cat test.txt git test git init git diff understand how git control version how git work git tracks changes of files someone prefers svn,but i don't care it my teammate is stupid too. $ 迫不及待执行 git reset HEAD 命令,先睹为快! # 救命稻草: 版本库内容替换掉暂存区内容 $ git reset HEAD test.txt Unstaged changes after reset: M test.txt # 效果: 目标文件已修改但未添加到暂存区 $ git status On branch master Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: test.txt Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store no changes added to commit (use \"git add\" and/or \"git commit -a\") # 目标文件内容: 仍然保持不变 $ cat test.txt git test git init git diff understand how git control version how git work git tracks changes of files someone prefers svn,but i don't care it my teammate is stupid too. $ 现在场景二已经退化成场景一了,目标文件发生意外更改但还没添加到暂存区,如何撤销工作区更改,请参考场景一方法. 提示: git checkout -- test.txt 场景三: 工作区出现意外更改不仅已添加到暂存区,还已提交到版本库,但尚未推送到远程仓库 时间不紧不慢地已经到凌晨了,困意越来越浓,洋洋洒洒写下几千字的工作报告,总算是写完了,添加到暂存区(git add),提交到版本库(git commit)一气呵成,等等,好像有什么不对劲,难免会犯糊涂,这不又发生意外了! # 衔接场景二 $ cat test.txt git test git init git diff understand how git control version how git work git tracks changes of files someone prefers svn,but i don't care it # 正常提交一 $ echo \"i love working,work makes me happy\" >> test.txt $ git add test.txt $ git commit -m \"encourage myself\" [master a44cf7a] encourage myself 1 file changed, 1 insertion(+) # 正常提交二 $ echo \"fix 110 bugs,so happy\" >> test.txt $ git add test.txt $ git commit -m \"fix bugs\" [master c66399d] fix bugs 1 file changed, 1 insertion(+) sunpodeMacBook-Pro:demo sunpo$ git status On branch master Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store nothing added to commit but untracked files present (use \"git add\" to track) # 意外更改: hate to work overtime $ echo \"hate to work overtime\" >> test.txt $ git add test.txt $ git commit -m \"test.txt\" [master c965724] test.txt 1 file changed, 1 insertion(+) $ 天妒英才,加班加点做事情,本想赢得老板的赏识,没想到最后一句话\"hate to work overtime\"让所有的努力都付之一炬,怎么办? 死马当活马医,还是照例看看git status 能提供什么建议吧! $ git status On branch master Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store nothing added to commit but untracked files present (use \"git add\" to track) $ 没有提供任何意见能帮助我们撤销意外更改,先别慌,容我深思三秒钟... 既然意外更改已经提交到版本库,那么应该用什么内容替换版本库内容呢?有了,既然最新版本库不可用,那上一个版本库内容可用的啊,完全可以用上一个版本库内容替换最新版本库内容,真乃\"天生我材必有用\"! # 当前文件内容: 闯祸的\"hate to work overtime\" $ cat test.txt git test git init git diff understand how git control version how git work git tracks changes of files someone prefers svn,but i don't care it i love working,work makes me happy fix 110 bugs,so happy hate to work overtime # 版本回退: 回到过去假装什么都没发生过 $ git reset --hard HEAD^ HEAD is now at c66399d fix bugs sunpodeMacBook-Pro:demo sunpo$ git status On branch master Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store nothing added to commit but untracked files present (use \"git add\" to track) # 岁月静好,一切似乎都没发生过 $ cat test.txt git test git init git diff understand how git control version how git work git tracks changes of files someone prefers svn,but i don't care it i love working,work makes me happy fix 110 bugs,so happy # 当前文件状态 $ git status On branch master Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store nothing added to commit but untracked files present (use \"git add\" to track) $ 详情请参考回到过去,时空穿越之旅就是这么方便哈! 提示: git reset --hard HEAD^ 场景四: 工作区出现意外更改不仅已添加到暂存区,还提交到版本库,还已推送到远程仓库 场景一到场景三都是本地仓库,所有的文件更改只能本机访问,小伙伴也好,上级领导也罢都无法查看到你本地更改,但是一旦你推送到远程仓库了,那么其他人就能查看你的更改了! 正常的提交更改还好,怕就怕这种\"stupid boss\"被领导看到就不好了,那应该怎么办?暂时还是自求多福吧! 小结 丢弃工作区更改: git checkout -- 丢弃暂存区更改: git reset HEAD 丢弃本地版本库更改: git reset --hard HEAD^ 丢弃远程版本库更改: 自求多福 © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"git/usage/delete.html":{"url":"git/usage/delete.html","title":"删除文件","keywords":"","body":"删除文件 回忆一下文件的常见操作,新增文件,修改文件,删除文件等,新增和修改文件都单独讨论过,现在我们来研究一下如何删除文件. 你可能会说删除文件还不简单啊,直接 rm -rf 即可,但是这仅仅是本地文件被删除了,对于 git 来说,文件并没有被删除. 还记得我们开篇介绍git 时就说过,一切操作皆版本 ,对于新增是一个版本,修改也是一个版本,就连删除都是一个版本. 下面让我们看一下 git 中如何删除文件吧! 背景 # 查看当前文件列表 $ ls file1.txt file2.txt file3.txt newFile.txt test.txt # 新建待删除文件 $ touch delete.txt # 再次查看当前文件列表,确保新建文件成功 $ ls delete.txt file2.txt newFile.txt file1.txt file3.txt test.txt # 查看当前文件状态: 新文件 `delete.txt` 还没被跟踪 $ git status On branch master Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store delete.txt nothing added to commit but untracked files present (use \"git add\" to track) # 添加新文件 `delete.txt` $ git add delete.txt # 查看文件状态: 已添加到暂存区,待提交到版本库 $ git status On branch master Changes to be committed: (use \"git reset HEAD ...\" to unstage) new file: delete.txt Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store # 提交新文件 `delete.txt` $ git commit -m \"add delete.txt\" [master 7df386a] add delete.txt 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 delete.txt # 再次查看文件状态: 已经没有新文件 `delete.txt` 的更改信息 $ git status On branch master Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store nothing added to commit but untracked files present (use \"git add\" to track) $ 以上操作,我们简单创建 delete.txt 文件,添加(git add)并提交(git commit) 该文件,完成准备工作后,开始删除文件! # 删除前文件列表 $ ls delete.txt file2.txt newFile.txt file1.txt file3.txt test.txt # 删除刚刚创建的文件 `delete.txt` $ rm delete.txt # 删除后文件列表 $ ls file1.txt file2.txt file3.txt newFile.txt test.txt # 当前文件状态: `delete.txt` 文件已被删除,且未添加到暂存区 $ git status On branch master Changes not staged for commit: (use \"git add/rm ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) deleted: delete.txt Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store no changes added to commit (use \"git add\" and/or \"git commit -a\") $ 本地删除 delete.txt 文件后,再次查看文件状态 git status 发现 git 给了我们两条建议,其中一条 git checkout -- 我们很熟悉,就是丢弃工作区的更改,此时此景下如果丢弃删除操作,相当于撤销删除,难怪说删除也是一个版本呢! 现在我们重点来看第一条建议 git add/rm ,rm 是 remove 单词的缩写,即删除文件. # 删除文件 $ git rm delete.txt rm 'delete.txt' # 查看文件状态: `delete.txt` 文件待提交 $ git status On branch master Changes to be committed: (use \"git reset HEAD ...\" to unstage) deleted: delete.txt Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store # 提交文件 $ git commit -m \"remove delete.txt\" [master 6298070] remove delete.txt 1 file changed, 0 insertions(+), 0 deletions(-) delete mode 100644 delete.txt # 再次查看文件状态 $ git status On branch master Untracked files: (use \"git add ...\" to include in what will be committed) .DS_Store nothing added to commit but untracked files present (use \"git add\" to track) $ 删除文件和添加文件类似,都是一次commit ,本地文件的任何更改都要添加到暂存区,然后提交到版本库. 小结 删除文件和新增文件类似逻辑,git rm 删除文件后,依然需要 git commit 提交版本. © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"git/usage/remote-repository.html":{"url":"git/usage/remote-repository.html","title":"远程仓库","keywords":"","body":"远程仓库 如果说本地仓库已经足够个人进行版本控制了,那么远程仓库则使多人合作开发成为可能. 如果你只是打算自己使用git,你的工作内容不需要发布给其他人看,那就用不到远程仓库的概念. git 是分布式版本控制系统,分布式意味着同一个git 仓库 可以部署在不同的机器上,正如\"鸡生蛋蛋生鸡\"问题一样,不论如何,先要有一个原始仓库,然后才能分布到其他机器上去. 充当原始仓库的机器要有一个特点那就是24h 开机且大家都能访问到,这个概念类似于\"中央服务器\".这样一来大家都可以从\"中央服务器\"下载最新代码,克隆到本地,本地发生更改后再推送给\"中央服务器\".如此一来,大家交流方便很多,轻松实现文件内容的共享. 这种\"中央服务器\"比较有名的是国外的网站 github,当然国内也有不少类似服务.像这种\"中央服务器\"也可以自己搭建,现阶段搭建的话简直就是\"杀鸡焉用牛刀\"! 背景 关于如何注册配置相关请参考 github 教程 为了和上述教程保持一致,项目名git-demo,先看一下当前工作区状态: # 查看文件列表 $ ls LICENSE README.md test.txt # 查看文件内容 $ cat test.txt add test.txt 现在测试一下本地更改能否推送到远程仓库,先在本地文件 test.txt 随便写点东西,然后添加(git add),提交(git commit),最后推送到远程仓库(git push origin master). # 写入新的内容并提交到本地仓库 $ echo \"see https://snowdreams1006.github.io/git/usage/remote-repository.html\" >> test.txt $ git add test.txt $ git commit -m \"see https://snowdreams1006.github.io/git/usage/remote-repository.html\" [master b3d8193] see https://snowdreams1006.github.io/git/usage/remote-repository.html 1 file changed, 1 insertion(+) # 推送到远程仓库 $ git push origin master Counting objects: 3, done. Delta compression using up to 4 threads. Compressing objects: 100% (3/3), done. Writing objects: 100% (3/3), 359 bytes | 359.00 KiB/s, done. Total 3 (delta 1), reused 0 (delta 0) remote: Resolving deltas: 100% (1/1), completed with 1 local object. To github.com:snowdreams1006/git-demo.git 8e62564..b3d8193 master -> master $ 命令行没有报错证明我们已经成功推送到 github,现在登录 github 看一下有没有刚才我们提交的新内容. 现在本地版本库和远程版本库已经能够正常建立关联了,此刻起将不再是独自一人在战斗! 小结 创建已有本地仓库和远程仓库的关联 # 添加远程仓库关联 git remote add origin git@github.com:username/repos.git # 首次推送 master 分支的全部内容 git push -u origin master # 后续推送 master 分支的最新更改 git push origin master 从已有远程仓库克隆到本地仓库 # 克隆远程仓库到本地仓库 git clone git@github.com:username/repos.git # 推送 master 分支的最新更改 git push origin master © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"git/usage/branch-manage.html":{"url":"git/usage/branch-manage.html","title":"分支管理","keywords":"","body":"分支管理 背景 什么是分支?简单地说,分支就是两个相对独立的时间线,正常情况下,独立的时间线永远不会有交集,彼此不知道对方的存在,只有特定情况下,两条时间线才会相遇,因为相遇,所以相知,因为相知,所以改变! 正如分支对于科幻电影来说是一个很好的卖点,关于分支的话题完全可以开启新的题材,对于这点相信不少科幻迷都深有体会,不必赘述. 回归正题,分支对于版本控制系统又意味着什么呢?实际工作中,我们大多作为一个团队一起合作开发项目,如果是独立开发者,只有一个人的话,其实用不到分支的概念,甚至远程仓库也用不到.所以下述情况针对的都是团队开发情况. 作为团队中的一员不论是项目领导还是项目成员,都需要了解并掌握分支的一般概念和常用操作.如果你刚好是实际开发的程序猿,上级领导分派一个新功能,预期两个星期内才能完成,其他同事也是如此,每个人都有自己的任务.接收任务就要开始干活,第一天工作开了一个头,还留下一大堆的 TODO 标记,此时你照例运行 git add ,git commit 等命令,学会上节的git push origin master 你知道了本地仓库和远程仓库的概念,你想将你的工作成果分享给其他人就要推送到远程仓库,这样其他人才能可见,等一等,别急! 首先明确的是,这个完整功能至少需要2个星期才能基本完成啊,你现在刚刚起了个头还没完成呢!你要是真的推送到远程仓库了,那其他人是不是有理由认为你这部分功能已完成?那你可能会反驳说,我可以在工作群吼一声,说这个功能还没完成,大家别着急使用哈!这样确实可以,很长一段时间内其他人必须无视你的代码,只有等你的功能基本可用时,等你再吼一声,别人才会去使用你的代码.粗略一看,好像并没有什么问题?! 实际上这种情况是存在很大风险的,因为未完成未经过测试的代码可能会产生大量意外 bug,严重的话,甚至影响整个系统,到时候由于你的未完成代码导致别人项目都无法运行,那别人还怎么工作,这个责任是谁负责? 所以,为了不给其他人造成麻烦,最好不要把未完成工作直接暴露到别人面前,那长时间提交又可能会造成丢失更改的风险,此时此景,平行时间线应用而生! 从接手新功能的时间点开始,创建一条新的时间线,于是新功能的开发完全在新的时间线上进行,至于其他人是否开启新的时间线那就不是我们能控制得了,我们能做到的就是不给其他人制造麻烦,如果其他人给我们制造麻烦的话,那我们就去上级领导那告他一状,哈哈! 等功能开发差不多时,你再想办法切换到原来的时间线上并将开发时间线的更改顺便都带过来,这样一来,别人虽然看不到你的开发时间线,但是看到了你离开的这段时间原来做了这么多的更改啊! 现在用git的专业术语再解释一遍上述场景: 接手新功能的时刻开始,创建一个开发分支(既可以是本地分支也可以是远程分支),以后新功能的开发全部在开发分支上完成,处于开发分支上你可以照常运行 git add ,git commit 等命令,不用担心丢失更改.等工作一段时间后,终于完成了新功能,是时候让新功能展示给其他同事了.此时再切换到原来的主干分支,在主干分支上合并开发分支,现在主干分支上已经有新功能了,这样一来,其他同事突然发现你已经偷偷地完成了新功能的开发! 不仅 git 有分支概念,其他版本控制系统比如 svn 也有分支概念,基本概念和常用操作类似,只不过 git 更强大,创建分支,切换分支,合并分支等功能十分强大,效率太高! (svn 创建分支,切换分支等操作简直慢到可以喝一杯茶了,分支管理都快成摆设了!) 建议 开发新功能时尽量创建自己的分支,不要给其他人造成麻烦 分配任务时要求项目成员创建各自分支,等时机成熟时再合并到主干分支 © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"git/usage/branch-overview.html":{"url":"git/usage/branch-overview.html","title":"分支总览","keywords":"","body":"分支总览 分支就是一条独立的时间线,既有分支,必有主干,正如一棵树谈到树枝,必有树干一样的道理.我们先前对git 的全部操作默认都是在主干上进行的,这个主干也是一种特殊的分支,名为 master 分支. 无论是穿越历史还是撤销更改,我们都或多或少接触过时间线,git 管理的版本串在一起就组成了这个时间线,其中master 分支是当前分支,HEAD 指向master ,因此HEAD 相当于指向了最新的版本. 基于分支上的操作,每一次 commit 都会提交一个新版本,并且新的 commit 指向原来的 commit,这来最新的 commit 就可以往前找,直到找到最初的commit.这就是 git 的时间线. 当我们打算开辟新的时间线时,git 在当前 HEAD 指向的 master 分支的 commit 处新建一个 dev 分支.如果主角没有主动进入时间线的话,那么仍然处于 master 分支,进入的方法就是 HEAD指向新建的 dev 分支. 不考虑孙悟空的分身特效,主角不能同时处于不同的时空下,git 也是如何,HEAD 只能指向某一个 commit ,既然刚刚已经指向了 dev 分支,所以原来的 master 分支就没有 HEAD 了,因为相当于master 分支静止了. 当主角在 dev 分支独自闯荡干出一番事业时,决定回到故乡 master 分支,并将出门在外所学的本领带回家乡,建设美好家园.master 分支因为合并了 dev 分支,所以一下子增添了很多内容,家乡焕然一新! 主角这次携带 dev 分支归来,HEAD 分支自然又回到了 master 分支上,年轻的心向往外面的世间,相信不久后还会有同样的故事发生... 下面详解分支相关命令 创建分支 创建 dev 分支,列出分支已验证是否创建成功 # 创建分支 $git branch dev # 列出分支 $ git branch dev * master $ * master 前面的 * 标记表明当前仍然处于 master 分支 切换分支 切换到新分支以便在分支上开展工作 # 切换分支 $ git checkout dev Switched to branch 'dev' # 列出分支 $ git branch * dev master $ 现在,我们在 dev 分支上奋笔疾书,先后提交两个版本后完成分支开发工作: # 查看当前文件列表 $ ls LICENSE README.md test.txt # 查看目标文件内容 $ cat test.txt add test.txt see https://snowdreams1006.github.io/git/usage/remote-repository.html # 第一个版本: learn git branch $ echo \"learn git branch\" >> test.txt $ git add test.txt $ git commit -m \"learn git branch\" [dev 9c30e50] learn git branch 1 file changed, 1 insertion(+) # 第二个版本: see https://snowdreams1006.github.io/git/usage/branch-overview.html $ echo \"see https://snowdreams1006.github.io/git/usage/branch-overview.html\" >> test.txt $ git add test.txt sunpodeMacBook-Pro:git-demo sunpo$ git status On branch dev Changes to be committed: (use \"git reset HEAD ...\" to unstage) modified: test.txt $ git commit -m \"see https://snowdreams1006.github.io/git/usage/branch-overview.html\" [dev 413a4d1] see https://snowdreams1006.github.io/git/usage/branch-overview.html 1 file changed, 1 insertion(+) 此时,再从 dev 分支切换回 master 分支,合并dev分支前看一下当前文件内容: # 切换回 master 分支 $ git checkout master Switched to branch 'master' Your branch is up to date with 'origin/master'. sunpodeMacBook-Pro:git-demo sunpo$ git status On branch master Your branch is up to date with 'origin/master'. nothing to commit, working tree clean # 查看当前文件列表 $ ls LICENSE README.md test.txt # 查看文件内容: 无 dev 分支更改 $ cat test.txt add test.txt see https://snowdreams1006.github.io/git/usage/remote-repository.html $ 合并分支 切换回 master 分支并没有我们在 dev 分支的更改,因为两条时间线是独立的,现在合并 dev 分支,再看一下当前文件内容: # 合并 dev 分支 $ git merge dev Updating b3d8193..413a4d1 Fast-forward test.txt | 2 ++ 1 file changed, 2 insertions(+) # 查看文件内容: 已经存在 dev 分支的更改! $ cat test.txt add test.txt see https://snowdreams1006.github.io/git/usage/remote-repository.html learn git branch see https://snowdreams1006.github.io/git/ 删除分支 合并分支后,dev 分支的历史使命已经完成,应该及时清空不必要分支. # 删除 dev 分支 $ git branch -d dev Deleted branch dev (was 413a4d1). # 列出当前分支: 只剩下 master 分支 $ git branch * master $ 以上场景包括了分支的常用操作,创建分支(git branch ),切换分支(git checkout ),删除分支(git branch -d )一系列操作十分流畅,因此 git 鼓励我们大量使用分支! 小结 列出分支 git branch 创建分支 git branch 切换分支 git checkout 创建并切换分支 git checkout -b 合并指定分支到当前分支 git merge 删除分支 git branch -d © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"git/usage/branch-merge-with-conflict.html":{"url":"git/usage/branch-merge-with-conflict.html","title":"冲突合并","keywords":"","body":"冲突合并 如果足够幸运的话,团队成员互不影响,彼此相安无事,大家各自基于 master 分支的某个 commit 创建自己的分支,平时在分支上独立工作,等到一段时间后再合并 merge 到 master 分支,这样一样 master 作为各个功能的集大成者,最终完成项目. 然而事情总不是一帆风顺的,团队协作时由于意见不同,遇到冲突简直是家常便饭,既然无法回避冲突,当冲突发生时如何应该呢? 背景 基于 master 分支上的某个 commit ,新功能由此继续开发: echo \"git commit c1\" >> test.txt $ git add test.txt $ git commit -m \"git commit c1\" 新功能分支命名为 feature ,使用git checkout -b 创建分支并切换: $git checkout -b feature Switched to a new branch 'feature' $ 在新功能 feature 分支上开发新功能,并提交: $ echo \"git commit c2\" >> test.txt $ git add test.txt $ git commit -m \"git commit c2\" [feature 0fe95f8] git commit c2 1 file changed, 1 insertion(+) $ 无论新功能 feature 是否开发完毕,团队的其他成员均有可能处于 master 分支并做相应更改: $ git checkout master Switched to branch 'master' Your branch is ahead of 'origin/master' by 3 commits. (use \"git push\" to publish your local commits) 其他成员对新功能有着自己的看法,于是也提交了版本,由于我们之前提交的是 git commit c2,而此时master 分支提交的是git commit c3,显然我们两个人的意见不一致! $ echo \"git commit c3\" >> test.txt $ git add test.txt $ git commit -m \"git commit c3\" [master 0949cc3] git commit c3 1 file changed, 1 insertion(+) $ 正在此时,feature 分支的新功能已开发完毕并主动切换回 master 分支,准备合并 feature 分支. # 合并 feature 分支 $ git merge feature Auto-merging test.txt CONFLICT (content): Merge conflict in test.txt Automatic merge failed; fix conflicts and then commit the result. $ 由于项目成员沟通不畅或者意见不一致,导致了代码冲突,git 作为版本控制系统,自然无法解决这类问题,总不能擅自做主抛弃后来的更改吧或者抛弃分支更改?所以 git 只负责抛出问题,等待我们程序员去解决问题. 既然是人的问题,那我们看一下我们到底是哪里不一致,为什么会产生冲突? # 查看状态 $ git status On branch master Your branch is ahead of 'origin/master' by 4 commits. (use \"git push\" to publish your local commits) You have unmerged paths. (fix conflicts and run \"git commit\") (use \"git merge --abort\" to abort the merge) Unmerged paths: (use \"git add ...\" to mark resolution) both modified: test.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") # 比较差异 $ git diff diff --cc test.txt index 6e00f87,0f95fd7..0000000 --- a/test.txt +++ b/test.txt @@@ -3,4 -3,4 +3,8 @@@ see https://snowdreams1006.github.io/gi learn git branch see https://snowdreams1006.github.io/git/usage/branch-overview.html git commit c1 ++>>>>>> feature 和我们预期一样,test.txt 文件产生了冲突,当前 HEAD 指向的提交即 master 分支是 git commit c3 ,而 feature 分支是 git commit c2,对于同一个文件的同一行内容发生不同的更改,git 不知道也不应该知道如何处理. # 查看内容 $ cat test.txt add test.txt see https://snowdreams1006.github.io/git/usage/remote-repository.html learn git branch see https://snowdreams1006.github.io/git/usage/branch-overview.html git commit c1 >>>>>> feature git 用 标记一个分支冲突开始,======= 标记分支分割线,>>>>>>> 标记另一个分支结束. 经过冲突双方的讨论后,彼此间达成妥协,决定修改成git commit c2 and c3 ,修改后继续提交: # 编辑冲突文件,按照协商一致的内容修改文件 $ vim test.txt # 将冲突内容更改为 git commit c2 and c3 $ cat test.txt add test.txt see https://snowdreams1006.github.io/git/usage/remote-repository.html learn git branch see https://snowdreams1006.github.io/git/usage/branch-overview.html git commit c1 git commit c2 and c3 $ git add test.txt $ git commit -m \"fix conflict\" [master 3b8f434] fix conflict 冲突已经解决,现在回顾一下提交历史,使用git log --graph 图形化展示提交历史: # 查看提交日志 $ git log --pretty=oneline --graph * 3b8f434013caa8c27fade4c59d7aa2ee2c079636 (HEAD -> master) fix conflict |\\ | * 0fe95f871b371834d30ea17faa82f84b7d67672b (feature) git commit c2 * | 0949cc319e099d554795d03c69ee38923af00d6c git commit c3 |/ * 5c482cd9965b9dfd4f273b43b240ed7db66167a8 git commit c1 * 413a4d1d2aab5ab85b6097d4b9f81cb5601c3b26 see https://snowdreams1006.github.io/git/usage/branch-overview.html * 9c30e50248b773e38b032477a859e87abe7c1bb0 learn git branch * b3d8193bbcb9f76c47e831e3e212f2405ae09f93 (origin/master, origin/HEAD) see https://snowdreams1006.github.io/git/usage/remote-repository.html * 8e625640348a47ac922409a1ecb4c844385582aa add test.txt * 9b196aab5bc87eeb11709c9eef35fca283e05c61 Initial commit $ 最后,删除新功能分支 feature ,不用的分支及时清理干净,需要时再创建分支. $ git branch -d feature 小结 无法杜绝冲突的发生,代码上的冲突本质上是人为因素造成的冲突. 解决冲突需要有关双方协商解决,不可能独自解决冲突,除非你抛弃自我,完全以对方为准. 使用 git log --graph 命令可以图表化查看提交历史,抑或 git log --pretty=oneline --graph © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"git/usage/branch-strategy.html":{"url":"git/usage/branch-strategy.html","title":"分支策略","keywords":"","body":"分支策略 默认情况下合并分支常常直接使用 git merge 命令,是最方便快速的合并方法.其实这种情况下 git 采用的是 fast forward 模式,特点是删除分支后,会丢失分支信息,好像从来没存在该分支一样,而我们推荐的是recursive 模式,能够保留分支的版本记录. 递归模式(recursive) 创建并切换 dev 分支,提交版本后切换回 master 分支,然后再合并 dev 分支,这不过这一次不再使用 git merge dev 命令: # 创建并切换 dev 分支 $ git checkout -b dev Switched to a new branch 'dev' # 提交版本 $ echo \"git checkout -b dev\" >> test.txt $ git add test.txt $ git commit -m \"git checkout -b dev\" [dev 44d68f6] git checkout -b dev 1 file changed, 1 insertion(+) # 切换回 master 分支 $ git checkout master Switched to branch 'master' Your branch is ahead of 'origin/master' by 6 commits. (use \"git push\" to publish your local commits) $ 现在添加 --no-ff 参数禁用 fast forward 模式,即git merge --no-ff: $ git merge --no-ff -m \"git merge --no-ff dev\" dev Merge made by the 'recursive' strategy. test.txt | 1 + 1 file changed, 1 insertion(+) $ 上述内容显示,这次使用的不再是 fast forward 模式,而是 recursive 模式,那让我们看一下提交历史有什么不同吧! $ git log --pretty=oneline --graph * 22fbef71b7575cd7eb7911079551618667f9f38f (HEAD -> master) git merge --no-ff dev |\\ | * 44d68f674bc85bc972426c572b78915e850e476c (dev) git checkout -b dev |/ * 3b8f434013caa8c27fade4c59d7aa2ee2c079636 fix conflict |\\ | * 0fe95f871b371834d30ea17faa82f84b7d67672b git commit c2 * | 0949cc319e099d554795d03c69ee38923af00d6c git commit c3 |/ * 5c482cd9965b9dfd4f273b43b240ed7db66167a8 git commit c1 * 413a4d1d2aab5ab85b6097d4b9f81cb5601c3b26 see https://snowdreams1006.github.io/git/usage/branch-overview.html * 9c30e50248b773e38b032477a859e87abe7c1bb0 learn git branch * b3d8193bbcb9f76c47e831e3e212f2405ae09f93 (origin/master, origin/HEAD) see https://snowdreams1006.github.io/git/usage/remote-repository.html * 8e625640348a47ac922409a1ecb4c844385582aa add test.txt * 9b196aab5bc87eeb11709c9eef35fca283e05c61 Initial commit $ 这种递归模式(recursive) 有一个明显的特点就是会产生一个新的 commit ,并不会像之前快速前进模式(fast forward)那样单纯更改 HEAD 的指向. 秉承着阅后即焚的习惯,分支一旦合并后就立即删除,现在删除 dev 分支,看一下会发生什么: # 删除 dev 分支 $ git branch -d dev Deleted branch dev (was 44d68f6). # 查看提交历史 $ git log --pretty=oneline --graph * 22fbef71b7575cd7eb7911079551618667f9f38f (HEAD -> master) git merge --no-ff dev |\\ | * 44d68f674bc85bc972426c572b78915e850e476c git checkout -b dev |/ * 3b8f434013caa8c27fade4c59d7aa2ee2c079636 fix conflict |\\ | * 0fe95f871b371834d30ea17faa82f84b7d67672b git commit c2 * | 0949cc319e099d554795d03c69ee38923af00d6c git commit c3 |/ * 5c482cd9965b9dfd4f273b43b240ed7db66167a8 git commit c1 * 413a4d1d2aab5ab85b6097d4b9f81cb5601c3b26 see https://snowdreams1006.github.io/git/usage/branch-overview.html * 9c30e50248b773e38b032477a859e87abe7c1bb0 learn git branch * b3d8193bbcb9f76c47e831e3e212f2405ae09f93 (origin/master, origin/HEAD) see https://snowdreams1006.github.io/git/usage/remote-repository.html * 8e625640348a47ac922409a1ecb4c844385582aa add test.txt * 9b196aab5bc87eeb11709c9eef35fca283e05c61 Initial commit $ 由此可见,删除 dev 分支后仅仅少了 dev 的引用而已,原来 dev 分支所做的更改全部保留下来了! 快速前进模式(fast forward) 创建并切换 dev 分支,提交版本后切换回 master 分支,然后再合并 dev 分支,使用 git merge dev 命令: # 创建并切换 dev 分支 $ git checkout -b dev Switched to a new branch 'dev' # 提交版本 $ echo \"fast forward\" >> test.txt $ git add test.txt $ git commit -m \"fast forward\" [dev 3fe94c0] fast forward 1 file changed, 1 insertion(+) $ 现在切换回 master 分支,采用默认的git merge 命令合并 dev 分支: $ git checkout master Switched to branch 'master' Your branch is ahead of 'origin/master' by 8 commits. (use \"git push\" to publish your local commits) sunpodeMacBook-Pro:git-demo sunpo$ git merge dev Updating 22fbef7..3fe94c0 Fast-forward test.txt | 1 + 1 file changed, 1 insertion(+) $ 上述内容显示这次合并采用的是快速前进模式(fast forward),让我们看一下提交历史: $ git log --pretty=oneline --graph * 3fe94c0088cae526eda1fb2ffa303001b1eb42ba (HEAD -> master, dev) fast forward * 22fbef71b7575cd7eb7911079551618667f9f38f git merge --no-ff dev |\\ | * 44d68f674bc85bc972426c572b78915e850e476c git checkout -b dev |/ * 3b8f434013caa8c27fade4c59d7aa2ee2c079636 fix conflict |\\ | * 0fe95f871b371834d30ea17faa82f84b7d67672b git commit c2 * | 0949cc319e099d554795d03c69ee38923af00d6c git commit c3 |/ * 5c482cd9965b9dfd4f273b43b240ed7db66167a8 git commit c1 * 413a4d1d2aab5ab85b6097d4b9f81cb5601c3b26 see https://snowdreams1006.github.io/git/usage/branch-overview.html * 9c30e50248b773e38b032477a859e87abe7c1bb0 learn git branch * b3d8193bbcb9f76c47e831e3e212f2405ae09f93 (origin/master, origin/HEAD) see https://snowdreams1006.github.io/git/usage/remote-repository.html * 8e625640348a47ac922409a1ecb4c844385582aa add test.txt * 9b196aab5bc87eeb11709c9eef35fca283e05c61 Initial commit $ 上述内容表明,此次合并并没有产生新的 commit ,只是更改下 HEAD 指向而已(HEAD -> master, dev). 同样,现在删除 dev 分支,再看一下提交历史: # 删除 dev 分支 $ git branch -d dev Deleted branch dev (was 3fe94c0). # 查看提交历史 $ git log --pretty=oneline --graph * 3fe94c0088cae526eda1fb2ffa303001b1eb42ba (HEAD -> master) fast forward * 22fbef71b7575cd7eb7911079551618667f9f38f git merge --no-ff dev |\\ | * 44d68f674bc85bc972426c572b78915e850e476c git checkout -b dev |/ * 3b8f434013caa8c27fade4c59d7aa2ee2c079636 fix conflict |\\ | * 0fe95f871b371834d30ea17faa82f84b7d67672b git commit c2 * | 0949cc319e099d554795d03c69ee38923af00d6c git commit c3 |/ * 5c482cd9965b9dfd4f273b43b240ed7db66167a8 git commit c1 * 413a4d1d2aab5ab85b6097d4b9f81cb5601c3b26 see https://snowdreams1006.github.io/git/usage/branch-overview.html * 9c30e50248b773e38b032477a859e87abe7c1bb0 learn git branch * b3d8193bbcb9f76c47e831e3e212f2405ae09f93 (origin/master, origin/HEAD) see https://snowdreams1006.github.io/git/usage/remote-repository.html * 8e625640348a47ac922409a1ecb4c844385582aa add test.txt * 9b196aab5bc87eeb11709c9eef35fca283e05c61 Initial commit $ 由此可见,快速前进模式一旦删除分支后就彻底丢失了分支的信息,即便是从提交历史中也找不到曾经存在的痕迹! 分支策略 git 是分布式版本控制系统,同时鼓励大量使用分支,如此一来大量的分支该如何管理? 实际开发中,建议准从以下原则进行分支管理: master 分支作为主干分支,负责对外提供服务,要求稳定可靠,因为应该专人负责更新维护. dev 分支作为开发分支,取代 master 分支的开发地位,积累到一定产出时再合并到 master 分支. feature 分支作为新功能分支,根据实际情况动态创建,删除分支,并适时合并到 dev 分支. bugFixed 分支作为修复特定 bug 分支,可能由 master 分支衍生而来,也可能由 dev 分支衍生等等,修复后及时合并到原分支. custom 自定义分支,项目成员私有分支,由上级领导分配任务后各开发人员自行选择创建自己的分支,并根据实际情况决定合并到 dev 分支或 feature 等分支. 小结 快速前进模式(git merge )不保留分支合并历史,递归模式(git merge --no-ff -m )保留分支合并历史. 制定大家都认同的分支管理原则,并严格准守规则. © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"git/usage/branch-emergency-fixbug.html":{"url":"git/usage/branch-emergency-fixbug.html","title":"紧急修复","keywords":"","body":"紧急修复 和往常一样,每个人团队开发者都在自己的本地分支上进行日常工作,相互独立又相互联系,一直以来相安无事,可是某天下午,上级领导突然急冲冲的打电话告诉你线上出bug了,需要你紧急修复,下班之前必须解决! 我们天生就是创造 bug 的特殊群体,每天都在和各种各样的 bug 打交道,早已经习惯了这样的工作节奏,再也没有当初刚刚遇到紧急问题的手足无措,先喝杯茶,冷静一下,然后汇报领导说:放心吧!保证30min 内解决问题! 背景 学习了分支操作的相关知识,团队内部就基本的开发流程达成一致: 假设线上是主干 master 分支,开发是 dev 分支,团队成员是自定义 custom 分支,平时开发时在大家在各自 custom 分支上工作,完成分配任务后再合并到开发 dev 分支,等到开发分支功能稳定后,由项目领导负责合并到主干分支 master . 上述流程只是开发流程的简化版,实际情况更加复杂,后续再介绍 gitflow 工作流相关知识. 由于是线上出现 bug,理所当然是基于 master 分支检出临时分支,修复分支代号为 issue-110,然后定位 bug 并提交,最后再合并到 master 分支,如此一来成功修复 bug,完成既定任务,心安理得准备下班回家! 如果真的向上述步骤那样操作,显然还不够冷静,刚才那一杯茶算是白喝了!因为这样操作可能会丢失现场数据,那很多工作岂不是白做了,下面简单演示一下: 错误示例 (一). 事发前正在自定义的 snow 分支上愉快编码中... # 线上分支 `master`,开发分支 `dev`,自定义分支 `snow`,当前正处于自定义分支 $ git branch dev master * snow # 接到领导电话前正在自定义 `snow` 分支上进行愉快编码中... $ echo \"Happy coding\" >> test.txt $ git add test.txt $ git commit -m \"Happy coding\" (二). 事发时直接检出主分 master 分支,并紧急修复 bug . (2.1) 基于 master 分支检出 issue-110 分支,并修复提交. # 注意: 事发时正在思考人生,此时更改尚未添加到暂存区! $ echo \"who am i\" >> test.txt # 当前情况下,默认不允许直接切换到其他分支,因为工作区更改会被重写,这里为了演示错误示例,强制切换! $ git checkout -f master # 基于主干 `master` 分支检出修复 `issue-110`分支 $ git checkout -b issue-110 Switched to a new branch 'issue-110' # 定位线上 `bug`并修复,假设将 `fast forward` 更改为 `fast forward not recommend`,瞬间修复 `bug`有没有! $ cat test.txt add test.txt see https://snowdreams1006.github.io/git/usage/remote-repository.html learn git branch see https://snowdreams1006.github.io/git/usage/branch-overview.html git commit c1 git commit c2 and c3 git checkout -b dev fast forward $ vim test.txt $ cat test.txt add test.txt see https://snowdreams1006.github.io/git/usage/remote-repository.html learn git branch see https://snowdreams1006.github.io/git/usage/branch-overview.html git commit c1 git commit c2 and c3 git checkout -b dev fast forward not recommend # 修复 `bug` 后,提交更改并备注已修复 $ git add test.txt $ git commit -m \"fix bug about issue-110\" [issue-110 e60c8ad] fix bug about issue-110 1 file changed, 1 insertion(+), 1 deletion(-) sunpodeMacBook-Pro:git-demo sunpo$ git status On branch issue-110 nothing to commit, working tree clean $ (2.1) 切换到主干 master 分支,并合并修复 issue-110 分支 # 切换回 `master` 分支,合并修复 `issue-110` 分支 $ git checkout master Switched to branch 'master' Your branch is up to date with 'origin/master'. $ git merge issue-110 Updating 3fe94c0..e60c8ad Fast-forward test.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) # 验证 `bug` 已修复: 更改为 `fast forward not recommend` $ cat test.txt add test.txt see https://snowdreams1006.github.io/git/usage/remote-repository.html learn git branch see https://snowdreams1006.github.io/git/usage/branch-overview.html git commit c1 git commit c2 and c3 git checkout -b dev fast forward not recommend $ (三). 事发后切换回自定义 snow 分支,打算下班回家. # 切换回 `snow` 分支,发现丢失了事发前的未保存更改:`who am i` $ git checkout snow Switched to branch 'snow' $ cat test.txt add test.txt see https://snowdreams1006.github.io/git/usage/remote-repository.html learn git branch see https://snowdreams1006.github.io/git/usage/branch-overview.html git commit c1 git commit c2 and c3 git checkout -b dev fast forward Happy coding $ 现在还打算下班吗?你所做的更改因为没有提交或者不能提交造成全部丢失! 结果 因为手头工作进行到一半无法提交或者忘记提交等原因,为了临时修复紧急 bug 而直接切换到目标分支再回来时发现更改全部丢失,相当于那部分工作白忙活了! 正确示例 经过上述错误示例的惨痛教训后,再也不敢轻易切换分支了,原因在于工作区更改并没有被提交,或者说不能提交,如果能够有一种机制来保护案发现场,这样我们就能放心切换到其他分支工作,回来时一切如初,那该多好? 幸运的是,git 确实提供这么一种机制,git stash 命令临时存储工作区,类似\"草稿箱\"作用. (一). 恢复工作区丢失更改,并使用 git stash 命令保存现场. # 修复工作区丢失更改: 同样未添加到暂存区 $ echo \"learn git stash\" >> test.txt $ cat test.txt add test.txt see https://snowdreams1006.github.io/git/usage/remote-repository.html learn git branch see https://snowdreams1006.github.io/git/usage/branch-overview.html git commit c1 git commit c2 and c3 git checkout -b dev fast forward Happy coding learn git stash # 保护现场: 存储到\"草稿箱\" $ git stash Saved working directory and index state WIP on snow: 93227ba Happy coding (二). 切换到开发 dev 分支并合并修复 issue-110 分支. # 切换到开发 `dev` 分支 $ git checkout dev Switched to branch 'dev' sunpodeMacBook-Pro:git-demo sunpo$ git status On branch dev nothing to commit, working tree clean # 合并修复 `issue-110` 分支 $ git merge issue-110 Updating 3fe94c0..e60c8ad Fast-forward test.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) sunpodeMacBook-Pro:git-demo sunpo$ git status On branch dev nothing to commit, working tree clean $ (三). 切换回自定义 snow 分支,并恢复工作现场. # 切换回自定义 `snow` 分支 $ git checkout snow Switched to branch 'snow' sunpodeMacBook-Pro:git-demo sunpo$ git status On branch snow nothing to commit, working tree clean $ git status 命令返回结果怎么显示工作区是干净的,好不容易才将丢失的更改找回来怎么又不见了?!逗我玩? 冷静,冷静,不要慌,既然工作现场已经保存到\"草稿箱\",那我们想要找回总要去\"草稿箱\"才能取出来吧?现在让我们看一下\"草稿箱\"有没有我们的工作现场? # 查看存储的\"草稿箱\"列表 $ git stash list stash@{0}: WIP on snow: 93227ba Happy coding $ 这里的 stash@{0} 是草稿 id,因为\"草稿箱\"允许保存多条草稿! 现在放心了吧,保存的\"草稿\"安然无恙躺在未知的某个地方,现在我们想办法恢复回工作区即可! git stash apply 恢复草稿,然后 git stash drop 删除草稿 git stash pop 恢复并删除草稿 # 恢复工作现场 $ git stash pop On branch snow Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: test.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") Dropped refs/stash@{0} (b0c8ddc034d21f31204c82e9838fc5d4c01a49a8) # 工作现场已恢复,更改未添加到暂存区,`learn git stash` 又恢复了! $ git status On branch snow Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: test.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") $ cat test.txt add test.txt see https://snowdreams1006.github.io/git/usage/remote-repository.html learn git branch see https://snowdreams1006.github.io/git/usage/branch-overview.html git commit c1 git commit c2 and c3 git checkout -b dev fast forward Happy coding learn git stash 结果 不论手头工作有没有提交,一旦工作区保存到\"草稿箱\"后,就放心大胆切换分支进行工作,回来时岁月静好,一切如初! 小结 紧急修复 bug 时,可以通过 git stash 保护工作现场,然后再切换到目标分支,检出修复分支,完成修复后切换到目标分支,合并修复分支,最后删除修复分支,此时再切换回本地分支后一切如初! 工作区更改添加到\"草稿箱\" : git stash,支持多次添加到\"草稿箱\" 列出\"草稿箱\"内容 : git stash list 恢复\"草稿箱\"内容 : git stash apply 删除\"草稿箱\"内容 : git stash drop 恢复并删除\"草稿箱\"内容 : git stash pop 恢复|删除指定\"草稿箱\"内容 : git stash ,例如 git stash apply stash@{0} © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"git/usage/branch-rebase.html":{"url":"git/usage/branch-rebase.html","title":"变基合并","keywords":"","body":"变基合并 git 鼓励大量使用分支---\"早建分支!多用分支!\",这是因为即便创建再多的分支也不会造成存储或内存开销,并且分支的作用有助于我们分解逻辑工作,这样一样其实比维护单一臃肿分支要简单得多! 正因如此,每个新功能会创建合并分支,修复 bug 会创建合并分支等等,一段时间后再次回顾整个版本库的提交历史就会发现分支错综复杂,难以理清! 虽然\"条条大路通罗马\",但错综复杂的道路容易让人迷失方向,如果不使用分支,当然就不存在\"分叉问题\",所以在某些情况下我们希望寻求一种替代方案来解决分支合并带来的\"分叉问题\"! 回顾提交历史 查看提交历史: git log --pretty=oneline --graph --abbrev-commit # 查看提交历史 $ git log --pretty=oneline --graph --abbrev-commit * e60c8ad (HEAD -> dev, origin/master, origin/HEAD, master) fix bug about issue-110 * 3fe94c0 fast forward * 22fbef7 git merge --no-ff dev |\\ | * 44d68f6 git checkout -b dev |/ * 3b8f434 fix conflict |\\ | * 0fe95f8 git commit c2 * | 0949cc3 git commit c3 |/ * 5c482cd git commit c1 * 413a4d1 see https://snowdreams1006.github.io/git/usage/branch-overview.html * 9c30e50 learn git branch * b3d8193 see https://snowdreams1006.github.io/git/usage/remote-repository.html * 8e62564 add test.txt * 9b196aa Initial commit 仅仅是简单的演示项目的提交历史都已经出现\"分叉问题\",更何况真实的企业级开发项目呢?如果真的是多分支多人合作开发的话,\"分叉现象\"将更加明显,模拟效果图大概长这样: 整理提交历史 如果想要一条直路直达罗马,那我们必须规划好路径,摒弃小道,坚持主干道.git 的各种 dev,feature等分支就是需要治理的一条条分叉小道,而 master 主分支就是我们的大道. 演示项目有三个分支,主干master,开发dev,自定义snow,目标是将自定义 snow 分支的工作成功整理合并到主干分支,从而解决\"分叉问题\",dev 分支与项目演示无关,无需更改. (1). 切换到 snow 分支并提交一个版本(learn git rebase) # 切换到 `snow` 分支 $ git checkout snow Switched to branch 'snow' # 追加新内容到 `test.txt` 文件 $ echo \"learn git rebase\" >> test.txt # 提交到版本库 $ git commit -am \"learn git rebase\" [snow 7d21e80] learn git rebase 1 file changed, 1 insertion(+) $ (2). 切换到 master 分支也提交一个版本(modify README) # 切换回 `master` 分支 $ git checkout master Switched to branch 'master' Your branch is up to date with 'origin/master'. # 追加新内容到 `README.md` 文件 $ echo \"learn git ,share git\" >> README.md # 提交到版本库 $ git add README.md $ git commit -m \"modify README\" [master 3931d48] modify README 1 file changed, 1 insertion(+) $ (3). 切换回 snow 分支,整理提交历史(git rebase)到 master 分支 # 切换到 `snow` 分支 $ git checkout snow Switched to branch 'snow' # 改变基础版本(父版本),简称\"变基\" $ git rebase master HEAD is up to date. # 当前提交历史线 $ git log --pretty=oneline --graph --abbrev-commit * e92f068 (HEAD) rebase * 72f4c01 fix confict about happy coding * 3931d48 (master) modify README * e60c8ad (origin/master, origin/HEAD, dev) fix bug about issue-110 * 3fe94c0 fast forward * 22fbef7 git merge --no-ff dev |\\ | * 44d68f6 git checkout -b dev |/ * 3b8f434 fix conflict |\\ | * 0fe95f8 git commit c2 * | 0949cc3 git commit c3 |/ * 5c482cd git commit c1 * 413a4d1 see https://snowdreams1006.github.io/git/usage/branch-overview.html * 9c30e50 learn git branch * b3d8193 see https://snowdreams1006.github.io/git/usage/remote-repository.html * 8e62564 add test.txt * 9b196aa Initial commit $ (4). 切换回 master 主干分支再次变基合并 snow 分支 # 切换回 `master` 分支 $ git checkout master Warning: you are leaving 2 commits behind, not connected to any of your branches: e92f068 rebase 72f4c01 fix confict about happy coding If you want to keep them by creating a new branch, this may be a good time to do so with: git branch e92f068 Switched to branch 'master' Your branch is ahead of 'origin/master' by 1 commit. (use \"git push\" to publish your local commits) # 改变父版本为 `snow` 分支指向的版本 $ git rebase snow First, rewinding head to replay your work on top of it... Applying: modify README $ (5). 整理分支完成,最终主干分支是一条直线 # 查看提交历史线 $ git log --pretty=oneline --graph --abbrev-commit # `modify README` 是 `master` 分支提交的版本 * dcce09c (HEAD -> master) modify README # `learn git rebase` 是 `snow` 分支提交的版本 * 7d21e80 (snow) learn git rebase * a06a866 fix conflict |\\ | * e60c8ad (origin/master, origin/HEAD, dev) fix bug about issue-110 * | ab846f9 learn git stash * | 93227ba Happy coding |/ * 3fe94c0 fast forward * 22fbef7 git merge --no-ff dev |\\ | * 44d68f6 git checkout -b dev |/ * 3b8f434 fix conflict |\\ | * 0fe95f8 git commit c2 * | 0949cc3 git commit c3 |/ * 5c482cd git commit c1 * 413a4d1 see https://snowdreams1006.github.io/git/usage/branch-overview.html * 9c30e50 learn git branch * b3d8193 see https://snowdreams1006.github.io/git/usage/remote-repository.html * 8e62564 add test.txt 这一次我们没有使用 git merge 而是采用 git rebase 方式完成了分支的合并,优点是提交历史更清晰,缺点是丢失了分支信息. 小结 git rebase 变基合并分支,实际上就是取出一系列的提交版本并“复制”到目标版本,从而形成一条新的提交历史线. 比如我们想要把 bugFix 分支里的工作直接移到 master 分支上,移动以后会使得两个分支的功能看起来像是按顺序开发,但实际上它们是并行开发的,这就是 git rebase 的作用. git rebase 的优势是创造更线性的提交历史,使得代码库的提交历史变得异常清晰,劣势是缺失了分支信息,好像从没存在过该分支一样. 将目标分支上的工作成果转移到到主干分支 : git rebase master 主干分支接收已转移好的目标分支工作成果 : git rebase © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"git/usage/branch-remote.html":{"url":"git/usage/branch-remote.html","title":"协同开发","keywords":"","body":"协同开发 前面我们已经介绍过远程仓库的相关概念,不过那时并没有深入探讨,只是讲解了如何创建远程仓库以及推送最新工作成果到远程仓库,实际上远程仓库对于团队协同开发很重要,不仅仅是团队协同开发的基础,也是代码备份的保障手段,现在我们先简单回忆下相关概念,以便为接下来的协同开发做好铺垫! 远程仓库和远程分支 远程仓库 远程仓库其实并不复杂,实际上只是本地电脑上的本地仓库在另一台远程电脑的备份而已. 相对本地仓库来说远程电脑上的版本库自然就是远程仓库,远程仓库使得我们的版本库更加安全,毕竟远程电脑可不是一般的电脑,出错的概率比我们平时工作所使用的电脑概率要小得多,这样一来即使不小心丢失了本地仓库的全部数据,只要远程仓库没有丢失,那我们就可以通过远程仓库重新取回最新数据! 还有一点,远程仓库让代码社交化,因为大家有了一致途径来访问远程仓库,团队也好或者陌生人也罢,只有你愿意,他们就可以获取远程仓库的最新代码并参与开发,这也是 github 的一大亮点! 远程分支 回顾好远程仓库的概念后,我们再来讲一下本地仓库的远程分支是什么意思? 当前你正在工作的电脑上存储的是本地仓库,如果没有远程仓库的支持,只能一个人鼓捣,别人无法共享你的工作成果,现在加入了团队开发流程,自然不再一个人独自开发,需要和团队其他人协同开发,共享开发成果. 所以本地仓库必然保存着远程仓库的基本信息,只有区分好自己的工作成果和公共成果,才能不乱套,又能做到信息及时共享. 实际上,在项目初期刚刚拷贝远程仓库(git clone)时,git 已经默认在本地仓库创建一个远程分支(origin/master),本地修改提交首先都是在本地仓库完成的,比如 git add,git commit 等命令,如果需要发布你的工作成果,那么就需要使用 git push origin 命令推送到远程仓库,这里的 origin 指的就是远程仓库名称(因为最初大家都是先从远程仓库克隆下来的,所以远程仓库存储的项目相当于原始项目,故而叫origin). git clone 命令帮助本地仓库的 master 分支和远程仓库的 master 分支建立了关联,一般称远程仓库名称为 origin. 查看远程仓库信息 : git remote 或 git remote -v # 查看远程仓库名称 $ git remote origin # 查看远程仓库详情 : 拉取和推送链接 $ git remote -v origin git@github.com:snowdreams1006/git-demo.git (fetch) origin git@github.com:snowdreams1006/git-demo.git (push) $ 本地分支推送到远程仓库 : git push origin 本地仓库和远程仓库的分支理论上应该一一对应,本地仓库的主干分支叫做 master ,而远程仓库也有相应的分支叫做 master ,这种映射关系是使用 git clone 命令时默认生成的,也是推荐的做法. 一般来说,本地仓库的分支推送到远程仓库指的就是推送到远程仓库同名的分支上,例如 git push origin master 意思是: 推将本地仓库的 master 分支推送到远程仓库的 master分支,当然你也可以推送其他分支到相应的远程分支上. 按照之前约定的分支管理策略来说,master 分支用于生产环境部署,dev 分支用于收集开发成果,feature 分支用于开发具体功能分支,既然如此,那这些本地分支哪些需要同步推送到远程仓库就比较清晰了! 推送本地 master 分支到远程仓库的 master 分支 : git push origin master 推送本地 dev 分支到元层仓库的 dev 分支 : git push origin dev # 查看当前分支 : `master` 主分支 $ git branch dev * master snow # 推送本地 `master` 分支到远程仓库 `origin` 上相应的 `master` 分支 $ git push origin master Counting objects: 15, done. Delta compression using up to 4 threads. Compressing objects: 100% (15/15), done. Writing objects: 100% (15/15), 1.31 KiB | 1.31 MiB/s, done. Total 15 (delta 9), reused 0 (delta 0) remote: Resolving deltas: 100% (9/9), completed with 3 local objects. To github.com:snowdreams1006/git-demo.git e60c8ad..dcce09c master -> master $ 正常来说,本地仓库的 master 分支应该领先远程仓库 origin 上的 master 分支若干个版本. 一旦我们已经将本地分支上的工作成果推送到远程仓库上相应分支时,本地仓库和远程仓库这时候就保持一致了. $ git status On branch master Your branch is up to date with 'origin/master'. nothing to commit, working tree clean $ 远程仓库下载到本地分支 : git fetch 远程仓库的操作可以简单归纳为两部分: 上传和下载. 本地仓库推送到远程仓库是上传,而远程仓库拉取到本地仓库就是下载. 团队多人协作开发时,大家都会定期或不定期往 master 或 dev 等分支上推送各自的更改,相应的我们就需要下载别人的最新工作成果. 现在模拟其他伙伴正在往 master 分支上推送更改,最好在另一个电脑另一个账户,当然模拟的话也可以是同一个电脑下其他目录,或者最简单的方式,直接登录 github 更改 master 分支上某个文件内容,简单起见,我们采用最后一种方式. 其他伙伴已往远程仓库上的 master 分支提交了新的版本: 创建 git-remote.txt 文件 现在我们想要下载其他人的最新工作成果,接下来让我们看看本地仓库的 master 还能和远程仓库的 master 分支保持一致吗? # 下载远程仓库的 `master` 分支 $ git fetch origin master remote: Enumerating objects: 4, done. remote: Counting objects: 100% (4/4), done. remote: Compressing objects: 100% (2/2), done. remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (3/3), done. From github.com:snowdreams1006/git-demo * branch master -> FETCH_HEAD dcce09c..10942ff master -> origin/master $ 执行 git fetch 命令后,远程仓库上的最新提交记录已经下载到本地仓库,同时更新了本地仓库的远程分支origin/master ,值得注意的是本地仓库的 master 分支并没有更新! 那你可能会有疑问了,我想要的结果是下载其他人的最新工作成果,怎么我本地仓库的 master 分支并没有更新呢? # 查看工作区 $ ls LICENSE README.md test.txt # 查看版本库状态 $ git status On branch master Your branch is behind 'origin/master' by 1 commit, and can be fast-forwarded. (use \"git pull\" to update your local branch) nothing to commit, working tree clean $ 既然 git fetch 并没有更新本地仓库的 master 分支,那它到底做了哪些工作呢? git fetch 会做的事情 实际上, git fetch 完成了仅有的但是很重要的两步操作: 从远程仓库下载本地仓库中缺失的提交记录 更新本地仓库的远程分支(比如origin/master) 通过上述两步操作完成的效果是: 将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态. 远程分支实际上是反映了远程仓库在你最后一次与它通信时的状态,而git fetch 就是你与远程仓库通信的方式了！ git fetch 不会做的事情 git fetch 并不会改变你本地仓库的状态,所以也就不会更新你的 master分支,自然也不会修改你磁盘上的文件. 理解这一点很重要,因为许多开发人员误以为执行了 git fetch 以后，他们本地仓库就与远程仓库同步了. 实际上它可能已经将进行这一操作所需的所有数据都下载了下来,但是并没有修改你本地的文件. 既然本地仓库的远程分支已更新,那么想要更新本地仓库的 master 分支该如何做呢?很简单,可以 git merge 啊! 远程仓库更新到本地分支 : git pull 其实通过 git fetch 命令我们已经下载了远程仓库的最新版本,只不过还没有合并到本地仓库而已,如何合并分支相信大家已经轻车熟路了,有很多方法: git merge origin/master git rebase origin/master git cherry-pick origin/master 实际上,先抓取更新(git fetch)再合并(git merge)这个流程很常用,因此 git 是有专门的命令来完成这两步操作的,这就是拉取更新git pull --- 刚好与推送更新 git push 相反! # 拉取最新版本 $ git pull Updating dcce09c..10942ff Fast-forward git-remote.txt | 1 + 1 file changed, 1 insertion(+) create mode 100644 git-remote.txt # 查看版本库状态 $ git status On branch master Your branch is up to date with 'origin/master'. nothing to commit, working tree clean # 查看工作区内容: 文件已更新 $ ls LICENSE README.md git-remote.txt test.txt $ 团队协作 掌握了远程仓库和远程分支的相关概念后,现在开始真正模拟团队协作开发了,为了简单起见,仍然以直接操作 github 上的 master 分支为例说明如何协同开发. (1). 其他人已往远程仓库推送2个版本 (2). 你正在本地仓库提交1个版本 $ echo \"learn teamwork\" >> test.txt $ git commit -am \"learn teamwork\" [master f971647] learn teamwork 1 file changed, 1 insertion(+) $ (3). 你推送到远程仓库前先拉取最新版本 # 拉取最新版本,并尝试合并 $ git pull remote: Enumerating objects: 8, done. remote: Counting objects: 100% (8/8), done. remote: Compressing objects: 100% (5/5), done. remote: Total 6 (delta 0), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (6/6), done. From github.com:snowdreams1006/git-demo 10942ff..612e08a master -> origin/master Merge made by the 'recursive' strategy. git-remote.txt | 2 ++ 1 file changed, 2 insertions(+) # 查看版本库状态 $ git status On branch master Your branch is ahead of 'origin/master' by 2 commits. (use \"git push\" to publish your local commits) nothing to commit, working tree clean # 查看其他人工作成果 $ cat git-remote.txt git remote git clone git commit -am \"fake second teamwork\" # 查看自己即将推送的工作成果 $ cat test.txt add test.txt see https://snowdreams1006.github.io/git/usage/remote-repository.html learn git branch see https://snowdreams1006.github.io/git/usage/branch-overview.html git commit c1 git commit c2 and c3 git checkout -b dev fast forward not recommend Happy coding learn git stash learn git rebase learn teamwork $ (4). 你将本地仓库更改内容推送到远程仓库 # 推送到远程仓库 $ git push origin master Counting objects: 5, done. Delta compression using up to 4 threads. Compressing objects: 100% (5/5), done. Writing objects: 100% (5/5), 564 bytes | 564.00 KiB/s, done. Total 5 (delta 3), reused 0 (delta 0) remote: Resolving deltas: 100% (3/3), completed with 3 local objects. To github.com:snowdreams1006/git-demo.git 612e08a..8fe5aba master -> master $ 现在前往 github 网站确认我们已经推送成功,我们的工作成果和其他人的工作成果同时存在于远程仓库中,这样就完成了一次团队协同开发的案例. 现在简单回顾一下整个协同开发流程: 其他人先于我们提交2个版本 我们本地提交1个版本 本地版本推送前拉取远程仓库 本地仓库推送到远程仓库 小结 查看远程仓库信息: git remote -v 本地仓库推送到远程仓库: git push origin 远程仓库抓取到本地仓库: git fetch 远程仓库拉取到本地仓库: git pull 相当于 git fetch 和 git merge 本地创建和远程仓库一致的分支: git checkout -b origin/,本地和远程分支名称最好一直,比如本地 master 和 远程 origin/master,本地 dev 和远程 origin/dev 本地分支和远程分支建立关联: git branch --set-upstream origin/ ,足够任性的话,本地 dev 可以关联远程 remote-dev 等,不过建议名称最好一致. 团队协同开发时,不仅平时要定期拉取(git pull),推送到远程仓库前更应先拉取(git pull)再推送(git push),如出现冲突,解决冲突后再推送. © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"git/usage/local-remote-repository.html":{"url":"git/usage/local-remote-repository.html","title":"本地和远程仓库的本质","keywords":"","body":"本地和远程仓库的本质 本地仓库和远程仓库在本质上没有太大区别,只不过一个是本地电脑,一个是远程电脑. 远程仓库不一定非得是 github 那种专门的\"中央服务器\",甚至局域网的另外一台电脑也可以充当\"中央服务器\"的角色,因为它存在的最初目的只是方便大家交换彼此的提交记录而已! 所以本地仓库和远程仓库的基本行为应该是一致的,约定俗成的规定是远程仓库一般不直接参与日常开发工作,主要作为项目托管中心. 某些自动化持续集成环境中也可能会直接操作远程仓库,这时远程仓库就真的和本地仓库没什么区别了! 个人开发常用命令 个人开发看重的是效率,同时兼顾下版本控制的话算是是锦上添花,git 的本地仓库是本地备份,而远程仓库则是网盘备份. git init : 初始化本地项目 将本地项目初始化 git 项目,直观表现是在该项目同级目录下多了 .git 隐藏目录,其存储着 git 版本库相关信息. 此后当前项目便具备了本地管理的能力,可以与 git 进行交互. git clone : 克隆远程项目 同 git init 一样的作用,也是创建本地仓库,只不过 git init 是直接将本地项目作为本地仓库,而git clone 是将远程项目克隆到本地并作为本地仓库. 由此可见,git clone 比 git init 多了一层远程仓库的概念. git add : 添加文件 将工作区的提交记录添加到暂存区,暂存区是工作区和版本库交互的桥梁,暂存区积累到一定量的提交记录时可以批量提交到版本库,这一点暂存区有点像缓存. git commit : 提交文件 将暂存区的版本提交到版本库,从而形成工作区->暂存区->版本库的基本链路,本地工作区的版本控制流程大致如此. git push : 推送文件 如果是使用 git clone 命令克隆的本地项目,当工作到一定程度时可能需要将这部分工作成果推送到远程仓库,这时候使用 git push 命令完成本地版本的推送流程. 如果是使用 git init 命令初始化的本地项目,可能没有远程仓库,自然也就不需要推送.如果后来创建了远程仓库,那么你自然是想要将本地仓库推送到远程仓库的,因此你需要准确告诉 git 你要推送到哪个远程仓库. 使用 git remote add origin git@github.com:username/repos.git 命令添加远程仓库信息,这样就建立了本地仓库和远程仓库的关联,以后就可以正常推送到远程仓库了. 团队开发常用命令 团队开发注重的不仅是个人效率还有团队的整体进度,随着企业级开发的日趋复杂化,不再是一个人能够独立完成的,更何况时间也不允许慢慢完成,大多数公司采用的是人力换时间的方式,团队并行开发来缩短整个项目周期,这种复杂需求下正是 git 大展拳脚的好机会. 项目整体采用并行开发模式,拆解成不同的功能模块,每个人负责各自模块,模块之间相对独立但也不排除存在交集的可能性.对于每一个个体开发者来说,既需要版本控制又需要团队交流.这时候分支的作用就凸显出来了. 根据项目的业务特点将其拆解成不同的功能模块,这些功能模块分别代表不同的分支,而这些功能模块又组成了完整的项目,这就是主干和分支的关系. 初始时项目是一个整体,中间拆解成不同功能模块,最后再合并成一个整---\"分久必分合久必分\". git branch : 创建分支 每一个独立的功能模块被定义成一个单独分支,创建分支的过程其实是拆解项目的过程,创建本地分支后就在分支上开发特有功能,不再关心其他功能分支. git checkout : 切换分支 模块拆解完成并创建了相应的分支后,需要切换到既定分支上才能开展自己的工作. git merge : 合并分支 没有绝对的独立,项目再怎么拆分也是整体的一部分,肯定需要和其他功能模块发生关系,某些情况下需要其他分支的工作成果合并到自己的本地仓库中,这样才能完成一次小规模的组装. 可以预期的是,当这种组装足够多的时候,最终便会演变成项目的终极形态,形成一个整体. git fetch : 抓取远程分支 合并目标分支首先需要能够获取到目标分支的提交记录,既然每个功能模块都是不同的项目成员负责开发的,也就不在我们电脑上,所以我们先要将目标分支下载到我们本地电脑,然后才能合并该分支到本地分支. git pull : 拉取远程分支 \"先下载目标分支再合并到本地分支,从而小规模组成更复杂更强大的功能\",每一次的组装过程都需要两步操作者显然不符合懒人思维啊,git pull 就是这两步操作的简化命令,先下载再合并就是这么简单! 本地和远程仓库的碰撞 不论是个人开发还是团队开发,我们几乎习惯惯站在主动方的角度来思考问题,有没有想过当远程仓库接收到我们的git push 或 git pull 请求时,远程仓库发什么了什么改变,这种改变对本地仓库又有什么影响? 远程仓库(远程电脑上的本地仓库)只是众多分布式电脑上本地仓库中的一员,说它特殊也很特殊,充当着\"中央服务器\"作用,其余人统一从这里下载或推送;说它普通也很普通,和本地电脑上的本地仓库没有什么不同,因为它随时可被任意电脑上的本地仓库所取代! 揭开远程仓库的神秘面纱后,现在我们只需要将其视为普通的本地仓库一样对待即可,然而我们本地电脑上已经有了本地仓库,故而需要将远程仓库做一下简单标识区分(origin)称之为远程分支. 先说说 git push 命令做了什么? 对于本地来说,git 将本地仓库的指定分支推送到远程仓库的相应分支,同时更新了本地仓库的远程分支. 对于远程来说,git 接收到本地仓库的推送请求时应该在相应分支上合并本地分支,同时更新远程仓库的相应分支. 只要本地的指定分支成功推送到远程的相应分支时,对于本地来说,不论是指定分支还是远程分支(origin/master)都应该是最新状态,因为已经与服务器同步了. 而远程接收到此次推送请求时,应该尝试合并此次推送请求,再更新自己的相应分支,远程合并完成后再通知本地此次推送结果,如此一来,三端同步,皆大欢喜! 再讲讲 git pull 命令发生了什么? 对于远程来说,接收到本地的拉取请求时,因为没有新版本需要处理,所以无需任何操作. 对于本地来说,当远程仓库的相应分支下载到本地时应该更新远程分支状态,再尝试合并到本地的相应分支. git pull 命令或者说是 git fetch 命令是本地和远程通信的方式,所以 origin/master 会自动更新! 小结 本地仓库和远程仓库本质上没有太大区别, git fetch 是本地仓库和远程仓库之间的通信途径,本地仓库中的远程分支(origin/master)保存着它们之间最后一次的通信状态. © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"git/usage/tag.html":{"url":"git/usage/tag.html","title":"里程碑式标签","keywords":"","body":"里程碑式标签 \"春风得意马蹄疾,一日看尽长安花\",对于项目也是如此,最值得期待的恐怕就要数新版本发布的时刻了吧?每当发布新版本时要么是版本号命名(比如v0.0.1)或者代号命名(比如Chelsea),不管怎么说这种里程碑阶段总是要留下些许纪念意义. 既然想要纪念这种特殊的历史时刻,自然是希望它能够固定下来,不要发生随意移动,产生不可预期后果. 这种需求其实和我们前面说的分支概念很相似,均是源于特殊的版本号,逐渐收集起一系列版本,最终形成一条相对独立的历史线,但分支并不是实现里程碑概念的最佳选择,为什么? 分支适合多人协作开发时互不影响,适当时机主动合并他人工作成果这种模式,而这种模式是由不同的功能模块进行驱动的,正所谓\"天下大势分久必合,合久必分\",当功能模块开发完毕后自然也就没有分支存在的必要性,更何况分支在收集版本的过程中会一直移动,并没有特殊的固定版本,显然分支不是最佳选择! 但是,分支确定一定程度上和里程碑概念很相似,源于特定版本,自主命名,收集版本等,那么何必重头再来,为何不复用已有概念呢? 实际上,git 中的标签(tag) 就是实现里程碑概念的方式,它可以永久性指向特定的提交并将命名,然后就可以将其理解成分支一样引用了! 但标签(tag)不是分支(branch),标签是一个点的话,分支就是若干点连接而成的线,标签是静态的,分支是动态的,标签是只读的,分只是可读可写的. 创建标签 git tag # 方式一: 默认 `HEAD` 指向的版本 git tag v0.0.1 # 方式二: 指定 `commit_id` 表示的版本 git tag v0.0.2 f971647 # 方式三: 指定 `commit_id` 表示的版本,同时创建标签说明信息 git tag -a v0.0.3 -m \"v0.0.3\" f971647 列出标签 git tag git tag 显示标签 git show git show v0.0.1 删除标签 git tag -d git tag -d v0.0.1 推送标签 git push origin git push origin v0.0.1 推送全部标签 git push origin --tags git push origin --tags 删除远程标签 git tag -d git push origin :refs/tags/ # 删除本地标签 git tag -d v0.0.1 # 推送删除标签(删除也是推送) git push origin :refs/tags/v0.0.1 © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"git/custom/about.html":{"url":"git/custom/about.html","title":"个性化 git","keywords":"","body":"个性化 git 前情概要 初识 git 时,我们就已经接触过 git 的基本配置,使用 git config 命令配置用户名和邮箱: # 配置当前项目(`local`)的用户名(`snowdreams1006`) git config --local user.name \"snowdreams1006\" # 配置当前项目(`local`)的邮箱(`snowdreams1006@163.com`) git config --local user.email \"snowdreams1006@163.com\" 快速回忆一下配置的相关语法: # 查看默认全部配置: `local>global>system` git config --list # 查看当前项目配置,等同于 `.git/config` 文件 git config --local --list # 查看当前用户配置,等同于 `~/.gitconfig` 文件 或 `~/.config/git/config` 文件 git config --global --list # 查看当前系统配置,等同于 `/etc/gitconfig` 文件 git config --system --list man git-config 查看帮助文档,git 的配置文件是普通文本,也可以直接编辑. 高频配置 总体来说,git 的配置项基本分为两类: 客户端和服务端.其中大部分属于客户端配置, 除非使用自己搭建私服,否则没机会手动配置服务端(第三方服务器基本都支持可视化配置,比如禁止强制推送等配置). alias 别名 熟悉 linux 操作的小伙伴对 ll 这个命令可能再熟悉不过了,是 ls -l 的缩写,称之为别名. git 也支持别名,有个别名我们可以将常用的命令都缩短,大大降低出概率,提高工作效率. # `git checkout` 缩写成 `git co` git config --global alias.co checkout # `git commit` 缩写成 `git ci` git config --global alias.ci commit # `git branch` 缩写成 `git br` git config --global alias.br branch 如此一来,以后再也不用担心打错字了,简化命令,懒人至上! core.editor 编辑器 默认情况下,git 使用的是 $VISUAL 或 $EDITOR 配置的文本编辑器,如果没有设置,则调用 vi 编辑器创建和编辑文本信息. 查看当前编辑器配置项: # 查看编辑器配置项: 若没配置过,则无内容输出,已配置过的话,会输出相应编辑器信息 git config core.editor 假设使用 sublime 作为默认编辑器,那么便可如下设置: # `Mac` 系统如下设置: 设置成自己的 `Sublime` 的安装路径 git config --local core.editor \"'/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl' -n -w\" # `Windows` 系统如下设置: 设置成自己的 `Sublime` 的安装路径 git config --local core.editor \"'F:\\Sublime Text 3 sublime text.exe' -n -w\" 此时再次查看编辑器配置项应该会输出刚才配置信息,接下来我们验证下编辑器的效果: 查看提交历史,已经提交成功(之前备注信息是在命令行中直接输入的,而现在是在编辑器中编辑) $ git log --pretty=oneline --abbrev-commit 43fa8aa (HEAD -> master) validate sublime successfully 00e16d7 ok 2400f11 git config --local core.editor \"'/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl' -n -w\" 0d60cb8 ok 8fe5aba (origin/master, origin/HEAD) Merge branch 'master' of github.com:snowdreams1006/git-demo $ 如果只是输入简单备注,根本用不到编辑器,若提交备注有格式化要求时再手动输入就显得力不从心了! core.template 提交模板 如果你需要格式化提交备注,那么这种情况下模板文件最好不过了,和自定义的编辑器一起搭配,这样就能约束自己和他人按照既定格式规范填写提交备注,方便以后统一管理. 查看当前提交模板配置: git config commit.template 假设你在当前项目下创建 commit-template.txt 模板文件,内容如下: # This is commit template # snowdreams1006 # git-demo 将编辑好的模板文件设置成提交默认信息,需要如下设置: git config --local commit.template commiit-template.txt 此时再次运行 git config commit.template 查看已配置提交模板,现在看一下实际效果: 查看提交历史,当然也提交成功啦,可根据实际需求定制适合自己的提交模板. $ git log --abbrev-commit commit a2ca3f0 (HEAD -> master) Author: snowdreams1006 Date: Wed Mar 27 16:22:18 2019 +0800 ok myself yes commit 43fa8aa Author: snowdreams1006 Date: Wed Mar 27 14:58:36 2019 +0800 validate sublime successfully commit 00e16d7 Author: snowdreams1006 Date: Wed Mar 27 14:56:20 2019 +0800 ok commit 2400f11 git 还支持其他配置,暂时不一一介绍了,详情请参考在线帮助文档: man git-config © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"git/custom/ignore.html":{"url":"git/custom/ignore.html","title":"忽略文件","keywords":"","body":"忽略文件 \"并不是所有的牛奶都叫特仑苏\",在版本控制系统中也有相似的表达,那就是\"并不是所有的文件都需要提交\". 有的是因为没必要提交,比如日志文件,系统缓存文件等,有的是因为不能提交,比如个人隐私文件,付费文档等. 正常来说,这些文件都是不应该被提交到版本库,倘若一不留神提交到版本库,要么泄露机密信息,要是造成经济损失,要么对团队其他人工作造成不便. 有鉴于此,我们应该寻求一种机制来规避事故的发生,在 git 版本控制系统中一般有三种不同的解决方案. 最常用也是最简单的当属 .gitignore 文件,不过先不要着急,我们先了解一下忽略原则和配置规则. 忽略文件的基本原则 忽略操作系统自动生成的文件,保持不同操作系统的纯粹性和整洁度. 忽略工具软件自动生成的文件,避免因个性化配置而产生的工作障碍. 忽略个人隐私配置文件,除非你愿意承担公开隐私所带来的潜在风险. 目标: 只提交必要文件,忽略无用文件,尽可能考虑多种情况,不给他人制造麻烦. 忽略文件的配置规则 一行记录代表一条规则,配置规则仅针对尚未被跟踪的文件清单. # 忽略 `*.a` 文件 *.a # 忽略 `*.A` 文件,但 `somefile.A` 除外. *.A !somefile.A # 忽略 `*.b` 和 `*.B` 文件 *.[bB] # 忽略 `*.c` 和 `*.C` 文件,但 `somefile.C` 除外. *.[cC] !somefile.C # 只忽略 `somepath/` 目录(包括该目录下所有文件),但不忽略 `somepath` 文件 somepath/ # 只忽略 `somepath/` 一级子目录下 `*.txt`,但不忽略 `somepath/sub/*.txt` 文件 somepath/*.txt # 忽略 `somepath` 文件和 `somepath` 目录 somepath # 只忽略 `somepath` 文件,但不忽略 `somepath/` 目录 somepath !somepath/ # 只忽略当前目录下的 `somepath` 文件和目录,但不忽略子目录的 `somepath` /somepath 说明: # 开头表示注释,! 紧跟某规则之后表示增加例外情况 在线示例和帮助文档 提供两个不错的在线示例,可以参考下在什么场景应该忽略哪些文件以及如何编写忽略规则. https://www.gitignore.io/ https://github.com/github/gitignore 运行 git help ignore 命令查看帮助文档 三种设置方式 git 设置忽略文件有三种方式,如下: 全局配置文件(~/.gitignore),执行 git config --global core.excludesfile ~/.gitignore 命令后适用于所有的版本库. 远程配置文件($PWD/.gitignore),编辑 .gitignore 文件后适用于远程和本地版本库. 本地配置文件($PWD/.git/info/exlude),编辑 $PWD/.git/info/exlude 文件后适用于本地版本库. 最常用方式 三种设置方式中,第二种最为常见,另外两种大致一样,重点在于配置文件如何编写. 创建 .gitignore 文件 参考在线示例以及基本语法编写自定义忽略规则 # General .DS_Store .AppleDouble .LSOverride # Windows thumbnail cache files Thumbs.db ehthumbs.db ehthumbs_vista.db 提交 .gitignore 文件 忽略文件规则配置完毕后,需要将该文件提交到版本库,这样在其他电脑上也能应用相同的忽略规则. # 添加 `.gitignore` git add .gitignore # 提交 `.gitignore` git commit -m \"add .gitignore\" # 上传 `.gitignore` git push origin master 验证忽略效果 新建 .gitignore 文件中已忽略的文件,运行 git status 命令,如果提示 working directory clean,那么说明忽略文件的配置已经生效,如果工作区不干净,很遗憾,忽略文件配置可能并未生效,需要检查下哪里配置错了. 运行 git check-ignore 命令检查是哪个配置规则写错了,从而我们能够更正相应的配置规则. © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"git/github/usage.html":{"url":"git/github/usage.html","title":"github 教程","keywords":"","body":"github 教程 github 是一个基于 git 的代码托管平台,是平时工作学习的好帮手,学会如何用好 github 网站能够帮助我们更好分享代码或者与其他开发人员合作. 注册 github 账号 首先准备好邮箱和密码,然后在 github 官网注册新账号,和大多数网站类似的注册流程,唯一注意的是你要想好注册类型,针对个人用户来说,一般无外乎个人账号和项目账号两种,比如 snowdreams1006 就认为是个人账号,而这种 security-plus 认为是项目账号. 其实这两种账号对于 github 来说是一样的,不像是个人账号同企业账号的差异那么大,那为什么称个人账号和项目账号呢? 是因为,大多数个人开发者名下会有多款开源作品,这些作品既可以全部挂载在某一个开发者账号下面,也可以单独挂载某一个开发者账号下面,如果此时的账号名恰好是项目名岂不是清晰多了? 因为个人刚开始可能并没多大名气,如果一个产品直接挂载在个人名下,那么这个产品很大程度上就依赖于个人名气了,所以不妨反过来,用产品说话,事实胜于雄辩,这种做法也是一种常用的宣传手段,很多个人开源产品正是这么做的! 除此之外项目账号还有一个好处,利用 github 的静态网站托管服务可以免费快速搭建项目官网,只要创建一个snowdreams1006.github.io 的项目,那么这个项目就可以作为静态网站的源码项目了,访问 https://snowdreams1006.github.io 就能看到项目官网了! 注意: snowdreams1006仅仅是笔者用户名,实际需要替换成读者的用户名 配置 github 既然项目已经托管到 github 网站,那本地如何访问到远程仓库呢?常用的方式有两种,一种是 https 方式,每次都需要输入密码,另外一种是 ssh 方式,只需要一次配置ssh 密钥对. 这里我们重点介绍最常用也是最方便的第二种 ssh 方式访问 github ,大致思路是本地生成密钥对,然后将公钥上传给 github 表明身份,之后本地再次推送给远程仓库时,github 自然就能识别到我们身份了. 第一步: 生成密钥对 默认情况下,会在当前用户目录下生成一对密钥对. ssh-keygen -t rsa -C \"youremail@example.com\" 这里的邮箱 youremail@example.com 需要填写自己的 github 邮箱,之后会提示输入路径和密码,一路回车采用默认值即可,运行结束后会在当前用户目录下 生成一对密钥对,包括公钥和私钥.其中公钥可以发送给任何人,而私钥千万不可泄露. 第二步: 复制公钥 在当前用户根目录下打开 .ssh 目录,其中包括两个文件,一个是公钥 id_rsa.pub ,另一个是私钥 id_rsa,用记事本或者其他方式打开公钥文件,复制其中内容,准备粘贴到github 相关设置项. # 查看当前用户下的 ssh 目录 ls ~/.ssh # 查看生成的公钥内容 cat ~/.ssh/id_rsa.pub 第三步: 设置 github 回到 github,点击头像(Acount),选择设置(Settings),再选择左侧的 SSH and GPG keys,点击右侧的NEW SSH Key,然后填写标题(Title),最好是有意义的名称,比如youremail@example.com for github,密钥(Key)填写上一边生成的公钥,一般是以ssh-rsa 开头的一大串字符,最后保存(Add SSH Key). 第四步: 验证 ssh 利用 ssh 协议测试一下是否能够正常访问 github 网站,如果出现成功提示,那就证明我们的配置没问题. ssh -T git@github.com 创建远程仓库 登录 github 网站新建远程仓库(New Repository),例如git-demo,默认权限是公开的(public),也可以选择私有的(private),初始化 README.md 文件和 .gitignore 文件以及选择开源协议这些都是可选的,视具体情况而定. 刷新当前页面,应该能到看到已创建好的git-demo 项目,接下来准备将其克隆到本地电脑. 克隆到本地仓库 将远程项目克隆到本地工作空间,和之前本地仓库的开发流程一样,例如add commit status 等等,唯一不同的是,多了一步 push 命令,即本地仓库的最新版本需要推送给远程仓库中,只有这样其他小伙伴才能从远程仓库拉取最新版本,进而才能看到你的代码,因而打破各自为政局面,实现团队协同开发. # 克隆到本地仓库 git clone git@github.com:snowdreams1006/git-demo.git # 切换到当前项目 cd git-demo # 创建新文件 touch test.txt echo \"add test.txt\" > test.txt # 添加文件到暂存区 git add test.txt # 提交文件到本地仓库 git commit -m \"add test.txt\" # 推送到远程仓库 git push origin master 提交完成后,登录 github 网站,刷新当前项目 git-demo ,应该能看到我们刚刚提交的新文件test.txt. 添加仓库关联 添加本地仓库和远程仓库之间关联,默认本地仓库分支名和远程仓库分支名相同 git remote add origin2 git@github.com:snowdreams1006/git-demo.git 查看远程仓库 查看当前配置有哪些远程仓库 git remote 执行时加上-v 参数能够查看别名关联的具体地址,即 git remote -v 下载远程仓库 从远程仓库下载最新分支数据 git fetch 注意: 该命令并不会自动合并当前分支,如需要合并,需手动执行git merge 命令 拉取远程仓库 从远程仓库拉取最新分支数据,自动尝试合并到当前分支,如有冲突,需先解决冲突再合并到当前分支. git pull git pull 相当于 git fetch + git merge 推送远程分支 将本地最新版本推送到远程仓库 git push origin master 以上命令将本地 master 分支推送到 origin 远程仓库的 master 分支 删除远程仓库 git remote rm origin © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"git/server/private.html":{"url":"git/server/private.html","title":"git 私服搭建教程","keywords":"","body":"git 私服搭建教程 前几节我们的远程仓库使用的是 github 网站,托管项目大多是公开的,如果不想让任何人都能看到就需要收费,而且 github 网站毕竟在国外,访问速度太慢,基于上述两点原因,我们有必要搭建自己的 git 服务器. 虽然我们能搭建基本的 git 服务器,但是想要做到 github 网站那种规模还不是目前能够探讨的,本节的主要目标是使用我们私有服务器对我提供类似于github的远程仓库托管服务,以下示例以centos 服务器为例说明: 安装 git 服务 运行以下命令安装 git 服务 # 安装 git 相关依赖 yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel # 安装 git yum install git # 查看 git 版本 git --version 详情请参考安装 git 配置 git 用户 创建 git 用户组和 git 用户,以便对外提供 git 服务 # 新增 git 用户组 groupadd git # 新增 git 用户并归属于 git 用户组 useradd git -g git # 禁用 git 用户登录 shell 编辑 /etc/passwd git:x:1001:1001:,,,:/home/git:/bin/bash 更改为 git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell 收集 git 公钥 回忆一下,在我们使用 github 网站时,我们是不是曾经将本地电脑生成的公钥~/.ssh/id_rsa.pub 复制到 Account -> Settings -> SSH and GPG keys -> New SSH key,而我们现在搭建的git 服务还是简单,但是这步骤必不可少,因此只能手动收集素有需要访问我们服务器的公钥文件. 我们知道需要登录我们服务器的用户公钥一般是存放在~/.ssh/id_rsa.pub ,那当前服务器作为远程服务器将这些公钥存放到哪里呢?还记得上一步我们创建了 git 用户吗? 因为 linux 系统支持多用户操作,而 git 用户就用于专门运行 git 服务,负责所有和 git 有关的事宜.因此,导入公钥文件的目录就是/home/git/.ssh/authorized_keys文件.一个用户公钥占用一行,几个用户就有几行. # 切换到 git 用户主目录 cd /home/git/ # 创建.ssh 目录 mkdir .ssh # 赋予标准目录权限 chmod 755 .ssh # 创建authorized_keys文件 touch .ssh/authorized_keys # 赋予标签文件权限 chmod 744 .ssh/authorized_keys 如果团队规模不大,那么上述方案完全可行,如果团队规模几百上千人,通过手动收集每个人的公钥再上传到服务器统一管理就有点力不从心了,这时候推荐 gitosis 决这一问题. 初始化 git 仓库 同样我们和github 网站类比,在 github 创建仓库时都会在当前账号下创建项目,完整的访问路径大概是这样的: git@github.com:snowdreams1006/git-demo.git,从中我们可以看出项目仓库都有一个前缀即命名空间,这和上一步操作是不是很类似,上一步收集 git 公钥时我们也有统一的目录,这次也不例外. 假设 git 仓库存放目录在 /home/git/repos/,同样的先创建该目录并赋予响应权限. # 切换到 git 用户主目录 cd /home/git/ # 创建 repos 目录 mkdir repos # 更改 repos 目录属主 chown git:git repos/ # 切换到 repos 目录 cd repos # 初始化 git 裸仓库 git init --bare git-demo.git # 更改 git-demo.git 仓库属主 chown -R git:git git-demo.git 这里搭建git服务器仅为了共享,不考虑用户直接登录该服务器上使用 git 将其作为工作区这一情况 经过上述操作,我们成功在远程服务器部署了 git 服务,并且创建了 git-demo 测试项目,实际访问路径大概是这样的 git@snowdreams1006.cn:/home/git/repos/git-demo.git 访问授权 总是存在一些公司不仅视源代码为生命,还视员工为窃贼,抑或是深受svn毒害,要求在版本控制系统中设置一套完善的权限控制体系,具体到每个账号对每个项目的每个目录是否有读写权限. 然而 git 天生并不支持权限控制,这一点和其出身有关,本来就是为了开源而生,并不关心所有人的提交. 不过这并不意味着 git 无法实现权限控制功能,因为 git 支持钩子函数(hook) ,所以在服务器端编写一系列的脚本控制提交行为,从而实现权限控制.详情请参考 gitolite 本地克隆远程仓库 身份回到本地电脑,假设本地已搭建好 git 环境,并且生成的ssh 公钥上传到远程服务器,那么我们接下来就可以和之前远程服务器是 github 网站那样的方式开发我们的项目了,唯一不同的是,接下来我们推送的远程服务器均是我们刚搭建好的主机. 需要做好心里准备,我们搭建的服务器还很简单,没有 github 网站那样可以直观操作远程仓库,但是这并不影响我们的 pull push merge 等操作哟! git clone git@snowdreams1006.cn:/home/git/repos/git-demo.git git-指的是 git 用户,snowdreams1006.cn-指的是远程主机域名或ip,/home/git/repos-指的是 git 仓库的目录,git-demo.git-指的是项目名称 现在我们已经成功搭建好自己的 git私服了,是不是很简单呢?有没有对 git 和 github 进一步理解?欢迎大家一起探讨! 小结 git 私服就是无 web 界面的简化版 github 小团队人工收集用户公钥,大团队使用 gitosis 实现类似 svn 那样的权限控制请使用 gitolite © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"git/tools/git-bash-command.html":{"url":"git/tools/git-bash-command.html","title":"git bash 常用命令","keywords":"","body":"git bash 常用命令 众所周知,现实世界和计算机世界是不同的,但是计算机作为人类对现实世界的抽象模拟,在一定程度上,具备了现实世界的基本特征,本文将以哲学角度对比分析现实世界和计算机世界,试图以浅显易懂的方式感受现实世界和计算机世界的联系. 首先请先回顾一下哲学的基本问题问题: 我是谁,我在哪以及我要干什么? 接下来我们逐步探讨下两个世界的关联,顺便学习下 Git Bash 支持的常用命令以及 git 的基本操作. 如果还没有安装 git 环境,请参考进行 https://snowdreams1006.github.io/git/base/install.html 或者参考千呼万唤始出来章节进行安装. 哲学第一问: 我是谁 现实生活中我们每个人都有名字,身份以及责任.正是由自我和他人一起构成了\"我是谁\"这一基本问题: 是儿子,是丈夫,是父亲,是社会中的一份子. 但是,在计算机世界中,我又是谁呢? 计算机世界是虚拟世界,有的只是冰冷冷的程序和数据,有限的人机交互才创造了\"我\",所以弄清楚\"我是谁\"的问题至关重要. whoami : who am i 的缩写,即打印出当前登录用户. 计算机世界中,\"我\"表现为一个账号,用户名是唯一标识.在这个世界上不止一个用户，同一台电脑支持多个账号. 所以,\"我\"是计算机的用户,哪天警察检查身份证时,需要自报家门,如果你都不知道你的名字那岂不是闹笑话了？ snowdreams1006@home MINGW64 ~ $ whoami snowdreams1006 哲学第二问: 我在哪 不论是武侠小说主角突然失忆还是被绑架桥段,第一句总是： \"我是谁？这是哪？\"或者\"你是谁？这是哪？\". 不仅现实世界人很多,计算机世界的用户也不止一个,目录更是数不胜数. 所以，我们第二个问题就要探讨一下\"我在哪\"的基本问题. echo ~ : echo 翻译为\"回声\",直接表现为输出某命令的执行结果,~ 代表用户的\"家\"目录,即输出家目录. 现实世界中我们每个人都有自己的家,计算机世界也不例外.每个用户都有自己的家目录 试想一下,如果没有心灵的港湾,灵魂和身体该如何安放?如果没有家目录,数据默认存放到哪里去？多个用户之间的数据怎么保证相对隔离？ snowdreams1006@home MINGW64 ~ $ echo ~ /c/Users/snowdreams1006 哲学第三问: 我要干什么 现实世界中,每个人出生后会慢慢长大,或一直留在家乡或外出闯荡,终其一生，生不带来，死不带去. 其中最直观表现为每个人基本上都要工作,从而维持生活,继而创造社会价值.不论是当地就业还是外出就业,我们上班的地点被称为工作地点. 家只有一个,工作地点却可以有多个,可以换工作换工作地点,但是永远只有一个家,是故乡,是出生地,是心灵的港湾. 如果这种场景反映到计算机世界,又是怎样一番场景呢? 既然和计算机打交道,不论什么交互方式,最终都无外乎输入输出两种形式.输入的是我们的投入,输出的是我们的产出. 输入输出的数据需要存储在计算机中,是以文件的形式有组织地保存起来,保存数据的目录就是工作目录,不是自己的家目录的其他目录都是我们的工作目录. 这样看起来,原来在计算机中换工作竟然这么容易,不是家目录的其他目录都是工作目录. 万丈高楼平地起: 创建目录 mkdir [OPTION] DIRECTORY : make directory 的缩写,即创建目录. 万丈高楼平地起,计算机人生刚刚起步,需要搭建好大厦的基础框架,然后再往里面一点一点加东西,终将变成摩天大厦！ 立下明确目标,坚定不移前往目的地,工作目录已创建,第一步已经迈出去,接下来准备前往新创建的工作目录,搭建好我们自己的高楼大厦. snowdreams1006@home MINGW64 ~ $ mkdir /g/workpace/git-bash-demo 飘洋过海来看你: 切换目录 cd [-L|[-P [-e]] [-@]] [dir] : change directory 的缩写,即切换目录. 既然选择了前方,便只顾风雨兼程.心中的大厦蓝图等待去实现,不论是从家目录出发还是工作目录出发,既然目标工作目录已经确定,接下来如何出发便不是太麻烦的事情了. 现实世界中出发到工作地点,可以坐高铁,坐轮船,坐飞机等多种交通方式任你挑选,在计算机世界中前往工作目录就很简单,只要明确知道工作目录,一条命令瞬间直达！ snowdreams1006@home MINGW64 ~ $ cd /g/workpace/git-bash-demo 惊鸿一瞥初相见: 打印目录 pwd [-LPW] : print working directory 的缩写,即打印工作目录. 初次来到新的工作地点,第一件事就是查看当前位置以便确认漂洋过海的经历没有白费。 非家目录的其他目录都是工作目录,确认工作目录是目标目录后就可以正式投入紧张有序的工作生活中了,准备好了吗？ snowdreams1006@home MINGW64 /g/workpace/git-bash-demo $ pwd /g/workpace/git-bash-demo 回头四顾心茫然: 列出文件 ls [OPTION] [FILE] : list file 的缩写,即列出文件. 刚刚进入新环境,本想查看一下周围环境和同事打个招呼,蓦然发现: 周围空无一人. 空荡荡的房子提醒着自己,万丈高楼平地起,创业道路孤独而艰辛！ snowdreams1006@home MINGW64 /g/workpace/git-bash-demo $ ls 保温杯中泡枸杞: 创建文件 touch [OPTION] [FILE] : 翻译为\"触摸\",有则改之无则新增,即如果文件已存在则更新权限和修改时间,否则新建文件. 身体是革命的本钱,即将开始废寝忘食的创业之旅,在高强度的工作来临之前,先检查一下保温杯在不在,在的话,洗一洗,不在的话,先去买一个再洗一洗. snowdreams1006@home MINGW64 /g/workpace/git-bash-demo $ touch cup.txt 枸杞茶中加枸杞: 覆盖输入 > : 覆盖输入,不论目标文件是否已有内容,新内容直接覆盖原文件内容. 保温杯中泡枸杞,第一步先往保温杯中加入枸杞,如果有其他东西先倾倒然后再加入枸杞,否则直接加入枸杞. snowdreams1006@home MINGW64 /g/workpace/git-bash-demo $ echo \"medlar\" > cup.txt echo \"medlar\" 即输出枸杞,> 是重定向操作,将上一步的输出结果当做下一步的输入参数,cup.txt 是保温杯,因此该组合命令表示将枸杞倒入保温杯. 枸杞茶中倒热水: 追加输入 >> : 追加输入,在原有文件内容后面追加新内容,新内容不会覆盖原文件内容. 保温杯中已有枸杞,第二步开始倒水准备泡枸杞茶,枸杞自然不能倾倒出去,不然就叫做白开水不能叫做枸杞茶了. snowdreams1006@home MINGW64 /g/workpace/git-bash-demo $ echo \"water\" >> cup.txt 枸杞茶要慢慢品: 查看文件 cat [OPTION] [FILE] : concatenate 的缩写,翻译为\"连接\",即查看文件内容. 枸杞只需一点点,温水适量,不多也不少才是最好,最好亲自品尝一下才能决定如何继续调整. 要看到文件的全部内容正如要看到枸杞茶整体一样,后续操作视观察结果而定. snowdreams1006@home MINGW64 /g/workpace/git-bash-demo $ cat cup.txt medlar water 枸杞茶要再调整： 追加并查看文件 枸杞差不多,浓度有点大,需要再加一点水,为了控制加入量,还要再品一下枸杞茶. # 追加文件内容 snowdreams1006@home MINGW64 /g/workpace/git-bash-demo $ echo \"more water\" >> cup.txt snowdreams1006@home MINGW64 /g/workpace/git-bash-demo # 查看文件内容 $ cat cup.txt medlar water more water 三更灯火五更鸡: 编辑文件 vim [OPTION] [FILE] : Vi IMproved 的缩写,vi = VIsual = Very Inconvenient 是命令行编辑工具,vim 即 vi 的增强版,编辑文件. 先设定整体目标,做好全局性计划,然后再是根据目标确定详细具体的工作安排. # 在命令行编辑器中编辑 goal.txt 文件,如果没有会自动创建. $ vim goal.txt 进入编辑器后的基本命令 i : insert 的缩写,翻译为\"插入\",即切换到编辑模式. esc : escape 的缩写，翻译为\"逃跑\",即切换到命令模式. :w ： write 的缩写,翻译为\"保存\",即保存文件内容. :q : quit 的缩写，翻译为\"退出\",即退出 vim 编辑器. :wq : write and quit 的缩写，翻译为\"保存并退出\",即保存并退出 vim 编辑器. :q! : quit force 的缩写,翻译为\"强制退出\",即不提示未保存强制退出. gg : 定位到文件开头. G ： 定位到文件结尾. yy : 复制整行. dd : 剪切整行. p : 粘贴. u : 撤销. ctrl + f : 下翻整页. ctrl + b : 上翻整页. ctrl + d : 下翻半页. ctrl + u : 上翻半页. / : 查找字符串 编辑后的目标,学习 markdown ,学习 git ,学习 gitbook ,分享 java 知识等等,目标远大,撸起袖子加油干吧！ snowdreams1006@home MINGW64 /g/workpace/git-bash-demo $ cat goal.txt ## learning markdown ## learning git ## learning gitbook ## sharing java8 撸起袖子加油干: 查看开头 head [OPTION] [FILE] : head 翻译为\"头\",即打印文件前十行内容. 我们立下的目标暂时只有四行,为了掩饰效果,临时录入更多无意义的计划,这部分并不属于我们的目标. echo \"万丈高楼平地起: 创建目录\" >> goal.txt echo \"飘洋过海来看你: 切换目录\" >> goal.txt echo \"惊鸿一瞥初相见: 打印目录\" >> goal.txt echo \"回头四顾心茫然: 列出文件\" >> goal.txt echo \"保温杯中泡枸杞: 创建文件\" >> goal.txt echo \"枸杞茶中加枸杞: 覆盖输入\" >> goal.txt echo \"枸杞茶中倒热水: 追加输入\" >> goal.txt echo \"枸杞茶要慢慢品: 查看文件\" >> goal.txt 现在 goal.txt 文件不止十行,而是十六行数据,足够我们演示效果. 在泡枸杞茶最后一步中,我们需要品茶以此确定枸杞和热水搭配是否合理,使用 cat 命令帮我们查看文件全部内容,如果我们不需要查看全部,只需要查看前十条的话,就需要另外的命令. snowdreams1006@home MINGW64 /g/workpace/git-bash-demo $ cat goal.txt ## learning markdown ## learning git ## learning gitbook ## sharing java8 万丈高楼平地起: 创建目录 飘洋过海来看你: 切换目录 惊鸿一瞥初相见: 打印目录 回头四顾心茫然: 列出文件 保温杯中泡枸杞: 创建文件 枸杞茶中加枸杞: 覆盖输入 枸杞茶中倒热水: 追加输入 枸杞茶要慢慢品: 查看文件 查看目标清单中的前十条记录,而不显示全部记录. snowdreams1006@home MINGW64 /g/workpace/git-bash-demo $ head goal.txt ## learning markdown ## learning git ## learning gitbook ## sharing java8 万丈高楼平地起: 创建目录 飘洋过海来看你: 切换目录 不思进取后十名: 查看结尾 tail [OPTION] [FILE] : tail 翻译为\"尾\",即打印文件后十行内容. 如果查看文件是目标文件 goal.txt 还好,目标再小也不应被歧视,如果是成绩文件或者绩效文件,难免会被比较,打上\"不思进取\"的标签. snowdreams1006@home MINGW64 /g/workpace/git-bash-demo $ tail goal.txt ## sharing java8 万丈高楼平地起: 创建目录 飘洋过海来看你: 切换目录 惊鸿一瞥初相见: 打印目录 回头四顾心茫然: 列出文件 保温杯中泡枸杞: 创建文件 枸杞茶中加枸杞: 覆盖输入 枸杞茶中倒热水: 追加输入 枸杞茶要慢慢品: 查看文件 优雅的写作体验: markdown markdown 是一种轻量型的文本标记语言,是无文本 txt 的增强版，是超文本 html 的精简版,是二进制 word 的替代版,带给你全新的写作体验. 刚刚立下的目标文件的第一条就是学习 markdown ,那什么是 mardown 以及我们为什么要学习 markdown 呢？ snowdreams1006@home MINGW64 /g/workpace/git-bash-demo # 前一条记录: -n 1，前五条记录: -n 5 $ head -n 1 goal.txt ## learning markdown 如果你的文章需要手动同步发表到各大网络平台,用书写 word 那种体验虽然直观,但是缺点是需要记住各平台布局按钮摆放位置,想要达到一致的输出效果,每个平台都需要手动调整以确保最终效果一致性. 如果使用 markdown 体验来书写文字则完全不会有这种问题,提前定义好的文件格式并不依赖平台,你可以一处编写,随心所欲到处复制粘贴! 既然 markdown 这么神奇,这种优雅的写作方式到底是什么呢?学起来真的一点都不费事! markdown 是一种标记语言,常用于书写文章,小巧轻量,不必记住令人眼花缭乱的按钮摆放位置,也不像记事本那种毫无格式,只需记住有限几个特殊字符就能输出漂亮美观的文件效果！ 比如当前文章的书写格式就是 markdown 进行编写,整体效果还不错,这样看起来 markdown 是不是很强大呢? 和其他文本文档一样, markdown 文件也有自己的后缀名 .md,比如该文章的文件名 git-bash-command.md. 现在你是不是迫不及待想要学习 markdown 了呢? 别急,学习需要规划,我们再专门新建目录用于存放 markdown 学习笔记. snowdreams1006@home MINGW64 /g/workpace/git-bash-demo # 创建目录: 参考\"万丈高楼平地起\"章节 $ mkdir markdown snowdreams1006@home MINGW64 /g/workpace/git-bash-demo # 列出文件: 参考\"回头四顾心茫然\"章节 $ ls cup.txt goal.txt markdown/ snowdreams1006@home MINGW64 /g/workpace/git-bash-demo # 切换目录: 参考\"飘洋过海来看你\"章节 $ cd markdown snowdreams1006@home MINGW64 /g/workpace/git-bash-demo/markdown # 打印目录: 参考\"惊鸿一瞥初相见\"章节 $ pwd /g/workpace/git-bash-demo/markdown 现在让我们先学习下 markdown 中标题和列表如何书写,想要了解更多请参考我专门介绍 makdown 的系列文章. 标题 语法格式: # + 空格 + 文本 ,# 表示一级标题,## 表示二级标题,### 表示三级标题,以此类推,最多支持六级标题. 示例: # 标题1 ## 标题2 有序列表 语法格式：数字 + . + 空格 + 文本 示例: 1. 有序列表1 2. 有序列表2 3. 有序列表3 无序列表 语法格式：'- 或 * 或 +' + 空格 + 文本 示例: - 无序列表1 * 无序列表2 + 无序列表3 哇塞,原来 markdown 语言竟然如何简洁,妈妈再也不用担心我记不住复杂的布局按钮了！ 笔记时间到,赶紧将上述知识点整理到 markdown 目录下,创建 markdown.md 文件用于记录刚才的学习笔记. snowdreams1006@home MINGW64 /g/workpace/git-bash-demo/markdown # 编辑文件: 参考\"三更灯火五更鸡\"章节 $ vim markdown.md snowdreams1006@home MINGW64 /g/workpace/git-bash-demo/markdown # 查看文件: 参考\"枸杞茶要慢慢品\"章节 $ cat markdown.md 先学习下 `markdown` 中标题和列表如何书写,想要了解更多请参考我专门介绍 `makdown` 的[系列文章](https://snowdreams1006.github.io/markdown/). ... 恪尽职责的网盘: git 经过上述内容引导发现 markdown 语法确实在某些场景下很好用,于是乎下定决心开始踏上学习 markdown 之旅. 工欲善其事必先利其器,本着小白初体验心态,还是先安装一个可视化的编辑器吧! 实际上,markdown 很常用,主流编辑器基本都有相应插件,比如 idea,vs code 和 sublime等. typora 编辑器,支持多平台, windows ,mac 和 linux,别具一格的首页. 安装没有特殊的注意事项,正常安装就可以了,安装完毕后可以选择打开已有 markdown 文件. 实时渲染,所见即所得,左侧是文件列表,右侧是内容编辑器,喜欢的话赶紧入手吧! 装备好编辑器后,我们接着继续学习 markdown 的基本知识,介绍下如何显示图片以及超链接。 链接 语法格式：[显示文本] + (链接地址) 示例: [https://snowdreams1006.github.io](https://snowdreams1006.github.io/) 图片 语法格式：! + [图片标题] + (图片地址) 示例: ![雪之梦技术驿站的头像](https://upload.jianshu.io/users/upload_avatars/16648241/57aebe62-b5b5-491a-a9fd-f994d5be7dda.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/240/h/240) 点滴积累也是进步,记得要把这次的学习笔记保存到我们之前的 markdown.md 文件中哟！ 正所谓\"温故而知新可以为师矣\",笔记不仅要写还要经常看,于是在刚刚的笔记上做些修改添加自己的理解. 果然是一次愉快的学习体验,真的是活学活用啊,孺子可教也！ 隔壁小伙伴听说你最近在学 markdown ，想借你老师留下的笔记看看,于是你好心找一下课堂笔记打算发给他. 等一等,对方需要的是课件资料并不包含你自己理解那部分笔记哟,怎么办? 那就以当前笔记为基础再复制一份笔记,然后删掉自己理解的那部分笔记呗！ 请给我拷贝课件: 复制文件 cp [OPTION] [-T] SOURCE DEST : copy 的缩写,即复制文件. 既然对方明确要求课件而不是自己的笔记,那把自己的那部分内容手动清除掉呗! 整理好课件后发给了小伙伴,虽然辛苦点但是帮助别人快乐自己,谁让我们一直接受的教育就是助人为乐呢？ 经过一阵子的学习了解到更多 markdown 知识,于是课件加上自己的笔记越来越多,小白已经渐渐远去,大神正在向我们招手... 省心尽责的网盘: 版本控制系统 上次帮助了隔壁的小伙伴,一传十十传百,又有其他小伙伴求课件了,听说认真好学的你还做了笔记,也有人要笔记,事情有点复杂啊. 有的人需要课件,有的人需要笔记,已领取资料的人还想要后续更新能及时通知到他们? 如果仍然采用复制粘贴修改的方式,可想而知是多么麻烦,源文件复制一份给张三,再复制一份给李四并且还要去掉自己笔记部分,给王二的文件比较老还有再弄一份新的给他... 如果不考虑文件的差异性需求,可以将文件上传到网盘中再分享给需要的小伙伴,明显这种网盘并不能解决目前问题. 因为网盘的文件是源文件的最新备份,不能满足文件差异性的需求也无法管理文件历史状态. 万一哪次整理课件时需要删除笔记部分时,一不小心忘记备份源文件,课堂笔记就这么丢失了很难再找回来了! 所以,如果有这么一种工具能够事无巨细帮我们记录文件状态,还能有网盘管理并分享的功能就能解决我们的痛点了,这样恪尽职责的网盘谁能不喜欢? 事实上,这种工具确实存在而且不仅一种！ 专业术语叫做版本控制系统,其中分为集中式版本控制系统和分布式控制系统,区别在于鸡蛋是否在一个篮子中. 如果鸡蛋都在一个篮子中,母鸡无论在何处下蛋,鸡蛋最终都会被收集都一个篮子中,想要吃鸡蛋时再去这个篮子里拿,这就叫做集中式版本控制系统. 如果鸡蛋不在同一个篮子中,母鸡下的鸡蛋被收集到附近的篮子中,需要吃鸡蛋时再从最近的篮子中去拿,这种情况就叫做分布式版本控制系统. 集中式的特点在于集中管理统一调度,而分布式的特点在于分开管理灵活高效,实际情况中选择哪一个需要具体情况具体分析. 当然,我们现在讲解的只是其中之一,那就是分布式版本控制系统. 千呼万唤始出来: git 说到分布式版本控制系统,不得不提的就是 git --- 最先进最流行的分布式版本控制系统. git 是分布式版本控制系统家族的璀璨明星,免费开源,支持 windows ,mac 以及 linux 等平台. 下面以 windows 电脑为例,介绍下 git 的安装和使用. 官网下载地址: https://git-scm.com/download/win 正常的话,按照默认选择安装即可,请确保 Git Bash Here 前面的复选框已勾选,否则无法提供命令行终端. 接下来一切按照默认选项安装,安装模拟终端类型时请选择第一种 Mintty 以保证环境一致性. 安装成功后桌面或者右键会出现 Git Bash 图标或选项,打开终端,输入 git --version如果能正常输出版本信息,那就说明安装成功了! 现在我们又不经意间学习了 git ,这不刚好是我们的第二个目标? 纳尼,你说目标是啥?竟然忘记了最初的目标. snowdreams1006@home MINGW64 /g/workpace/git-bash-demo/markdown $ ls courseware.md markdown.md snowdreams1006@home MINGW64 /g/workpace/git-bash-demo/markdown $ cd ../ snowdreams1006@home MINGW64 /g/workpace/git-bash-demo $ ls cup.txt goal.txt markdown/ snowdreams1006@home MINGW64 /g/workpace/git-bash-demo $ head goal.txt ## learning markdown ## learning git ## learning gitbook ## sharing java8 万丈高楼平地起: 创建目录 飘洋过海来看你: 切换目录 关于学习 markdown 的目标已经完成,学以致用不如动手改造下目标文件 goal.txt 重命名 goal.md . 改头换面化个妆: 移动文件 mv [OPTION] [-T] SOURCE DEST : move file 的缩写,即移动文件. 正常来说换工作一般会工作地点,当然升职这种换工作但工作地点可能并没有改变,反映到计算机世界中,移动文件本是更改工作目录,如果工作目录没有改变,只是修改个后缀名也未尝不可. $ ls cup.txt goal.txt markdown/ snowdreams1006@home MINGW64 /g/workpace/git-bash-demo $ mv goal.txt goal.md snowdreams1006@home MINGW64 /g/workpace/git-bash-demo $ ls cup.txt goal.md markdown/ snowdreams1006@home MINGW64 /g/workpace/git-bash-demo $ cat goal.md ## learning markdown ## learning git ## learning gitbook ## sharing java8 万丈高楼平地起: 创建目录 飘洋过海来看你: 切换目录 惊鸿一瞥初相见: 打印目录 回头四顾心茫然: 列出文件 保温杯中泡枸杞: 创建文件 枸杞茶中加枸杞: 覆盖输入 枸杞茶中倒热水: 追加输入 枸杞茶要慢慢品: 查看文件 版本控制我来了: 初始化 git init : 即初始化本地项目. 如何将文件放到网盘管理,正如如何将鸡蛋放到篮子中,首先要有篮子,这里我们将 git-bash-demo 父目录充当我们的篮子. 正式使用 git 打造本地网盘前,我们还需要设置下用户名和邮箱,这一步相当于自报家门,这样 git 才知道现在是谁在用. 还记得我是谁吗? whoami 就是你在计算机中的用户名,这里的 git 用户名可以使自定义的用户名. $ git config --global user.name \"your username\" $ git config --global user.email \"example@example.com\" 现在运行 git init 命令,开始打造本地网盘,开启版本控制之旅! snowdreams1006@home MINGW64 /g/workpace/git-bash-demo $ pwd /g/workpace/git-bash-demo snowdreams1006@home MINGW64 /g/workpace/git-bash-demo $ git init Initialized empty Git repository in G:/workpace/git-bash-demo/.git/ 好记性不如烂笔头,像我们学习 markdown 那样,我们也创建专门的目录用于存放 git 笔记. snowdreams1006@home MINGW64 /g/workpace/git-bash-demo (master) $ ls cup.txt goal.md markdown/ snowdreams1006@home MINGW64 /g/workpace/git-bash-demo (master) $ mkdir git snowdreams1006@home MINGW64 /g/workpace/git-bash-demo (master) $ ls cup.txt git/ goal.md markdown/ snowdreams1006@home MINGW64 /g/workpace/git-bash-demo (master) $ cd git snowdreams1006@home MINGW64 /g/workpace/git-bash-demo/git (master) $ ls snowdreams1006@home MINGW64 /g/workpace/git-bash-demo/git (master) $ touch git.md snowdreams1006@home MINGW64 /g/workpace/git-bash-demo/git (master) $ ls git.md snowdreams1006@home MINGW64 /g/workpace/git-bash-demo/git (master) $ echo \"first step : git init\" > git.md snowdreams1006@home MINGW64 /g/workpace/git-bash-demo/git (master) $ cat git.md first step : git init 知己知彼看状态: 查看状态 git status : 即查看文件状态 正所谓\"知己知彼方能百战不殆\",随时了解文件状态才能做到心中有数,从而更好地进行版本管理. 所谓\"版本\",可以理解为现实世界中的不同时空那一刻的\"状态\",文件的版本则是记录了文件的历史状态. git status 命令告诉我们文件状态以及能够智能猜预测我们下一步操作,好比身边的小秘书一样. snowdreams1006@home MINGW64 /g/workpace/git-bash-demo/git (master) $ git status # 在 `master` 分支上,暂时不用理解分支概念,默认处于该分支 On branch master # 目前还没有提交,`commit` 翻译\"提交\",即\"版本\",表示文件的不同历史时刻下的当时的状态 No commits yet # 未被追踪的文件: 好比文件上传到网盘一样,`git init` 创建本地网盘,但还没添加文件到网盘中. Untracked files: # (使用 `git add ` 来包含将要被添加的文件: 智能预测提示我们下一步应该添加下述文件) (use \"git add ...\" to include in what will be committed) ../.swp ../cup.txt ./ ../goal.md ../markdown/ # 没有已添加文件需要提交,但是目前有未被追踪文件(使用 `git add` 去追踪文件变化): 再次提示我们运行 `git add` 命令追踪文件. nothing added to commit but untracked files present (use \"git add\" to track) 整装待命入队列: 添加文件 git add ： 即添加文件,表示跟踪文件变化,即将加入版本控制系统. 如果将文件上传到网盘中,首先需要确定好需要上传的文件列表,然后才是上传文件的具体操作. git add 做的就是挑选出需要上传文件的清单列表,追踪到这些文件的变化以便下一步一次性全部上传! $ git add ../cup.txt ./ ../goal.md ../markdown/ warning: LF will be replaced by CRLF in cup.txt. The file will have its original line endings in your working directory warning: LF will be replaced by CRLF in git/git.md. The file will have its original line endings in your working directory warning: LF will be replaced by CRLF in goal.md. The file will have its original line endings in your working directory warning: LF will be replaced by CRLF in markdown/courseware.md. The file will have its original line endings in your working directory warning: LF will be replaced by CRLF in markdown/markdown.md. The file will have its original line endings in your working directory 在命令行操作中的基本哲学理念是\"没有消息就是好消息\",输入命令没有任何反馈的话,操作一般都成功了,如果操作失败都会有报错提示的. 虽然我们是在 windows 电脑上演示命令行操作,但命令行的逻辑不像 windows 可视化操作那样,新建文件会提示新建成功,移动文件也会提示移动成功,而命令行逻辑确实 linux 系统那一套逻辑. 没有消息就是好消息,在命令行交互的过程中可能没有那么多操作反馈,因而要求我们熟知命令作用,清楚明白自己在干什么! 既然 git add 没有消息反馈就说明我们操作成功了,下一步我们应该运行什么命令才能将这些目标问价添加到网盘呢? 外事不决问谷歌,内事不决问百度,而我们却有一个智能小秘书---git status ,大多数情况下提供了足够多的信息告诉我们下一步操作. 又见智能小秘书: 查看文件状态 刚刚我们运行 git add 命令添加了一些目标文件,故意留下了 ../.swp 文件,这种名字一看就算不是我们主动创建的文件,八成是系统或者编辑器什么的自动创建的,因而我们不需要备份这文件. 此时运行 git status 命令告诉我们目标文件已添加但还没提交,此时可以撤销(unstage)到未添加状态,还有一个文件未被追踪提示我们可以使用 git add 添加到待提交文件列表中. 目前为止,文件经历了两个阶段,最初尚未被追踪状态,使用 git add 命令添加文件转变成已追踪状态,此时再次运行 git status 提示我们已追踪到文件变化还未被提交,因此我们可以预测有一种命令能够提交文件,但是这个命令是谁呢? $ git status # 仍然处于 `master` 主干分支 On branch master # 目前仍然没有提交(版本) No commits yet # 即将要被提交的更改: `Changes` 翻译为更改，`committed` 翻译为被提交,即文件的更改将要被提交,提示我们下一步操作是提交文件 Changes to be committed: # (使用 `git rm --cached ` 来清空缓存: 注意 `unstage` 并不是 `commit` ，所以并不是提交操作而是撤销操作,即下述文件既可以进行下一步提交也可以回到上一步撤销文件.) (use \"git rm --cached ...\" to unstage) new file: ../cup.txt new file: git.md new file: ../goal.md new file: ../markdown/courseware.md new file: ../markdown/markdown.md # 未被追踪的文件列表: 使用 `git add ...` 添加文件 Untracked files: (use \"git add ...\" to include in what will be committed) ../.swp snowdreams1006@home MINGW64 /g/workpace/git-bash-demo/git (master) 不想见就删了吧: 删除文件 rm [OPTION] [FILE] : remove 翻译为\"删除\",即删除问价. 上一步中运行 git add 后再次运行 git status 命令没有提示我们如何进行提交文件操作,只告诉我们 git rm --cached 来撤销已被追踪的文件,可能是由于还有文件 ../.swp 文件没有被追踪,所以小助手猜想我们可能还没操作完毕,故而没有告诉我们如何提交? 不想见它就删了吧,通过命令行命令删除这个令人讨厌的家伙,看看会发生什么事情. $ rm ../.swp 依然没有消息反馈,应该删除成功了吧,看一下该文件还在不在以及当前文件的状态如何. snowdreams1006@home MINGW64 /g/workpace/git-bash-demo/git (master) $ ls git.md snowdreams1006@home MINGW64 /g/workpace/git-bash-demo/git (master) $ git status On branch master No commits yet Changes to be committed: (use \"git rm --cached ...\" to unstage) new file: ../cup.txt new file: git.md new file: ../goal.md new file: ../markdown/courseware.md new file: ../markdown/markdown.md 好吧,依然没有告诉我们提交文件的命令,只有只能亲自动手直接告诉你，这个命令就是 git commit ,估计你也猜个八九不离十,毕竟 commit 出现频率如此之高! 兢兢业业上班中: 提交文件 git commit : 即提交文件,将已跟踪的文件清单变化全部提交到版本库. git add 命令帮助我们打包好待上传文件,git commit 命令则执行上传操作,现在文件已经加入本地网盘了,妈妈再也不用担心文件丢失了呢! # 提交文件并添加备注信息,其中 `-m` 是 `-message` 的缩写,表示备注信息 $ git commit -m \"init git-bash-demo\" [master (root-commit) 128d0d0] init git-bash-demo 4 files changed, 59 insertions(+) create mode 100644 cup.txt create mode 100644 git/git.md create mode 100644 goal.txt create mode 100644 markdown/markdown.md 现在已经提交了文件,我们再次请来小秘书查看一下当前文件状态. $ git status On branch master # 没有什么文件需要提交,工作区很干净. nothing to commit, working tree clean working tree clean 告诉我们现在工作区很干净,这里的工作区可以简单理解为当前所处的工作目录. 告诉我你的历史: 提交历史 git log : 即查看提交历史,每一次的提交都能记得清清楚楚,不然怎么配得上兢兢业业上班中的标题. 每一次的提交都是一个版本,一段时间后提交历史会越来越多,查看提交历史时想要知道当初提交的基本信息就要看上一步 git commit -m 提供的备注信息. $ git log # 版本号: `128d0d0367096c41a6716ff30b4aec5876239343`,每一次提交都会产生唯一的版本号,作为提交记录的标识. commit 128d0d0367096c41a6716ff30b4aec5876239343 (HEAD -> master) # 提交作者的信息,`snowdreams1006` 是用户名,`snowdreams1006@163.com` 是邮箱,是安装 `git` 后配置的信息. Author: snowdreams1006 Date: Tue Apr 30 09:44:39 2019 +0800 # 提交备注: `init git-bash-demo` init git-bash-demo 命令太多记不住: 操作历史 git reflog : reflog 翻译为\"回流\",即翻阅命令. 版本号默认是一串无意义的字符串,主要用于定位确定唯一提交版本,所以查找指定版本号时可以缩短只要能找到版本号就可以. 正如下面的 128d0d0 代表的版本号就是 128d0d0367096c41a6716ff30b4aec5876239343. HEAD@{0} 作为高级用法时很重要,简单基础的命令并不会用到,作为扩展知识点了解即可. $ git reflog # `128d0d0` 是 `128d0d0367096c41a6716ff30b4aec5876239343` 的前7位,理论上能唯一定位到某个提交版本就好,所以可以缩短版本号. 128d0d0 (HEAD -> master) HEAD@{0}: commit (initial): init git-bash-demo 现在我们回忆一下 git 的基本流程,文件是如何上传到本地网盘? git init 初始化项目,创建本地网盘. git add 添加文件,挑选出待上传到网盘的文件,准备上传. git commit 提交文件,将已目标文件上传到网盘进行备份. git status 查看文件状态,本地网盘创建完毕后随时随地呼唤小秘书查看文件状态. git log 查看提交历史,同一个文件运行多次上传,每一次的文件都能识别,总览上传记录. git reflog 查看回流历史,存储重要操作命令结果,高级进阶必备知识点. 重要知识点我都帮你总结好了,还不拿出小本本赶紧记下来? $ echo \"git 的基本流程\" > git.md $ echo \"1. `git init` 初始化项目,创建本地网盘.\" >> git.md $ echo \"2. `git add` 添加文件,挑选出待上传到网盘的文件,准备上传.\" >> git.md $ echo \"3. `git commit` 提交文件,将已目标文件上传到网盘进行备份.\" >> git.md $ echo \"4. `git status` 查看文件状态,本地网盘创建完毕后随时随地呼唤小秘书查看文件状态.\" >> git.md $ echo \"5. `git log` 查看提交历史,同一个文件运行多次上传,每一次的文件都能识别,总览上传记录.\" >> git.md $ echo \"6. `git reflog` 查看回流历史,存储重要操作命令结果,高级进阶必备知识点.\" >> git.md 小笔记已经保存,现在开始将文件保存到网盘中,再次体验下 git 的工作流程,准备好了吗? Administrator@snowdreams1006 MINGW64 /f/workspace/git-bash-demo/git (master) # 列出当前文件: 当前工作目录位于 `git` 目录,存在学习笔记 `git.md`. $ ls git.md Administrator@snowdreams1006 MINGW64 /f/workspace/git-bash-demo/git (master) # 查看文件状态: 学习笔记 `git.md` 尚未被追踪,提示我们可以使用 `git add` 命令添加进来. $ git status On branch master No commits yet Untracked files: (use \"git add ...\" to include in what will be committed) git.md nothing added to commit but untracked files present (use \"git add\" to track) Administrator@snowdreams1006 MINGW64 /f/workspace/git-bash-demo/git (master) # 添加文件: 将学习笔记 `git.md` 添加到追踪文件清单. $ git add git.md warning: LF will be replaced by CRLF in git.md. The file will have its original line endings in your working directory Administrator@snowdreams1006 MINGW64 /f/workspace/git-bash-demo/git (master) # 再次查看文件状态: 此时学习笔记 `git.md` 已添加到跟踪文件清单,显示这是一个新文件,如需提交可运行 `git commit` 提交到本地仓库. $ git status On branch master No commits yet Changes to be committed: (use \"git rm --cached ...\" to unstage) new file: git.md Administrator@snowdreams1006 MINGW64 /f/workspace/git-bash-demo/git (master) # 提交文件: 将跟踪文件清单的更改全部提交到本地仓库,此时跟踪清单只有我们的学习笔记 `git.md` ,所以显示只有一个文件被改变. $ git commit -m \"add git learn note\" [master (root-commit) 08cbe61] add git learn note 1 file changed, 9 insertions(+) create mode 100644 git.md Administrator@snowdreams1006 MINGW64 /f/workspace/git-bash-demo/git (master) # 再次查看文件状态: 文件已经全部提交到本地版本库,相当于网盘已经有最新文件了. $ git status On branch master nothing to commit, working tree clean 一次新增文件之旅就这么轻松愉快,赶紧记到笔记鼓励下自己吧! Administrator@snowdreams1006 MINGW64 /f/workspace/git-bash-demo/git (master) $ echo \"git is so easy\" >> git.md Administrator@snowdreams1006 MINGW64 /f/workspace/git-bash-demo/git (master) $ cat git.md git 的基本流程 1. `git init` 初始化项目,创建本地网盘. 2. `git add` 添加文件,挑选出待上传到网盘的文件,准备上传. 3. `git commit` 提交文件,将已目标文件上传到网盘进行备份. 4. `git status` 查看文件状态,本地网盘创建完毕后随时随地呼唤小秘书查看文件状态. 5. `git log` 查看提交历史,同一个文件运行多次上传,每一次的文件都能识别,总览上传记录. 6. `git reflog` 查看回流历史,存储重要操作命令结果,高级进阶必备知识点. git is so easy 每一次文件内容发生重大更改时都应该被记录以便后续查看当时文件状态,那现在也提交到本地仓库吧! Administrator@snowdreams1006 MINGW64 /f/workspace/git-bash-demo/git (master) # 查看文件状态: 和以往不同的是,这次小助手给我们提供了两个建议,`git add` 和 `git checkout` ,其中 `git add` 是更新将要提交文件的内容,而 `git checkout` 则是丢弃本次更改内容. $ git status On branch master Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: git.md no changes added to commit (use \"git add\" and/or \"git commit -a\") Administrator@snowdreams1006 MINGW64 /f/workspace/git-bash-demo/git (master) # 添加文件: 按照上一步提示,我们希望的是准备提交文件,因此运行 `git add` 命令进行添加文件. $ git add git.md warning: LF will be replaced by CRLF in git.md. The file will have its original line endings in your working directory Administrator@snowdreams1006 MINGW64 /f/workspace/git-bash-demo/git (master) # 提交文件: 和往常一样,每一次的提交都要有提交备注,方便查看提交历史时提醒自己文件内容. $ git commit -m \"git is so easy\" [master 0b0657b] git is so easy 1 file changed, 1 insertion(+) Administrator@snowdreams1006 MINGW64 /f/workspace/git-bash-demo/git (master) # 再次查看文件状态: 正如我们所料,小助手告诉我们工作区是干净的,这表示目标文件都已添加到版本库中,接下来让恪尽职责的 `git` 帮我们管理文件吧. $ git status On branch master nothing to commit, working tree clean Administrator@snowdreams1006 MINGW64 /f/workspace/git-bash-demo/git (master) # 查看提交历史: 提交历史按照时间倒排顺序依次显示,最新的提交历史在终端的上面,有我们的提交备注等信息. $ git log commit 0b0657b7db02f1f5c6e8d5ac3f1307156c15ce08 (HEAD -> master) Author: snowdreams1006 Date: Tue Apr 30 11:55:07 2019 +0800 git is so easy commit 08cbe61c2a635ec6f70ae7a50842ae308cd95fee Author: snowdreams1006 Date: Tue Apr 30 11:16:19 2019 +0800 add git learn note 目前为止,这种操作好像和普通的网盘没有什么不同,选择文件,添加文件,那我为什么要使用 git 呢? 开启时间穿梭机: 版本控制 git checkout : 即检出文件,切换到指定版本状态. 假如你正在学习 git 知识,认真跟着教程边练习边做笔记,学着学着犯困了趴在电脑上睡着了,于是笔记变成了下面这样了. $ cat git.md git 的基本流程 1. `git init` 初始化项目,创建本地网盘. 2. `git add` 添加文件,挑选出待上传到网盘的文件,准备上传. 3. `git commit` 提交文件,将已目标文件上传到网盘进行备份. 4. `git status` 查看文件状态,本地网盘创建完毕后随时随地呼唤小秘书查看文件状态. 5. `git log` 查看提交历史,同一个文件运行多次上传,每一次的文件都能识别,总览上传记录. 6. `git reflog` 查看回流历史,存储重要操作命令结果,高级进阶必备知识点. git is so easy lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll ,pasdad,;qwd;lq\\we1233333333333333333333333333333333333,;qwe qwewewewewewewewewewewewewewewewewewewewewewewewewewewewe 很显然,下面的内容绝对是无意之举,碰到键盘乱按的,这时候怎么删除无意义的文字呢? 当然你可以选择手动删除,当然是一种方法但不是优雅的方法,下面介绍下 git 对这种情况的解决方案. 还记得我们的小助手吗,有事没事问问它能给我们什么意见就对了,git status 闪亮登场! $ git status On branch master Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: git.md no changes added to commit (use \"git add\" and/or \"git commit -a\") 工作目录的文件发生修改后,如果是正确的修改那我们运行的都是 git add 命令,假如是意外内容的话(比如这次瞌睡打盹产生的乱码),肯定就不能采纳第一种建议了. 第二种建议说使用 git checkout -- 来丢弃工作目录的更改,不妨试一下会发生什么吧! Administrator@snowdreams1006 MINGW64 /f/workspace/git-bash-demo/git (master) # 丢弃工作区更改: 恢复到最近一次版本管理状态 $ git checkout -- git.md Administrator@snowdreams1006 MINGW64 /f/workspace/git-bash-demo/git (master) # 查看文件状态: 工作区是干净的,就像我们执行完 `git commit`命令一样. $ git status On branch master nothing to commit, working tree clean Administrator@snowdreams1006 MINGW64 /f/workspace/git-bash-demo/git (master) # 查看文件内容: 神奇回到了上次文件状态 $ cat git.md git 的基本流程 1. `git init` 初始化项目,创建本地网盘. 2. `git add` 添加文件,挑选出待上传到网盘的文件,准备上传. 3. `git commit` 提交文件,将已目标文件上传到网盘进行备份. 4. `git status` 查看文件状态,本地网盘创建完毕后随时随地呼唤小秘书查看文件状态. 5. `git log` 查看提交历史,同一个文件运行多次上传,每一次的文件都能识别,总览上传记录. 6. `git reflog` 查看回流历史,存储重要操作命令结果,高级进阶必备知识点. git is so easy 仅仅需要 git checkout -- 一条命令就能轻松撤销文件更改,so easy! 穿越到过去看看: 回到过去 git reset --hard : 即重置到某个版本. 正如之前不经意间提到的版本概念,每一次提交文件都会产生一长串无意义的字符串,那个字符串就是版本号. git 实现的网盘功能可不是百度云网盘,普通的网盘只能保存最新文件,相同名称的文件不允许再次上传会被自动替换或者重命名. 然而,git 却可以多次保存文件,比如我们的学习笔记 git.md 就不止保存过一次,现在看一下该文件的提交历史吧! Administrator@snowdreams1006 MINGW64 /f/workspace/git-bash-demo/git (master) $ git log # 第二次提交记录: 当时写下了git is so easy commit 0b0657b7db02f1f5c6e8d5ac3f1307156c15ce08 (HEAD -> master) Author: snowdreams1006 Date: Tue Apr 30 11:55:07 2019 +0800 git is so easy # 第一次提交记录: 当时记录了git 的学习笔记 commit 08cbe61c2a635ec6f70ae7a50842ae308cd95fee Author: snowdreams1006 Date: Tue Apr 30 11:16:19 2019 +0800 add git learn note 你可能会问了,记录了这么多版本历史有什么用呢? 用处可大了,比如我们可以穿越到第一次提交记录的那一刻去,感受怀念一下旧时光. # 重置版本: 穿越到第一次的版本号,`08cbe61c2a635ec6f70ae7a50842ae308cd95fee` 即 `git log` 告诉我们的版本号. $ git reset --hard 08cbe61c2a635ec6f70ae7a50842ae308cd95fee HEAD is now at 08cbe61 add git learn note 发生什么了,我是谁,我在哪?现在是2019年还是公元220年? 小助手你在哪,快帮我看看现在是什么状态. # 查看文件状态: 报告老板,工作区很干净,没有发生文件更改哟! $ git status On branch master nothing to commit, working tree clean 小助手也没有给我满意的回复,自己动手丰衣足食,我还是自己看看周围有什么人吧! Administrator@snowdreams1006 MINGW64 /f/workspace/git-bash-demo/git (master) # 查看当前目录下文件: 原来我还在 `git` 目录下,这里还有我的学习笔记 `git.md` 呢! $ ls git.md Administrator@snowdreams1006 MINGW64 /f/workspace/git-bash-demo/git (master) # 查看文件内容: 我的笔记内容不是最新的了,原来的\"git is so easy\"不见了,我竟然真的回到了过去! $ cat git.md git 的基本流程 1. `git init` 初始化项目,创建本地网盘. 2. `git add` 添加文件,挑选出待上传到网盘的文件,准备上传. 3. `git commit` 提交文件,将已目标文件上传到网盘进行备份. 4. `git status` 查看文件状态,本地网盘创建完毕后随时随地呼唤小秘书查看文件状态. 5. `git log` 查看提交历史,同一个文件运行多次上传,每一次的文件都能识别,总览上传记录. 6. `git reflog` 查看回流历史,存储重要操作命令结果,高级进阶必备知识点. 抱着四处逛逛的心态,看一下当初的风景,逛累了回去吧! 怎么来的就怎么回去,原路返回一直是最保险的,自信心爆棚的说: 要先查看一下版本号,然后运行git reset --hard 穿越回未来! # 查看提交历史: 心态崩了,放声大哭:现在的我看不到未来的版本号,那我如何穿越啊... $ git log commit 08cbe61c2a635ec6f70ae7a50842ae308cd95fee (HEAD -> master) Author: snowdreams1006 Date: Tue Apr 30 11:16:19 2019 +0800 add git learn note 真的是叫天天不应叫地地不灵,本来是想回到过去旅游观光的,现在手头上没有了未来的坐标如何穿越回去啊? 哭了三天三夜,调整好心态,求人不如求己,努力回想下平生所学看看有什么别的方法能穿越回未来? 记得当初介绍 git log 命令时还介绍一个相似的命令,当时说高级进阶必备,现在不知道能不能用着. 叫什么名字,好像是\"回流\",于是经过千百次的尝试终于记起来命令,原来是 git reflog ,出发吧,皮卡丘! # 翻阅命令: 目前所处的版本号是 `08cbe61`,上一个版本号是 `0b0657b`,然后回到了 `08cbe61` . $ git reflog 08cbe61 (HEAD -> master) HEAD@{0}: reset: moving to 08cbe61c2a635ec6f70ae7a50842ae308cd95fee 0b0657b HEAD@{1}: commit: git is so easy 08cbe61 (HEAD -> master) HEAD@{2}: commit (initial): add git learn note 看来学习不能只追求够用啊,需要救命时还是要靠附加技能啊. # 重置版本: 穿越回未来,看到 \"git is so easy\" 放心多了,我应该回来了吧? $ git reset --hard 0b0657b HEAD is now at 0b0657b git is so easy # 查看文件内容: 我张汉三又回来了! $ cat git.md git 的基本流程 1. `git init` 初始化项目,创建本地网盘. 2. `git add` 添加文件,挑选出待上传到网盘的文件,准备上传. 3. `git commit` 提交文件,将已目标文件上传到网盘进行备份. 4. `git status` 查看文件状态,本地网盘创建完毕后随时随地呼唤小秘书查看文件状态. 5. `git log` 查看提交历史,同一个文件运行多次上传,每一次的文件都能识别,总览上传记录. 6. `git reflog` 查看回流历史,存储重要操作命令结果,高级进阶必备知识点. git is so easy 经过这次穿越之旅,再也不敢轻视任何一个知识点了,以后保不齐都是救命的附加技能啊,赶紧把这条感悟追加到 git.md 学习笔记中去! # `git reflog` 可以大概理解为 `reference log` 记做日志的参考日志,这样下次就不要绞尽脑汁回忆 `reflog` \"回流\"了! $ echo \"git reflog help us to back to fulture\" >> git.md 亲爱的小伙伴们,git 的学习之旅暂时告一段落,有没有掌握 git 命令行的基本操作呢? 如果想要了解关于 git 的相关知识,可以参考 git 入门教程 系列文章哟,当然这篇文章就是其中一篇呢! 登录到远程服务器: 远程登录 ssh DESTINATION : secure shell 的缩写,即安全的 shell 终端. 正常情况下 windows 系统自带 cmd 终端是不支持 ssh 方式登录 linux 服务器的,如果想要远程登录 linux 服务器一般需要安装第三方工具,但 git bash 命令行却支持ssh. # 登录 github: 正常输入用户名密码或者秘钥等可以登录到远程 `linux` 服务器. $ ssh git@github.com PTY allocation request failed on channel 0 Hi snowdreams1006! You've successfully authenticated, but GitHub does not provide shell access. Connection to github.com closed. 访问互联网资源: 网络请求 curl URL : CommandLine Uniform Resource Locator 的缩写,即命令行下载工具. 互联网的资源一般都有专属链接,通过浏览器我们可以访问网页,但是在命令行下没有浏览器又想访问互联网资源该怎么办? curl 就是这么一种工具,在命令行下也可以访问互联网资源,由于默认是将互联网资源下载到本地,因此又被成为命令行下载工具. # 将百度首页下载到 `baidu.html` 文件,配合管道符 `>` 实现文件内容的重定向 $ curl http://baidu.com > baidu.html 查看已运行命令: 历史 history : 翻译为\"历史\",即查看历史命令 $ history 常用命令 git bash 命令行终端内置命令比 windows 默认的 cmd 命令行窗口强大多了,除了支持一般的命令外,还支持简单的 linux 命令. 如果仅仅操作文本,git bash足以满足日常文增删该查需求,如果追求类 linux 命令行体验,推荐下载babun. Babun - a windows shell you will love ! 常用内置命令 # 打印当前登陆用户 $ whoami # 打印当前目录路径,其中 `/` 表示根目录,`~` 表示家目录. $ pwd # 查看当前目录下所有文件(夹) $ ls # 切换指定目录,其中 `cd` 不带任何参数直接切换到家目录,`../` 表示上一级目录 $ cd 切换目录 # 新建指定目录 $ mkdir DIRECTORY # 新建指定文件 $ touch FILE # 编辑指定文件 $ vim FILE # 查看指定文件 $ cat FILE # 查看指定文件开头部分,默认前十行. $ head FILE # 查看指定文件结尾部分,默认后十行. $ tail FILE # 查看操作历史 $ history # 复制文件 $ cp SOURCE DEST # 移动文件 $ mv SOURCE DEST # 删除文件 $ rm FILE # 删除文件夹 $ rmdir DIRECTORY # 特殊字符: `tab` 自动补全命令,`esc` 退出编辑模式，`>` 覆盖重定向,`>>` 追加重定向. # 远程登录服务器 $ ssh DESTINATION # 发起网络请求 $ curl URL git 基本命令 # 初始化本地项目 $ git init # 添加文件到缓存区 $ git add FILE # 提交文件到版本库 $ git commit # 查看文件状态 $ git status # 查看提交日志 $ git log # 查看操作历史 $ git reflog 小结 我们以现实世界和计算机世界对比分析,在命令行终端工具下通过命令试图介绍计算机哲学,顺便学习了常用的命令. 比如简单的文件增删改查,相信你现在无鼠标操作也能创建文件,删除文件以及复制修改文件了吧? 基本的命令除了解决日常所需外,还在于和其他工具的配合,比如我们使用的命令行终端是 git bash ,这是安装 git 服务时安装的辅助性工具,帮助我们在命令行下进行版本控制. 只有熟悉基本的命令后才能更好的理解 git 的工作流程,图形化工具或插件也有很多,每一种都有自己的操作风格,相信熟悉了命令后再去学习图形化工具操作也不会太费事. 希望本文对你理解计算机或者说学习 git 能够带来些许帮助,如有不当描述,欢迎指出补充. © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-30 15:25:51 "},"git/tools/git-bash-relationship.html":{"url":"git/tools/git-bash-relationship.html","title":"git bash 复杂关系","keywords":"","body":"git bash 复杂关系 曾以为 git bash 能够完全取代 cmd ,谁知道 cmd 却投给我一个鄙视的眼神! git bash 确实能够在一定程度上替代 cmd ,但是默认安装的 git bash 命令行工具并不能彻底取代 cmd ,难怪 cmd 听说要让自己退休,会呵呵一笑了! 你好陌生老朋友 windows 小伙伴们在学习 git 时不知道有没有接触过 git bash 命令行工具？ 反正我是接触过并且仍然在一直在使用中,因为 git bash 命令行工具是 windows 系统安装 git 服务时默认安装的扩展工具,它还有一个异卵双胞胎兄弟是 git gui 图形化工具. 这两兄弟一个像 linux ,一个像 windows ,虽然是一母同生,性格长相却千差万别,不过确实是双胞胎兄弟哟! 首先登场的是 Windows 系统所喜闻乐见的图形化工具,git gui 闪亮登场! 不是说好闪亮登场的吗,怎么右侧文件区是乱码?别急,简单设置下编码方式就能正常显示中文了. 在菜单栏选择编辑(Edit),然后选择选项(Options...),在设置页面左侧中间部分选择文件编码格式(Default File Content Encoding) 修改(Change)成 utf-8. 解决好中文乱码显示问题,现在演示下 git 的基本工作流. 依次点击扫描(Rescan) -> 暂存已更改(Stage Changed) -> 停止广播(Sign Off) -> 提交(Commit),完成一次文件修改后的提交操作. 其次登场的是 linux 小伙伴很熟悉的命令行操作方式,唤醒方式和上述工具的方式基本一致,选中项目的根路径右键选择Git Bash Here 跳出命令行窗口. git --version 查看 git 版本,git status 查看文件状态,git add 添加文件,git commit 提交文件. 现在两兄弟分别登台亮相,向大家展示了基本的操作流程,虽然操作方式不同,但最终目的确实一致的,这一下应该认同他们俩确实是亲兄弟了吧. 下面我们重点讨论下 git bash 命令行工具,看 git + bash 会擦除什么样的火花,让我们重新认识一下这个陌生的老朋友. git bash 命令行工具大多数情况下是通过安装 git 时进行集成安装的,当然也不排除单独安装的可能性. 回忆那年初相见 时光不老,我们不散,git bash 陪我们一起走过难忘的那一段路. git 是 linux 的缔造者开发出的一款分布式版本控制系统,最初是为了更好的服务 linux 系统的开发,后来逐渐风靡全球,成为当今世界上最先进最流行的分布式版本控制系统. 学习 git 或是工作所需,或是开源精神所驱使,不管出于怎样的目的,只要是想要学习 git ,那第一步已经迈出去,接下来的日子里我们都在构建自己的知识库. 如果是目的性非常明确的工作任务,越快越好,跟随项目团队选择一个图形化工具弄清楚基本操作,再配合实际工作需要找到自己的工作流程,这种方式最经济快捷. 如果相对充裕的话,我还是建议学习一下命令行操作.毕竟不是所有的环境都有自己熟悉的开发工具,更何况大牛更喜欢命令行操作,更炫酷更有型,不是吗？ linux 系统主要操作方式是命令行,mac 系统自带的终端也能很好支持命令行操作,唯独 windows 自带的 cmd 命令行有点差强人意了. 明明有各种各样的图形化工具,偏偏要学习命令操作,为什么？ 原因很简单： 记住命令有利于我们更加了解团队开发的工作流程以及自己在什么位置. 熟悉命令行后我们可以自由组合任意命令,从而定义属于自己的工作流. 更加接近真实生产环境,临时从开发环境切换到生产环境不至于措手不及. 各种图形化工具存在差异性,换个图形化工具又要重新记忆按键位置. 图形化工具不能随心所欲控制细节,功能受限,无法或者很难自定义扩展. 以上原因只是一家之言,切勿当真也不要较真,仅供参考. 正如\"自相矛盾\"故事中那样,没有绝对的最好,适合自己的才是最好的. 诚然,最初使用命令行操作 git 时,确实不太习惯,大多数人还是习惯图形化界面. 但是,现在想一想也没有那么难,不是吗？ git init 或者 git clone 用于初始化项目. git add 和 git commit 用于提交版本. git status 和 git diff 用于查看状态. git push 和 git pull 用于更新版本。 git branch 和 git tag 用于开发和发布. ... 当这些熟悉的命令一遍又一遍出现时,你还是觉得难吗,你说记不住那可能是你练习得还不够. 时光易老薄性情 恰逢春风正得意,忽遇桃花败满地. git bash 命令行操作让我们熟悉 git 基本工作流程,无论是命令行操作还是图形化工具,基本概念不会变,上手很快. 甚至,还会思考一个简单的按钮可能会涉及到哪些命令的组合,看看我们的思考和实际运行的命令有什么出入,潜移默化又提高了学习层次. 然而,事情的发展变化总不是一帆风顺的,尤其是换个环境时这种变化更为突出. 正如天天吃肉的皇帝面对闹饥荒吃不上饭的灾民,不明白他们为什么不吃肉呢？ 长时间处在一个环境中,思维很容易固化,理所当然认为世界本该如此,正是这些\"理所应当\"才弄出不少笑话. windows 系统自带的 cmd 风格丑陋,功能简单,不怎么受人待见. 所以,当 git 提供的 git bash 命令行工具能满足日常管理所需时自然不会再考虑 cmd . 毕竟,git bash 不仅操作界面漂亮而且功能体验也不错,基本的 bash 功能足够应付日常开发需求. 长此以往,潜意识中认为 git bash 能够完全替代 cmd,这种想法是不对的！ 实际上,git bash 并不能完全替代 cmd ,可以作为 cmd 的扩展补充,原配始终是原配！ 有些命令，git bash 没有提供就认为 cmd 肯定也没有,毕竟 cmd 命令行操作和 linux 命令行操作完全不是一个体验. 比如本人最近正在学习如何开发 gitbook 插件,跟着教程练习需要在看到目录结构是否一致,很自然想到了tree 命令,结果却发现查无此命令. 没有命令的话,可以理解,至少应该提供包管理工具供我自由扩展命令吧？很抱歉,并没有找到类似的包管理工具. 一味信任 git bash 直接导致的结果就是根本没有想到 cmd 自带的命令,事实上,cmd 是带有 tree 命令的. 探求庐山真面目 回到起点,重温当初走过的路. © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-05-03 14:41:39 "},"git/summary/common.html":{"url":"git/summary/common.html","title":"知识速查","keywords":"","body":"知识速查 创建版本库 初始化项目 git init 从零开始创建项目 示例 git init 克隆项目 git clone 将已有项目拷贝到本地 示例 git clone git@github.com:snowdreams1006/snowdreams1006.github.io.git 添加文件 git add 将新文件或已修改文件添加到缓存区 示例 git add README.md 查看状态 git status 查看当前文件是否和上次提交内容是否有修改 示例 git status README.md 比较差异 git diff 查看当前文件和上次提交内容的具体差异 尚未缓存的修改: git diff 查看已缓存修改: git diff --cached 查看已缓存与未缓存的所有修改: git diff HEAD 显示摘要而非整个差异: git diff --stat 示例 git diff README.md 提交文件 git commit 将缓存区内容添加到版本库 示例 git commit -m \"remark\" 取消已缓存内容 git reset HEAD 将缓存区内容添加到版本库 示例 git reset HEAD 删除文件 git rm 从暂存区中移除且不保留在工作目录: git rm 强制从暂存区中移除且不保留在工作目录: git rm -f 从暂存区中移除但保留工作目录: git rm --cached 示例 git rm README.md 移动文件 git mv 移动或重命名文件,目录,软连接 示例 git mv README.md README_NEW.md commit push pull fetch merge 的区别与含义: git commit : 将本地修改过的文件提交到本地仓库中 git push : 将本地仓库的最新版本推送到远程库中 git pull : 从远程库获取最新版本到本地,并自动merge git fetch : 从远程库获取最新版本到本地,不会自动merge git merge : 将指定版本合并到当前分支 替换本地改动 丢弃当前文件修改内容,已添加到暂存区以及新文件都不会受到影响 示例 git checkout -- 丢弃本地所有改动 示例 git reset --hard 分支管理 创建分支 git branch 创建本地分支,但不自动切换新分支 示例 git branch dev 切换分支 git checkout 切换到指定分支 示例 git checkout dev 创建并切换分支 git checkout -b 创建本地分支并自动切换到新分支 示例 git checkout -b feature 合并分支 git merge 将指定分支合并到当前分支 示例 git merge dev 删除分支 git branch -d 删除指定分支 示例 git branch -d dev 列出分支 git branch 列出本地全部分支 示例 git branch 提交日志 git log 查看纳入版本库的提交日志 示例 git log 标签管理 创建标签 git tag -a 创建标签并提交备注 示例 git tag -a v1.0.0 追加标签 git tag -a 追加标签并更新备注 示例 git tag -a v0.9.0 6ad8956bc09a6a62c731711eabe796690aa6471c 删除标签 git tag -d 删除指定标签 示例 git tag -d v1.0.0 查看标签 git show 查看指定标签 示例 git show v1.0.0 列出标签 git tag 列出本地全部标签 示例 git tag © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"git/summary/cheatsheet-translation.html":{"url":"git/summary/cheatsheet-translation.html","title":"备忘录[译]","keywords":"","body":"备忘录[译] 创建 | Create 克隆一个已存在的仓库 | Clone an existing repository git clone git@github.com:snowdreams1006/snowdreams1006.github.io.git 创建一个新的本地仓库 | Create a new local repository git init 本地更改 | Local Changes 工作目录中已更改文件 | Changed files in your working directory git status 已追踪文件的更改 | Changes to tracked files git diff 添加当前全部更改到下次提交版本 | Add all current changes to next commit git add . 添加文件中某些更改到下次提交版本 | Add some changes in to next commit git add -p 提交已追踪文件的全部本地更改 | Commit all local changes in tracked files git commit -a 提交上一次暂存区更改 | Commit previously staged changes git commit 更改上次提交 | Change the last commit 没有更改已发布的提交 | Don't amend publishd commits! git commit --amend 提交历史 | Commit history 显示全部提交,以最新的开头 | Show all commits,starting with newest git log 显示某个文件一段时间内的更改 | Show changes over time for a specific file git log -p 某文件是谁在什么时候更改了什么内容 | Who changed what and when in git blame 分支和标签 | Branches & Tags 列出全部已存在的分支 | List all existing branches git branch -av 切换到 HEAD 分支 | Switch HEAD branch git checkout 基于当前 HEAD 创建新分支 | Create a new branch based on your curent HEAD git branch 基于远程分支创建新的正在追踪分支 | Create a new tracking branch based on a remote branch git checkout --track 删除一个本地分支 | Delete a local branch git branch -d 为当前提交打上标签 | Make the current commit with a tag git tag 更新和发布 | Update & Publish 列出当前全部已配置的远程仓库 | List all currently configured remotes git remote -v 显示远程仓库信息 | Show information about a remote git remote show 添加的远程仓库 | Add new remote repository named git remote add 下载来自远程仓库的所有更改但是不合并到 HEAD | Download all changes from but don't integrate into HEAD git fetch 下载来自远程仓库指定分支的所有更改并且自动合并到 HEAD | Download changes and directly merge/integrate into HEAD git pull 在远程仓库上发布本地更改 | Publish local changes on a remote git push 在远程仓库上删除分支 | Delete a branch on the branch git branch -dr 发布你的标签 | Publish your tags git push --tags 合并和变基 | MERGE & REBASE 合并指定分支到你的 HEAD | Merge into your current HEAD git merge 变基到当前HEAD | Rebase your current HEAD onto 不要变基已发布的提交 | Don't rebase published commits! git rebase 取消变基 | Abort a rebase git rebase --abort 使用已配置的冲突工具去解决冲突 | Use your configured merge tool to solve conflicts git mergetool 使用编辑器手工解决冲突然后(解决之后)标记文件已解决冲突 | Use your editor to manually solve conflicts and (after resolving) mark file as resolved git add git rm 撤销 | UNDO 丢弃工作区全部更改 | Discard all local changes in your working directory git reset --hard HEAD 丢弃指定文件的本地更改 | Discard local changes in a specific file git checkout HEAD 抵消一个提交(通过产生一个新的相反的提交) | Revert a commit (by producing a new commit with contrary changes) git revert 重置当前 HEAD 指针到上一个提交...然后丢弃自那以后的全部更改 | Reset your HEAD pointer to a previous commit ... and discard all changes since then git reset --hard ...然后作为未缓存更改保存全部更改 | ... and preserve all changes as unstaged change git reset ...然后保存未提交的本地更改 | ... and preserve all changes as unstaged change git reset --keep 建议 | SUGGESTION 提交相关更改 | COMMIT RELATED CHANGES 提交应该是相关更改的包装,例如,修复两个不同的 bug 应该产生两个单独的提交. 小的提交让其他开发者更容易理解此次更改,并且万一出错方便回滚. 在暂存区这类工具以及暂存部分文件的能力下,git 很容易创建细粒度的提交. A commit should be a wrapper for related changes, For example,fixing two different bugs should produce two separete commits. Small commits make it easier for other developers to understand the changes and roll them back if something went wrong. With tools like the staging area and the ability to stage only parts of a file. Git makes it easy to create very granular commits. 经常提交 | COMMIT OFTEN 经常提交使得你的提交很小并且有助于仅提交相关更改. 此外,这样允许你更频繁地和其他人分享你的代码,对于每个人来说更容器定期合并更改,避免了遭遇合并冲突. ,很少的大提交,很少分享它们.相反很难解决冲突. Commiting often keeps your commits small and again helps you commit only related changes. Moreover,it allows you to share your code more frequently with others. That way it's easier for everyone to integrate changes regularly and avoid having merge conflicts.Having few large commits and sharing them rarely.in contrast,makes it hard to solve conflicts. 不要提交未完成工作 | DON'T COMMIT HALF-DONE WORK 你应该仅提交已完成代码,这并不意外着提交前你不得不完成一个完整的,很大的功能分支.恰恰相反,将功能分支划分成很多逻辑块并且记得早一点,频繁些提交. 如果仅仅是为了下班前仓库该有点什么就不要提交,如果你尝试提交仅仅是因为你需要一个干净的工作副本(检出分支,拉取更改),考虑使用 git 的 stash 特性. You should only commit code when it's completed. This doesn't mean you have to complete a whole ,large feature before commiting. Quite the contrary:split the feature's implementatiion into logical chunks and remember to commit early and often. But don't commit just to have something in the repository before leaving the ofice at the end of the day. If you're tempted to commit just because you need a clean working copy (to check out a branch,pull in changes ,etc.) consider using Git's feature instead. 提交前测试代码 | TEST CODE BEFORE YOU COMMIT 抵制自以为已完成的提交. 直接测试来确保它真的已完成并且没有副作用(显而易见的). 当提交半成品到本地仓库时要求你不得不自我谅解,让你的代码进过测试对发布或者分享你的代码也很重要. Resist the temptation to commit something that you think is completed. Test it thoroughly to make sure it really is completed and has no side effect (as far as one can tell). While committing half-baked thing in your local repository only requires you to forgive yourself,having your code tested is even more important when it comes to publishing/sharing your code with others. 编写代码提交信息 | WRITE CODE COMMIT MESSAGE 对你的更改以简短总结进行描述(达到50字符作为准则). 以包括空白行作为分割下述内容. 提交信息体应该提供下述问题的详细答案: 此次更改的动机是什么? 和上一个实现有什么不同? 使用必要的现在时语态(更改,不是已更改,或者变更)和使用形如 git merge 命令生成的信息保持一致. Begin your message with short summary of your changes(up to 50 characters as a guideline). Separate it from the following body by including a blank line. The body of your message should provide detailed answers to the following questions: What was the motivation for the change? How does it differ from the previous implementation? Use the imperative ,present tense(change,not changed or changes) to be consistent with generated messages from commands like git merge. 版本控制不是一个备份系统 | VERSION CONTROL IS NOT A BACKUP SYSTEM 在远程服务器存有文件的备份是版本控制系统的一个很好副作用.但是你不应该将VCS 视为一个备份系统. 当做版本控制时,你应该注意语义化提交,而不是死记硬背文件. Having your files backed up on a remote server is a nice side effect of having a version control system. But you should not use your VCS like it was a backup system. When doing version control,you should pay attention to committing semantically(see related changes) - you shouldn't just cram in files. 利用分支 | USE BRANCHES 分支是 git 最强大的特性之一,这不是偶然. 从第一天开始快速而简单的分支就是一个核心需求. 分支是帮助你避免弄混不同开发线的完美工具. 在你的开发流程中应该广泛使用分支,像新功能,修复 bug,新想法... Branching is one of Git's most powerful features-and this is not by accident:quick and easy branching was a central requirement from day one. Branches are the perfect tool to help you avoid mixing up different lines of development. You should use branches extensively in your development workflows:for new features,bug fixes,ideas... 认同工作流 | AGREE ON A WORKFLOW Git 允许你从大量不同的工作流中选择一个:长期运行的分支,主题分支,合并或变,基工作流... 具体选择哪一个取决于一系列因素:你的项目,你的总体开发和部署工作流和(可能是最重要的)你和你的团队的个人偏好. 不论你选择哪一个去工作,你需要确保准守一个大家都认同的工作流. Git lets you pick from a lot of different workflows:long-running branches,topic branches,merge or rebase,git-flow... Which one you choose depends on a couple of factors:your project,your overall development and deployment workflows and (maybe most importantly ) on your and your teammate's personal preferences. However you choose to work,just make sure to agree on a common workflow that everyone follows. 帮助和文档 | HELP & DOCUMENTATION 命令行下获取 git 帮助 git help Git help on the command line git help 免费在线资源 | FREE ONELINE RESOURCES http://www.git-tower.com/learn http://rogerdudler.github.io/git-guide/ http://www.git-scm.org/ © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"git/issue/":{"url":"git/issue/","title":"常见问题","keywords":"","body":"常见问题 最新文档 官网实时更新同步,第三方平台定期更新,但不保证同步. git 入门教程 初识 git 安装 git 配置 git 实战 git 本地仓库 版本管理 回到过去 基本概念 版本控制 撤销更改 删除文件 远程仓库 分支管理 分支总览 冲突合并 分支策略 紧急修复 变基合并 协同开发 本地和远程仓库的本质 里程碑式标签 个性化 git 忽略文件 github 教程 git 私服搭建教程 知识速查 备忘录[译] 常见问题 同步平台 简书 : git 入门教程专题 CSDN : git 入门教程专栏 博客园 : git 入门教程随笔 掘金 : 雪之梦技术驿站专栏 开源中国 : git 入门教程分类 segmentfault : 雪之梦技术驿站专栏 慕课手记 : git 手记 B站专栏 : git 入门教程文集 微信公众号 : 名称: 雪之梦技术驿站,微信号: snowdreams1006 © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"myGitbook/":{"url":"myGitbook/","title":"gitbook 入门教程","keywords":"","body":"gitbook 入门教程 gitBook 是一个基于node.js的命令行工具,使用 github/git 和 markdown/asciiDoc 构建精美的电子书. gitbook 支持输出静态网页和电子书等多种格式,其中默认输出静态网页格式. gitbook 不仅支持本地构建电子书,而且可以托管在 gitbook 官网上,并享受在线发布和托管图书的便利,完整的文档请参考 gitbook 新版文档(需FQ) 或 gitbook 旧版文档(不需FQ) 适用场景 不仅适用于软件说明文档的发布更新,同样适用于文本文档的连载更新. 既适合具有一定编程经验的软件开发从业者,也适用于不满足传统书写方式的文学创作者. 简而言之,gitbook 可以条理清晰地整理出零碎知识,打造专属你自己的电子书,漂亮的主题,丰富的插件让你的知识变得从此与众不同! git + markdown = gitbook,其中 git 可以管理书籍内容的变更,并将其托管到云端实现团队协作,而 markdown 简洁的语法特点,使得我们不必关心布局排版问题,专注创作,重拾写作乐趣! 如果你还不了解 git 和 markdown 相关知识,赶紧去学习 markdown 快速入门 和 git 入门教程 吧! 先睹为快 gitbook 教程 gitbook 官网 gitbook 文档 参考文档 gitbook 官网(新) gitbook 官网(旧) gitbook 文档(新) gitbook 文档(旧) git 官网 github 官网 gitbook 新版需要FQ,旧版不需要FQ © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"myGitbook/preparation/prepare.html":{"url":"myGitbook/preparation/prepare.html","title":"准备阶段","keywords":"","body":"准备阶段 主要包括两部分: 前置知识和操作工具. 前置知识主要是涉及到 git 以及 markdown 的相关知识,其中 git 是分布式版本控制系统,方便管理我们的电子书,备份到云端,方便团队共享合作,而 markdown 则是一种简单标记语言,简单情况下可以替代 word 进行排版布局,能完全替换 txt 文本,最终实现媲美 html 的输出效果,简洁高效的书写体验,深受广大软件开发者的喜爱. 正是由于 git + markdown 的搭配组合,使得上手 gitbook 相当简单,带给一种全新的体验. 操作工具主要是环境准备,主要是指 gitbook 环境,因为涉及到 git ,所以也包括 git 环境,至于markdown 语法支持,不一定非要安装相应软件,按照规定的格式书写文档即可,不过新手可能更愿意使用可视化软件,毕竟所见即所得,写着放心,看着舒心! 知识准备 markdown 快速入门 git 入门教程 上述教程中有详细的安装以及使用方法,最好能够完全掌握,如果时间有限,不愿意细读的话,请看下一节,我会挑选出常用命令进行讲解! © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"myGitbook/preparation/front-knowledge.html":{"url":"myGitbook/preparation/front-knowledge.html","title":"前置知识","keywords":"","body":"前置知识 markdown 基本知识 markdown 是一种简化的 html 语法,相比于 txt 无格式文本更强大. 你可以用专门的软件去编辑 markdown 文件,就像需要使用软件编辑 txt 文件一样,当然也可以什么软件也不用,甚至直接在记事本或命令行书写,只不过这样的缺点就是无法实时预览输出效果,安全依赖个人经验和想象力了. markdown 文件后缀名是.md,安装了相应插件的浏览器或专门软件能够看到输出效果. 标题 语法格式: # + 空格 + 文本 大多数markdown编辑器支持 h1~h6 级标题,而富文本编辑器一般仅支持到二级标题. 示例: # 标题1 ## 标题2 效果: 标题1 标题2 列表 列表包括有序列表,无序列表和任务列表,并支持列表嵌套. 大多数 markdown 编辑器和富文本编辑器均支持有序列表和无序列表,而任务列表和列表嵌套支持度就不是很好,存在平台兼容性问题. 有序列表 语法格式：数字 + . + 空格 + 文本 示例: 1. 有序列表1 2. 有序列表2 3. 有序列表3 效果: 有序列表1 有序列表2 有序列表3 无序列表 语法格式：'- 或 * 或 +' + 空格 + 文本 示例: - 无序列表1 * 无序列表2 + 无序列表3 效果: 无序列表1 无序列表2 无序列表3 链接和图片 markdown 编辑器和富文本编辑器均支持链接和图片,值得注意的是有些平台限制或禁止外链. 链接 语法格式：[显示文本] + (链接地址) 示例: [https://snowdreams1006.github.io](https://snowdreams1006.github.io/) 效果: https://snowdreams1006.github.io 图片 语法格式：! + [图片标题] + (图片地址) 示例: ![雪之梦技术驿站的头像](https://upload.jianshu.io/users/upload_avatars/16648241/57aebe62-b5b5-491a-a9fd-f994d5be7dda.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/240/h/240) 效果: 代码 代码分为单行代码和多行代码,其中多行代码也叫做代码块. 大多数 markdown 编辑器均支持代码,富文本编辑器支持度不一样,有的支持单行代码有的支持代码块. 单行代码 语法格式：` + 单行代码 + ` 示例: `code` 效果: code 多行代码 语法格式：``` + 多行代码 + ``` 示例: ``` function fun(){ echo \"这是一句非常牛逼的代码\"; } fun(); ``` 效果: function fun(){ echo \"这是一句非常牛逼的代码\"; } fun(); 这里的富文本支持语法指的是 markdown 渲染后的内容能否正常显示,并不是指 markdown语法本身能够正常渲染,更多详情请参考 markdown 快速入门 git 基本知识 git 是全世界最先进的分布式版本控制系统,帮助项目更好地进行管理,支持版本历史管理和多人写作管理等功能. 简单地说,可以理解为一种优雅的文档备份方式,支持云端备份,多人协作等特点. 初始化项目 语法格式: git init 适合从零开始的本地项目,初始化后的项目才是能够被 git 管理的项目. 示例: git init 克隆项目 语法格式: git clone 适合已有远程项目需要下载到本地,作用是将远程项目克隆到本地,和 git init 实现类似的功能. 示例: git clone git@github.com:username/username.github.io.git 添加文件 语法格式: git add 将文件添加到暂存区,支持多次添加文件,相当于写入缓存区. 示例: git add . 提交文件 语法格式: git commit 将暂存区内容提交到版本库,完成一次历史版本. 示例: git commit -m \"写入提交备注,简短说明下提交意图和目标\" 推送文件 语法格式: git push 将本地版本库推送到远程版本库,相当于本地文件备份到云端服务器. 示例: git push origin master 拉取文件 语法格式: git pull 将远程版本库拉取到本地版本库,相当于云端服务器文件恢复到本地. 示例: git pull 查看状态 语法格式: git status 查看当前文件状态,包括文件被新增,被修改,被删除,未提交等等. 示例: git status 比较差异 语法格式: git diff 查看两个文件之间的具体差异 示例: git diff 历史日志 语法格式: git log 查看版本库的提交历史日志 示例: git log 上述仅介绍了 git 的简单命令,实际使用情况远不止这些,更多详情请参考 git 入门教程 © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"myGitbook/preparation/environmental-requirements.html":{"url":"myGitbook/preparation/environmental-requirements.html","title":"环境要求","keywords":"","body":"环境要求 gitbook 是基于 node.js 的命令行工具,首先需要安装并配置好 node.js 环境,然后才能安装gitbook 相关工具. 由于安装工具全部都是国外网站,因此速度可能会很慢,也可能需要FQ,请耐心等待或者学会科学上网. 当然如果安装过程中遇到任何问题,也可以找我要一下安装包或者我帮你免费解决下. 环境预检查 检查 git 环境[可选] git 是免费开源的分布式版本控制系统,主要用于电子书的更新管理和团队协作,如果不需要将电子书托管到github 网站上,则可以不安装 git . 如果打印出 git 版本信息,则表示本机已安装 git 环境,跳过此步骤. $ git --version git 安装配置教程请参考初识 git 检查 node.js 环境[必须] node.js 是 js 在服务端运行的环境基础,从而使得 js 从浏览器端延伸到服务端领域,而 gitbook 则是运行在 node.js 基础之上的命令行工具,因此必须先安装好 node.js 开发环境. 如果打印出 node.js 版本信息,则表示本机已安装 node.js 环境,跳过此步骤. $ node -v node.js 安装配置教程请参考 https://nodejs.org/ 检查 gitbook 环境[必须] gitbook-cli 是 gitbook 的脚手架工具,帮助我们更方便构建 gitbook 应用,当然也可以直接安装 gitbook ,只不过那样的话,略显麻烦,不推荐. 如果打印出 gitbook 和 cli 版本信息,则表示本机已安装 gitbook 环境,跳过此步骤. $ gitbook -V 否则的话,本机可能并没有安装 gitbook 环境,则需要安装 gitbook 相关工具. 因为 gitbook 是基于 node.js 环境,而安装好 node.js 后默认提供了 npm 包管理工具,而我们则是通过 npm 来安装其他工具. 安装 gitbook-cli 工具[必须] 假设你已经搭建好 node.js 环境,现在我们开始安装 gitbook 相关工具了! $ sudo npm install -g gitbook-cli 全局安装的话,可能需要超级管理员权限,输入下相应密码即可继续安装,如无报错,则表示安装成功. 安装成功后会带有 gitbook 命令,现在再次运行下 gitbook -V 查看版本信息. # 打印出 `CLI` 和 `GitBook` 版本信息即可,安装版本可能已经大于 `2.3.2` $ gitbook -V CLI version: 2.3.2 GitBook version: 3.2.3 $ 安装 GitBook Editor 编辑器[可选] gitbook 官方客户端编辑器,支持 windows, mac 和 linux ,主要用于可视化编辑文档,组织文档结构. 下载相应平台的 GitBook Editor,正常安装即可. gitbook 的使用方法大致可以有三种,而 GitBook Editor 编辑器只是其中一种,所以这一步是可选的. 使用 gitbook-cli 脚手架提供的各种命令直接在命令行管理 gitbook,适合一定编程经验的软件从业人员. 使用 GitBook Editor 编辑器管理 gitbook ,适合无任何编程的文学创作者. 使用 gitbook.com 官网在线管理 gitbook ,适合不具备本地开发环境的萌新体验者. 小结 gitbook 基于 node.js 开发环境,因此首先要安装好 nodejs 环境,其次再使用 node.js 提供的 npm 包管理工具来安装 gitbook. 只需运行 sudo npm install -g gitbook-cli 即可安装,接着运行 gitbook -V 查看安装版本信息确认已经安装成功. 至此 gitbook 的必要开发环境已经准备妥当,接下来让我们赶紧体验一下 gitbook 的魅力吧! © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"myGitbook/experience/preview.html":{"url":"myGitbook/experience/preview.html","title":"快速体验","keywords":"","body":"快速体验 本文主要介绍三种使用 gitbook 的方式,分别是 gitbook 命令行工具,Gitbook Editor 官方编辑器和 gitbook.com 官网. 总体来说,三种途径适合各自不同的人群,找到适合自己的方式就好,基本操作流程都是一样的. 命令行工具更适合具备编程经验开发者,具有简单高效易整合等特点. 编辑器更适合无任何编程经验的文学创作者,不熟悉 markdown 语法,不熟悉 git 工作流,这种情况下也推荐使用图形化操作的编辑器. 官网适合想要快速体验 gitbook 效果的萌新,只有觉得物超所值才能有动力搭建 gitbook 开发环境,不是吗? 当然,如果你想访问官网的话,你可能需要学会科学上网,网址见文章结尾. gitbook 命令行 首先需要创建存放书籍的目录,然后对该目录进行初始化,最后启动本地服务即可体验效果. 初始化项目 语法格式: gitbook init 如果是空目录会自动创建 README.md 和 SUMMARY.md 两个文件,当然也可以手动创建再初始化. 示例: # 创建 `gitbook` 演示项目 $ mkdir gitbook-demo # 初始化项目 $ gitbook init warn: no summary file in this book info: create README.md info: create SUMMARY.md info: initialization is finished # 当前目录结构 $ tree . ├── README.md └── SUMMARY.md 0 directories, 2 files $ gitbook init 命令可能会自动生成 README.md 和 SUMMARY.md 两个文件,如已存在则更新. 运行项目 语法格式: gitbook serve 将初始化后的项目启动成为一个本地服务,我们可以直接在浏览器访问项目,预览书籍效果. 示例: # 启动本地服务器 $ gitbook serve Live reload server started on port: 35729 Press CTRL+C to quit ... info: 7 plugins are installed info: loading plugin \"livereload\"... OK info: loading plugin \"highlight\"... OK info: loading plugin \"search\"... OK info: loading plugin \"lunr\"... OK info: loading plugin \"sharing\"... OK info: loading plugin \"fontsettings\"... OK info: loading plugin \"theme-default\"... OK info: found 1 pages info: found 0 asset files info: >> generation finished with success in 1.2s ! Starting server ... Serving book on http://localhost:4000 如果要停止服务器,只需同时按住 CTRL+C 即可,现在再看一下 gitbook-demo 目录结构. $ tree . ├── README.md ├── SUMMARY.md └── _book ├── gitbook │ ├── fonts │ │ └── fontawesome │ │ ├── FontAwesome.otf │ │ ├── fontawesome-webfont.eot │ │ ├── fontawesome-webfont.svg │ │ ├── fontawesome-webfont.ttf │ │ ├── fontawesome-webfont.woff │ │ └── fontawesome-webfont.woff2 │ ├── gitbook-plugin-fontsettings │ │ ├── fontsettings.js │ │ └── website.css │ ├── gitbook-plugin-highlight │ │ ├── ebook.css │ │ └── website.css │ ├── gitbook-plugin-livereload │ │ └── plugin.js │ ├── gitbook-plugin-lunr │ │ ├── lunr.min.js │ │ └── search-lunr.js │ ├── gitbook-plugin-search │ │ ├── lunr.min.js │ │ ├── search-engine.js │ │ ├── search.css │ │ └── search.js │ ├── gitbook-plugin-sharing │ │ └── buttons.js │ ├── gitbook.js │ ├── images │ │ ├── apple-touch-icon-precomposed-152.png │ │ └── favicon.ico │ ├── style.css │ └── theme.js ├── index.html └── search_index.json 11 directories, 27 files $ gitbook serve 命令可能会自动生成 _book 目录,如已存在则更新. gitbook editor 编辑器 下载 gitbook editor 并安装,如果下载遇到困难,可以找我来帮忙哟! 如果你没有梯子,可以暂不登录(Do that Later),只不过无法与 gitbook.com 保持同步. 更改图书路径 更改默认图书存放位置(Gitbook Editor => Change Library Path...),以后图书目录都在该目录下,比如设置的是 .../gitbook-editor/ 图书目录. 新建图书 新建图书项目,名字仍然是 gitbook-demo,这样方便比较和命令行创建的 gitbook-demo 区别. 图形化操作界面总体来说还是很容易上手的,自己好好研究一下即可,这里仅仅演示默认效果. 启动项目 现在先找到新建图书的具体目录,然后再启动本地服务器,同样地,我们在浏览器中体验电子书效果. 图书项目路径: /workspace/gitbook-editor/Import/gitbook-demo,其中 /workspace/gitbook-editor/ 是上一步更改的图书路径. # 启动本地服务器 $ gitbook serve 这里不再需要运行 gitbook init 命令了,因为已经创建过 README.md 和 SUMMARY.md 这两个文件. Gitbook Editor 编辑器新建的图书项目和 gitbook-cli 创建的图书项目本质上并没有什么不同,只不过编辑器集成了常用功能而已! gitbook.com 网站 由于受网络因素所限,暂时不分享这部分知识了,简单来说就是在线编辑并发布电子书,这一点和 github 的代码托管服务类似. gitbook 新版官网(需要FQ) : https://www.gitbook.com/ gitbook 旧版官网(无需FQ) : https://legacy.gitbook.com 小结 初始化项目 : gitbook init 启动项目 : gitbook serve 默认访问地址: http://localhost:4000 © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"myGitbook/experience/gitbook-cli.html":{"url":"myGitbook/experience/gitbook-cli.html","title":"gitbook-cli 命令行操作","keywords":"","body":"gitbook-cli 命令行操作 gitbook 生成电子书主要有三种方式: gitbook-cli 命令行操作,简洁高效,适合从事软件开发的相关人员. gitbook-editor 编辑器操作,可视化编辑,适合无编程经验的文学创作者. gitbook.com 官网操作,在线编辑实时发布,适合无本地环境且科学上网的体验者. 本文主要讲解第一种 gitbook-cli 命令行操作流程,其他两种见另外两篇教程. gitbook 的一些常用命令 安装 gitbook-cli 脚手架工具 本机已安装 node.js 开发环境,安装完成后运行 gitbook -V 能够打印出版本信息,则表示安装成功. $ sudo npm install -g gitbook-cli 关于安装配置相关问题请参考 环境要求 初始化 gitbook 项目 初始化项目,按照 gitbook 规范会自动创建 README.md 和 SUMMARY.md 两个文件,具体用途见下文. 其实 SUMMARY.md 是电子书的章节目录,gitbook 会初始化相应的文件目录结构,所以主要是用于开发初始阶段. $ gitbook init 启动 gitbook 项目 启动本地服务,程序无报错则可以在浏览器预览电子书效果: http://localhost:4000 由于能够实时预览电子书效果,并且大多数开发环境搭建在本地而不是远程服务器中,所以主要用于开发调试阶段. $ gitbook serve 构建 gitbook 静态网页 构建静态网页而不启动本地服务器,默认生成文件存放在 _book/ 目录,当然输出目录是可配置的,暂不涉及,见高级部分. 输出静态网页后可打包上传到服务器,也可以上传到 github 等网站进行托管,因而主要用于发布准备阶段. $ gitbook build 章节小结 gitbook init 初始化 README.md 和 SUMMARY.md 两个文件. gitbook build 本地构建但不运行服务,默认输出到 _book/ 目录. gitbook serve 本地构建并运行服务,默认访问 http://localhost:4000 实时预览. # 创建 `gitbook` 演示项目 $ mkdir gitbook-demo # 初始化项目 $ gitbook init warn: no summary file in this book info: create README.md info: create SUMMARY.md info: initialization is finished # 启动本地服务器 $ gitbook serve Live reload server started on port: 35729 Press CTRL+C to quit ... info: 7 plugins are installed info: loading plugin \"livereload\"... OK info: loading plugin \"highlight\"... OK info: loading plugin \"search\"... OK info: loading plugin \"lunr\"... OK info: loading plugin \"sharing\"... OK info: loading plugin \"fontsettings\"... OK info: loading plugin \"theme-default\"... OK info: found 1 pages info: found 0 asset files info: >> generation finished with success in 1.2s ! Starting server ... Serving book on http://localhost:4000 # 查看当前目录结构 $ tree . ├── README.md ├── SUMMARY.md └── _book ├── gitbook │ ├── fonts │ │ └── fontawesome │ │ ├── FontAwesome.otf │ │ ├── fontawesome-webfont.eot │ │ ├── fontawesome-webfont.svg │ │ ├── fontawesome-webfont.ttf │ │ ├── fontawesome-webfont.woff │ │ └── fontawesome-webfont.woff2 │ ├── gitbook-plugin-fontsettings │ │ ├── fontsettings.js │ │ └── website.css │ ├── gitbook-plugin-highlight │ │ ├── ebook.css │ │ └── website.css │ ├── gitbook-plugin-livereload │ │ └── plugin.js │ ├── gitbook-plugin-lunr │ │ ├── lunr.min.js │ │ └── search-lunr.js │ ├── gitbook-plugin-search │ │ ├── lunr.min.js │ │ ├── search-engine.js │ │ ├── search.css │ │ └── search.js │ ├── gitbook-plugin-sharing │ │ └── buttons.js │ ├── gitbook.js │ ├── images │ │ ├── apple-touch-icon-precomposed-152.png │ │ └── favicon.ico │ ├── style.css │ └── theme.js ├── index.html └── search_index.json 11 directories, 27 files $ gitbook 的目录结构说明 既然要书写一本电子书,那么起码的章节介绍和章节详情自然是必不可少的. 当然还有标题,作者和联系方式等个性化信息需要指定,如果不指定的话,一旦采用默认配合,八成不符合我们的预期,说不定都会变成匿名电子书?所以配置文件一般也是需要手动设置的! 真正可选的文件要数词汇表了,毕竟不是每一本电子书都有专业词汇需要去解释说明.如果在章节详情顺便解释下涉及到的专业词汇,那么自然也就不需要词汇表文件了. 简单解释下各个文件的作用: README.md 是默认首页文件,相当于网站的首页 index.html ,一般是介绍文字或相关导航链接. SUMMARY.md 是默认概括文件,主要是根据该文件内容生成相应的目录结构,同 README.md 一样都是被gitbook init 初始化默认创建的重要文件. _book 是默认的输出目录,存放着原始 markdown 渲染完毕后的 html 文件,可以直接打包到服务器充当静态网站使用.一般是执行 gitbook build 或 gitbook serve 自动生成的. book.json 是配置文件,用于个性化调整 gitbook 的相关配置,如定义电子书的标题,封面,作者等信息.虽然是手动创建但一般是必选的. GLOSSARY.md 是默认的词汇表,主要说明专业词汇的详细解释,这样阅读到专业词汇时就会有相应提示信息,也是手动创建但是可选的. LANGS.md 是默认的语言文件,用于国际化版本翻译,和 GLOSSARY.md 一样是手动创建但是可选的. README.md 首页文件[必须] 编辑 README.md 文件,随便写点内容并启动本地服务(gitbook serve)实时预览效果. SUMMARY.md 概括文件[必须] 先停止本地服务,编辑章节目录结构,然后重新再初始化(gitbook init)自动创建相应目录. _book 输出目录[可选] 执行 gitbook build 或 gitbook serve 命令后会自动生成静态网页. # 构建电子书 $ gitbook build info: 7 plugins are installed info: 6 explicitly listed info: loading plugin \"highlight\"... OK info: loading plugin \"search\"... OK info: loading plugin \"lunr\"... OK info: loading plugin \"sharing\"... OK info: loading plugin \"fontsettings\"... OK info: loading plugin \"theme-default\"... OK info: found 5 pages info: found 0 asset files info: >> generation finished with success in 0.7s ! # 查看输出目录 $ tree _book/ _book/ ├── first │ ├── 01.html │ └── 02.html ├── first.html ├── gitbook │ ├── fonts │ │ └── fontawesome │ │ ├── FontAwesome.otf │ │ ├── fontawesome-webfont.eot │ │ ├── fontawesome-webfont.svg │ │ ├── fontawesome-webfont.ttf │ │ ├── fontawesome-webfont.woff │ │ └── fontawesome-webfont.woff2 │ ├── gitbook-plugin-fontsettings │ │ ├── fontsettings.js │ │ └── website.css │ ├── gitbook-plugin-highlight │ │ ├── ebook.css │ │ └── website.css │ ├── gitbook-plugin-lunr │ │ ├── lunr.min.js │ │ └── search-lunr.js │ ├── gitbook-plugin-search │ │ ├── lunr.min.js │ │ ├── search-engine.js │ │ ├── search.css │ │ └── search.js │ ├── gitbook-plugin-sharing │ │ └── buttons.js │ ├── gitbook.js │ ├── images │ │ ├── apple-touch-icon-precomposed-152.png │ │ └── favicon.ico │ ├── style.css │ └── theme.js ├── index.html ├── search_index.json └── second.html 10 directories, 28 files $ book.json 配置文件[可选] 在根目录下新建 book.json 配置文件,完整的支持项请参考官方文档,下面仅列举常用的一些配置项. title 标题 书籍的标题 示例: \"title\": \"雪之梦技术驿站\" author 作者 书籍的作者 示例: \"author\": \"snowdreams1006\" description 描述 书籍的简要描述 示例: \"description\": \"雪之梦技术驿站又名snowdreams1006的技术小屋.主要分享个人的学习经验,一家之言,仅供参考.\" isbn 国际标准书号 书籍的国际标准书号 示例: \"isbn\": \"978-0-13-601970-1\" 选填,请参考 ISBN Search language 语言 支持语言项: 默认英语(en),设置成简体中文(zh-hans) en, ar, bn, cs, de, en, es, fa, fi, fr, he, it, ja, ko, no, pl, pt, ro, ru, sv, uk, vi, zh-hans, zh-tw 示例: \"language\": \"zh-hans\" direction 阅读顺序 阅读顺序,支持从右到左(rtl)或从左到右(ltr),默认值取决于语言值. 示例: \"direction\" : \"ltr\" gitbook 版本 指定 gitbook 版本,支持SemVer规范,接受类似于 >=3.2.3 的条件. 示例: \"gitbook\": \"3.2.3\" root 根目录 指定存放 gitbook 文件(除了book.json文件本身)的根目录 示例: \"root\": \".\" links 侧边栏链接 左侧导航栏添加链接,支持外链 示例; \"links\": { \"sidebar\": { \"我的网站\": \"https://snowdreams1006.cn/\" } } styles 自定义样式 自定义全局样式 示例: \"styles\": { \"website\": \"styles/website.css\", \"ebook\": \"styles/ebook.css\", \"pdf\": \"styles/pdf.css\", \"mobi\": \"styles/mobi.css\", \"epub\": \"styles/epub.css\" } plugins 插件 配置额外的插件列表,添加新插件项后需要运行 gitbook install 安装到当前项目. gitbook 默认自带5个插件,分别是: highlight 语法高亮插件 search 搜索插件 sharing 分享插件 font-settings 字体设置插件 livereload 热加载插件 后续会介绍一些常用插件,如需获取更多插件请访问官网插件市场 示例: \"plugins\": [ \"github\", \"pageview-count\", \"mermaid-gb3\", \"-lunr\", \"-search\", \"search-plus\", \"splitter\", \"-sharing\", \"sharing-plus\", \"expandable-chapters-small\", \"anchor-navigation-ex\", \"edit-link\", \"copy-code-button\", \"chart\", \"favicon-plus\", \"donate\" ] pluginsConfig 插件配置 安装插件的相应配置项,具体有哪些配置项是由插件本身提供的,应访问插件官网进行查询. \"pluginsConfig\": { \"github\": { \"url\": \"https://github.com/snowdreams1006/snowdreams1006.github.io\" }, \"sharing\": { \"douban\": true, \"facebook\": false, \"google\": false, \"hatenaBookmark\": false, \"instapaper\": false, \"line\": false, \"linkedin\": false, \"messenger\": false, \"pocket\": false, \"qq\": true, \"qzone\": true, \"stumbleupon\": false, \"twitter\": false, \"viber\": false, \"vk\": false, \"weibo\": true, \"whatsapp\": false, \"all\": [ \"facebook\", \"google\", \"twitter\", \"weibo\", \"instapaper\", \"linkedin\", \"pocket\", \"stumbleupon\" ] }, \"edit-link\": { \"base\": \"https://github.com/snowdreams1006/snowdreams1006.github.io/blob/master\", \"label\": \"编辑本页\" }, \"chart\": { \"type\": \"c3\" }, \"favicon\": \"/images/favicon.ico\", \"appleTouchIconPrecomposed152\": \"/images/apple-touch-icon-precomposed-152.png\", \"output\": \"_book\", \"donate\": { \"wechat\": \"/images/wechat.jpg\", \"alipay\": \"/images/alipay.jpg\", \"title\": \"赏\", \"button\": \"捐赠\", \"alipayText\": \"支付宝\", \"wechatText\": \"微信\" } } structure 目录结构配置 指定README.md,SUMMARY.md,GLOSSARY.md 和 LANGS.md 文件名称. 配置项 描述 structure.readme readme 文件名(默认值是 README.md) structure.summary summary 文件名(默认值是 SUMMARY.md) structure.glossary glossary 文件名(默认值是 GLOSSARY.md) structure.languages languages 文件名(默认值是 LANGS.md) pdf 配置 定制 pdf 输出格式,可能需要安装 ebook-convert 等相关插件 配置项 描述 pdf.pageNumbers 添加页码(默认值是 true ) pdf.fontSize 字体大小(默认值是 12 ) pdf.fontFamily 字体集(默认值是 Arial ) pdf.paperSize 页面尺寸(默认值是 a4 ),支持a0,a1,a2,a3,a4,a5,a6,b0,b1,b2,b3,b4,b5,b6,legal,letter pdf.margin.top 上边界(默认值是 56 ) pdf.margin.bottom 下边界(默认值是 56 ) pdf.margin.left 左边界(默认值是 62 ) pdf.margin.right 右边界(默认值是 62 ) 电子书封面照片 cover.jpg 和 cover_small.jpg,后续会详细说明. GLOSSARY.md 词汇表文件[可选] 词汇表文件,用于全书的专业词汇解释说明,比如鼠标悬停在专业词汇上会有相应提示. 语法格式: ## + ` +专业词汇` 学习 gitbook 前最好先学习下markdown和git,你知道他们的用途吗? 示例: ## markdown 简洁优雅的排版语言,简化版的 `HTML`,加强版的 `TXT`,详情请参考 [https://snowdreams1006.github.io/markdown/](https://snowdreams1006.github.io/markdown/) ## git 分布式版本控制系统,详情请参考 [https://snowdreams1006.github.io/git/](https://snowdreams1006.github.io/git/) LANGS.md 语言文件[可选] 支持国际化编写图书,一种语言一个单独子目录,同样地,将语言文件放到根目录下. 示例: * [English](en/) * [French](fr/) * [Español](es/) 章节小结 开发初始阶段运行 gitbook init 命令按照 SUMMARY.md 文件内容自动创建对应目录结构,编写各自文件内容后运行 gitbook serve 启动本地服务实时预览效果. 开发到一定程度后打算发布服务,再运行 gitbook build 输出到 _book/ 目录,别忘了配置 book.json 文件,然后就可以将 _book/ 文件夹整个扔到 nginx 等静态服务器上,这样就能联网访问你的电子书了. 是不是很简单,后续还会有如何发布与导出等相关教程,今天先到这里,下次见! © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"myGitbook/experience/gitbook-editor.html":{"url":"myGitbook/experience/gitbook-editor.html","title":"gitbook-editor 编辑器操作","keywords":"","body":"gitbook-editor 编辑器操作 亲测,目前已不再支持旧版 gitbook-editor 编辑器,而官网也没有相应的新版编辑器,如果哪位找到了新版编辑器,还望告知! 现在注册 gitbook 账号会默认重定向到 新版官网,而 旧版官网 的账号应该是可以正常使用的,前提是你必须之前注册过. 遗憾的是,最新注册的账号是无法使用 gitbook-editor 编辑器,不能登录到 gitbook ,也无法同步 github ,充其量只能算本地的 markdown 编辑器,所以这一节不再介绍了. 如果有兴趣了解 gitbook-editor 编辑器的基本使用,请参考 gitbook editor 编辑器. © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"myGitbook/experience/gitbook-com.html":{"url":"myGitbook/experience/gitbook-com.html","title":"gitbook.com 官网操作","keywords":"","body":"gitbook.com 官网操作 gitbook 官网是官方提供的图书托管的在线平台,分为新版官网(需要FQ) https://www.gitbook.com/ 和旧版官网(无需FQ) https://legacy.gitbook.com 两个网站. 目前均正常提供服务,但令人遗憾的是,两个网站的信息相互独立,而且现在注册的账号默认只能在新版官网中使用,而新版官网的访问速度简直比 github 还要慢,所以国内用户在线访问你的电子书真的需要点技术手段了! 本文主要介绍 www.gitbook.com 官网的基本使用,而 legacy.gitbook.com 网站我就算是想介绍也没有账号测试啊. \"巧妇难为无米之炊\",明明你就在那里,可我却什么也做不了. 先大概说一下 gitbook.com 网站的一些个人总结吧. gitbook.com 提供收费和免费服务,有点像早期的 github ,免费账号只能创建一个私有的命名空间,其他命名空间只能是公开的,这里的命名空间可以理解为一本书. 这一点是不是有点像早期的 github.com?免费账号无法创建私有仓库,只能是公开仓库. (现在 github.com 已被微软收购,目前可以创建无限量的私有仓库了!) 再说 gitbook 的账号问题,像 github 一样提供用户名和邮箱登录方式,他们的用户名都可以作为二级域名,比如我的用户名是snowdreams1006,那么我的 gitbook 第一本电子书网址就是 https://snowdreams1006.gitbook.io/index/ ,再看一下我的 github 个人网址 https://snowdreams1006.github.io/ ,这两个是不是很类似?! 如果不仔细看的话,八成你会觉得一样,一个是gitbook.io,另一个是github.io. 所以我严重怀疑他俩是不是有着不为人知的私密关系,太多的相似性,鼓励分享,限制私有等等特点. 无图无真相,趁着这次教程顺便将 github 个人网站项目同步到 gitbook 电子书项目了,这样的好处是本地只需要推送到 github ,自动更新 github.io 网站(利用的是github 静态网站托管服务) ,然后再自动同步到 gitbook.io 网站. 是不是很神奇,一份源码,两个官网! gitbook : https://snowdreams1006.gitbook.io/ github : https://snowdreams1006.github.io/ 注册并登陆 gitbook.com 注册信息主要包括用户名和邮箱,还有一些其他信息,没什么特殊的注意事项. 访问 https://www.gitbook.com/ 需要 FQ 新建命名空间(电子书) 注册账后后会默认生成一个私有的命名空间,因为并不打算将私有电子书托管到 gitbook,所以接下来直接将其转变成公开电子书进行演示. 个性性配置 标题和图片 主题颜色和页面反馈 观众 观众指的是当前电子书面向的受众是谁,公开的和私有的的区别以及设置是否被谷歌搜索收录. 域名 默认域名是 https://snowdreams1006.gitbook.io/,如果需要自定义域名,请保证 dns 能够正确解析到该网站. url 设置的命名空间是 index,因此最终访问路径是 https://snowdreams1006.gitbook.io/index/ 整合 gitbook 默认提供4种整合方式,在下孤陋寡闻只了解 github ,其余三种没接触过,暂不涉及. 选择 github 进行整合 登录 github 并授权 选择列出公开的仓库,然后输入用户名和密码进行登录并授权. 选择目标仓库 授权成功后会列出当前 github 账号下全部的公开仓库,选择目标仓库并点击下一步. 这里以 snowdreams1006.github.io 公开仓库为例,因为该仓库是本人官网源码项目. 同步内容 选择同步分支 根据实际情况选择同步分支,因为我一般是直接推送到 master 分支,所以 master 分支是个人网站的维护分支,因此这一步我选择的是 master. 选择同步内容 选择同步内容的方式,是从 github 同步到 gitbook,还是从 gitbook 同步到 github,因为我的项目已托管到 github ,所以初次同步内容选择的是 github --> gitbook. 显示 github 按钮 生成的电子书网站是否显示 github 按钮,作用是点击该按钮会跳转到关联的github 仓库上. 此时心里在想,万一点进 github ,随手就是一个 star 呢?哈哈! 等待内容导入 根据目标仓库的大小不同,导入内容是的时长自然也不一样,耐心等待... 上线 导入完成,电子书终于正式上线了! 现在赶紧分享一下好消息吧,访问 https://.gitbook.io/ 在线阅读! 小结 本文以如何集成 github 为例,演示了 gitbook.com 发布电子书的基本流程,由于 gitbook 电子书内容来自于 github 项目,因此我们只要更新 github 仓库,我们的 gitbook 电子书网站自然也就相应更新了! gitbook 是 markdown 和 github 的完美结合体,借助 gitbook.com 官网我们很容易发布并托管电子书. 美中不足的是,国内无法正常访问 gitbook.com ,因此并不是很推荐将电子书发布到 gitbook.com 网站. 现在国内也有类似的产品,有一种产品叫做 看云,还不错! 后续还会介绍 gitbook 如何结合 github 发布个人网站,欢迎继续关注 gitbook 系列教程! 如何打造免费的个人官网,想了解 https://snowdreams1006.github.io/ 背后的故事吗? © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"myGitbook/advance/advance.html":{"url":"myGitbook/advance/advance.html","title":"高级进阶","keywords":"","body":"高级进阶 不论是 gitbook-cli 命令行还是 gitbook editor 编辑器都离不开 gitbook 命令的操作使用,所以再次了解下常用命令. 注意 gitbook-cli 是 gitbook 的脚手架工具,是 gitbook 的扩展功能,同时着管理 gitbook. 查看 gitbook 帮助信息 语法格式: gitbook --help 示例: $ gitbook --help Usage: gitbook [options] [command] Options: -v, --gitbook [version] specify GitBook version to use -d, --debug enable verbose error -V, --version Display running versions of gitbook and gitbook-cli -h, --help output usage information Commands: ls List versions installed locally current Display currently activated version ls-remote List remote versions available for install fetch [version] Download and install a alias [folder] [version] Set an alias named pointing to uninstall [version] Uninstall a version update [tag] Update to the latest version of GitBook help List commands for GitBook * run a command with a specific gitbook version $ gitbook ls 列出本地安装版本 语法格式: gitbook ls 示例: # 列出本地已安装 `gitbook` 版本 $ gitbook ls gitbook current 列出当前使用版本 语法格式: gitbook current 示例: # 列出当前正在使用的 `gitbook` 版本 $ gitbook current gitbook ls-remote 列出远程可用版本 语法格式: gitbook ls-remote 示例: # 列出远程可用的 `gitbook` 版本 $ gitbook ls-remote gitbook fetch 安装指定版本 语法格式: gitbook fetch [version] 示例: # 下载并安装指定的 `gitbook` 版本 $ gitbook fetch 2.6.9 gitbook alias 指定文件夹别名 语法格式: gitbook alias [folder] [version] 示例: # 下载并安装指定的 `gitbook` 版本 $ gitbook alias /Users/sunpo/Desktop/book/gitbook/ 1.0.0 gitbook uninstall 卸载指定版本 语法格式: gitbook uninstall [version] 示例: # 卸载指定的 `gitbook` 版本 $ gitbook uninstall 2.6.9 gitbook update 更新指定版本 语法格式: gitbook update [tag] 示例: # 默认更新到最新的 `gitbook` 版本 $ gitbook update # 更新到指定的 `gitbook` 版本 $ gitbook update 2.6.9 列出 gitbook 可用命令 语法格式: gitbook help 示例: $ gitbook help build [book] [output] build a book --log Minimum log level to display (Default is info; Values are debug, info, warn, error, disabled) --format Format to build to (Default is website; Values are website, json, ebook) --[no-]timing Print timing debug information (Default is false) serve [book] [output] serve the book as a website for testing --port Port for server to listen on (Default is 4000) --lrport Port for livereload server to listen on (Default is 35729) --[no-]watch Enable file watcher and live reloading (Default is true) --[no-]live Enable live reloading (Default is true) --[no-]open Enable opening book in browser (Default is false) --browser Specify browser for opening book (Default is ) --log Minimum log level to display (Default is info; Values are debug, info, warn, error, disabled) --format Format to build to (Default is website; Values are website, json, ebook) install [book] install all plugins dependencies --log Minimum log level to display (Default is info; Values are debug, info, warn, error, disabled) parse [book] parse and print debug information about a book --log Minimum log level to display (Default is info; Values are debug, info, warn, error, disabled) init [book] setup and create files for chapters --log Minimum log level to display (Default is info; Values are debug, info, warn, error, disabled) pdf [book] [output] build a book into an ebook file --log Minimum log level to display (Default is info; Values are debug, info, warn, error, disabled) epub [book] [output] build a book into an ebook file --log Minimum log level to display (Default is info; Values are debug, info, warn, error, disabled) mobi [book] [output] build a book into an ebook file --log Minimum log level to display (Default is info; Values are debug, info, warn, error, disabled) $ gitbook build 构建电子书 语法格式: gitbook build [book] [output] 示例: # 默认输出到 `_book/` 目录 $ gitbook build # 指定输出目录 `/Users/sunpo/Desktop/book/` $ gitbook build ./ /Users/sunpo/Desktop/book/ # 指定输出格式 `json` $ gitbook build --format=json gitbook serve 启动本地服务器 语法格式: gitbook serve [book] [output] 示例: # 默认服务端口: `4000`,热部署端口: `35729` $ gitbook serve # 指定输出目录 `/Users/sunpo/Desktop/book/` $ gitbook serve ./ /Users/sunpo/Desktop/book/ # 指定服务端口: `5000` 和热部署端口: `45729` $ gitbook serve --port=5000 --lrport=45729 gitbook install 安装插件 语法格式: gitbook install [book] 示例: # 安装当前项目所需插件 $ gitbook install # 安装指定项目所需插件 `/Users/sunpo/Desktop/gitbook-demo/` $ gitbook install /Users/sunpo/Desktop/gitbook-demo/ # 安装当前项目所需插件且指定日志输出级别: `debug` $ gitbook install --log=debug gitbook parse 解析电子书 语法格式: gitbook parse [book] 示例: # 解析并输出当前项目的 `debug` 级别日志信息 $ gitbook parse # 解析并输出指定项目的 `/Users/sunpo/Desktop/gitbook-demo/` 的 `debug` 级别日志信息 $ gitbook parse /Users/sunpo/Desktop/gitbook-demo/ # 解析并输出当前项目的 `info` 级别日志信息 $ gitbook parse --log=info gitbook pdf 输出 PDF 电子书 语法格式: gitbook pdf [book] [output] 示例: # 默认输出到当前项目 $ gitbook pdf # 指定输出文件 `/Users/sunpo/Desktop/book.pdf` $ gitbook pdf ./ /Users/sunpo/Desktop/book.pdf # 指定输出日志级别: `debug` $ gitbook pdf --log=debug 可能需要安装 ebook-convert 相关插件,详情见相关系列教程. gitbook epub 输出 epub 电子书 语法格式: gitbook epub [book] [output] 示例: # 默认输出到当前项目 $ gitbook epub # 指定输出文件 `/Users/sunpo/Desktop/book.epub` $ gitbook epub ./ /Users/sunpo/Desktop/book.epub # 指定输出日志级别: `debug` $ gitbook epub --log=debug 可能需要安装 ebook-convert 相关插件,详情见相关系列教程. gitbook mobi 输出 mobi 电子书 语法格式: gitbook mobi [book] [output] 示例: # 默认输出到当前项目 $ gitbook mobi # 指定输出文件 `/Users/sunpo/Desktop/book.mobi` $ gitbook mobi ./ /Users/sunpo/Desktop/book.mobi # 指定输出日志级别: `debug` $ gitbook mobi --log=debug 可能需要安装 ebook-convert 相关插件,详情见相关系列教程. © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"myGitbook/advance/plugin.html":{"url":"myGitbook/advance/plugin.html","title":"插件介绍","keywords":"","body":"插件介绍 插件是 gitbook 的扩展功能,很多炫酷有用的功能都是通过插件完成的,其中插件有官方插件和第三方插件之分. 推荐官方插件市场 https://plugins.gitbook.com/ 寻找或下载相应的插件. 当然也可以去 npm 市场搜索 gitbook 插件,根据 gitbook 插件规范, gitbook-plugin- 是功能插件,gitbook-theme- 是主体插件. 如果没有按照规范命名,还是直接百度搜索吧! npm 安装后再 gitbook 安装 语法格式: npm install gitbook-plugin- 安装到本地: npm install gitbook-plugin-advanced-emoji 激活安装插件: 配置 book.json 中 plugins 节点 安装到项目: gitbook install 启动并测试测试: gitbook serve 示例: # 安装 gitbook-plugin-advanced-emoji 插件 $ npm install gitbook-plugin-advanced-emoji # 安装 gitbook-plugin-advanced-emoji 插件 $ gitbook install npm 安装速度慢的话,可以使用 cnpm 加速安装(npm install cnpm),表情插件下载地址 Advanced Emoji gitbook 直接安装 语法格式: gitbook install 激活安装插件: 配置 book.json 中 plugins 节点 安装到项目: gitbook install 启动并测试测试: gitbook serve 示例: # 安装 gitbook-plugin-advanced-emoji 插件 $ gitbook install 表情插件下载地址 Advanced Emoji 插件示例 Advanced Emoji表情列表 Advanced Emoji下载地址 book.json 配置文件: \"plugins\": [ \"advanced-emoji\" ] 安装插件: $ gitbook install 使用示例: :bowtie: :laughing: :relaxed: © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"myGitbook/advance/plugin-practical.html":{"url":"myGitbook/advance/plugin-practical.html","title":"实用插件","keywords":"","body":"实用插件 插件没有什么逻辑顺序,大家可以按照目录大纲直接定位到感兴趣的插件部分阅读即可. 更多插件正在陆续更新中,敬请期待... 最新更新插件 tbfed-pagefooter 版权页脚插件 gitalk 评论插件 search-plus 中文搜索插件 gitalk 评论插件并不是 gitbook 插件,因而集成方式和一般的插件安装方式不同! tbfed-pagefooter 版权页脚插件 如果希望将网页源码暴露出去并接受公众的监督校准的话,使用edit-link插件可以直接链接到源码文件. 链接地址: https://plugins.gitbook.com/plugin/tbfed-pagefooter 激活插件配置 在 book.json 中配置 tbfed-pagefooter 插件,详细说明请参考 tbfed-pagefooter 插件. 示例: { \"plugins\": [\"tbfed-pagefooter\"], \"pluginsConfig\": { \"tbfed-pagefooter\": { \"copyright\":\"&copy snowdreams1006\", \"modify_label\": \"文件修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" } } } 安装 tbfed-pagefooter 插件 示例: $ gitbook install 测试 tbfed-pagefooter 插件 启动本地服务后,每个页面的页脚处都会自动生成版权信息以及当前文件的最后更新时间. 功能慎用: 如果文档频繁更新适合生成最后更新时间,如果长时间不更新文档,岂不是最后更新时间还是几年前,给读者的感觉像是不再维护了一样! 示例: $ gitbook serve disqus 评论插件 discus 是一款集成评论的插件,可以为静态网站添加动态评论,让你的网站动起来! 遗憾的是,discus 插件只有 FQ 才能正常使用,暂时没找到其他较好的替代方案. 注册 disqus.com 账号 gitbook 集成 disqus 插件中最重要的配置项就是注册 disqus.com 网站唯一标识. 注册并绑定域名 如果没有注册账号请先注册,否则直接登录,当然也支持第三方账号登录(我使用的是谷歌账号). 人机验证时,选出符合条件的全部图形,直到没有新的图形为止,这一点和国内的静态图片验证是不同的! 选择安装 disqus 插件(I want to install Disqus on my site),接下来会绑定集成网站的域名. 接下来设置网站的相关信息,其中网站名称(snodreams1006)是唯一标示,接下来集成到 gitbook 用的就是这个简短名称,而分类和语言按照实际情况选择即可. 选择服务类型 disqus 网站提供的服务类型,有基础班(basic),加强版(plus),专业版(pro)和免费版(free). 每个版本计划有不同的收费标准以及相应的服务,可以根据实际情况选择适合自己的服务类型. 接下来以免费版为例进行有关演示 安装并配置 disqus 到网站 估计是这些网站提供了默认的集成方式,这里并没看到 gitbook 相关的网站,因此选择最后一个自定义网站. 填写网站的基本信息,其中网站缩写名称仍然是 snowdreams1006,网址填写 https://snowdreams1006.github.io/ ,至于其他信息根据实际情况填写即可. 至此 disqus.com 网站配置完成,接下来我们配置 gitbook 集成 disqus 插件. 安装并配置 disqus 插件 上一步我们已经获取到唯一的标识: snowdreams1006 ,接下来可以继续配置 disqus 插件了. 链接地址: https://plugins.gitbook.com/plugin/disqus 激活插件配置 在 book.json 中配置 disqus 插件,根据实际情况修改成自己的缩写名称(shortName). 示例: { \"plugins\": [\"disqus\"], \"pluginsConfig\": { \"disqus\": { \"shortName\": \"snowdreams1006\" } } } 安装 disqus 插件 示例: $ gitbook install 测试 disqus 插件 示例: $ gitbook serve 正常情况下(FQ),disqus 插件已经成功集成到 gitbook 网站了,因此推送到实际服务器上时看到的效果是这样的. 如果你不具备条件(FQ),那么你看到的仍然是这样的. gitalk 评论插件 本篇文章发表在开源中国后得到网友 @八一菜刀 的评论,让我推荐了gitalk 评论插件,初始使用了一下,确实不错,因此在这里更新下. 上述 disqus 评论插件虽然比较好用,但是注册是在 disqus.com 官网,需要特殊手段才能访问,即便成功配置了国内一般也是访问不到的,因此功能相当鸡肋. gitalk 评论插件解决了这一痛点,利用 github 的开发者接口授权,将讨论区的 issue 变成评论区,和 github 结合的如此紧密,适合用源码托管到 github 这类情况. 先混个脸熟,看一下 gitalk 官网 是如何介绍自己的呢. 看着效果确实不错,并且评论区的内容直接作为 github 仓库的 issue,这么好的想法我咋没想到呢! 好了,现在让我们开始集成到我们自己的项目中,遇到新鲜事物,当然先要参考官网介绍了. 申请 GitHub Application 授权 登录 github 账号,点击 在线申请 授权应用. 看到这一步,想必读者已经有个大概印象了,gitalk 插件是利用 github 的开发者服务,进行授权进而调用 issue 相关接口从而显示评论功能. 这种由官网提供的开发者服务还是比较好的,至少感觉比手动模拟提交要靠谱些,更何况走的是 OAuth 授权模式. 比如第三方应用提供微信登录,走的也是 OAuth 协议,这里的第三方应用当然就是现在说的 Gitalk 插件,微信就是我们的 github . 新建应用,首页 url 和授权回调 url 填写相同的首页链接即可,其他情况自定义填写. 应用登记成功后会生成 token 令牌,clientId 和 clientSecret 需要重点保存下来,待会需要用到. 安装并集成到网站 在需要添加评论的页面,添加下述内容引入 gitalk 插件,其中参数来自我们上一步获取的 clientId 和 clientSecret . 默认应该添加到 .html 页面,当然也可以添加到 .md 页面,毕竟 markdown 语法也支持 html 标签. var gitalk = new Gitalk({ \"clientID\": \"clientId\", \"clientSecret\": \"clientSecret\", \"repo\": \"GitHub repo\", \"owner\": \"GitHub repo owner\", \"admin\": [\"GitHub repo admin\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); 稍微解释下参数的含义: \"clientID\" : [必选] GitHub Application Client ID \"clientSecret\" : [必选] GitHub Application Client Secret \"repo\" : [必选] GitHub repository \"owner\" : [必选] GitHub repository 所有者，可以是个人或者组织 \"admin\" : [必选] GitHub repository 的所有者和合作者 (对这个 repository有写权限的用户) \"id\" : [可选] 页面的唯一标识,默认值: location.href, 长度必须小于50,否则会报错! \"distractionFreeMode\": [可选] 类似 Facebook 评论框的全屏遮罩效果,默认值: false 上述配置只是最简配置,如果想要了解更多高级配置,请参考 官方文档 测试集成效果 按照上述安装步骤,将代码复制到首页(README.md)文件中,然后推送到 github ,体验下集成效果. 注意: 这里必须推送到服务器,因为申请应用时填写的域名是线上地址,因而本地测试是不会成功的,会报错,这一点和微信支付的回调地址类似. 示例: var gitalk = new Gitalk({ \"clientID\": \"3f62415a283d19cbd696\", \"clientSecret\": \"aed0e1db0620bf5d0e3a3f0225f801997ad74e58\", \"repo\": \"snowdreams1006.github.io\", \"owner\": \"snowdreams1006\", \"admin\": [\"snowdreams1006\"], \"id\": location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); 上述参数仅供参考,实际使用中请替换成自己的配置,不然你也没有我仓库的权限,肯定会报错的啊! 心心相念的 gitalk 评论区呢?是不是哪里配置错了,为啥没有出来? 别急,要淡定,看一下提示说\"未找到的 Issue 进行评论,请联系 @snowdreams1006 初始化创建\",既然如此,那我们就操作一下吧! 点击下方的按钮 使用 Github登录 ,会跳转到相应的仓库,然后按照提示确定. 再次返回首页,刷新一下看看发生什么神奇的事情了? 终于集成了评论功能,而且还支持 markdown 格式的评论呢! 进一步思考 确实不错,心中自然是欣喜万分,但别高兴太早了,因为你会发现其他页面并没有评论区,也很好理解,我们目前仅仅在首页(README.md) 集成了 gitalk 插件,也就是说使用 gitbook build 输出的 index.html 首页才支持评论区,其他页面没有插入上述代码,自然是没有评论区功能的啊! 那如果想要实现全网站的所有页面都集成评论区功能,应该怎么办呢? 百度搜索了一下,并没有找到优雅的解决方案,如果有人能够提供更好的解决方案,还望不吝赐教,在此谢过. 既然网上找不到优雅的解决方案,那寻求专业人士的帮助也是一种好办法,我去哪找 gitalk 的使用者呢? 聪明的你或许已经想到了,解铃还须系铃人,当然是向推荐给我插件的大牛提问了! 他确实提供了一种思路,以下是网友@八一菜刀原话: 文档里面我用的是tbfed-pagefooter插件，不过我是在本地使用gitbook install后重写了该插件的js，无非就是在js里面加一段Gitalk的调用代码，这样使用gitbook build命令的时候，所有的页面都会有Gitalk的评论调用 人家既然已经提供了思路,不太好意思继续麻烦人家要源码,既然如此,那就自己动手吧! tbfed-pagefooter 插件很熟悉,一般是用于注明版权以及文章的修订时间的,而且作用于每个页面,这一点就满足了集成 gitalk 相关代码的基本要求. 大体方向确定后,目前就是解决如何在 tbfed-pagefooter 插件构建的相关生命周期内顺便执行我们的代码? 正常当前项目安装 tbfed-pagefooter 插件后应该存放于 /node_modules/gitbook-plugin-tbfed-pagefooter 目录,大致看一下插件的项目结构. gitbook-plugin-tbfed-pagefooter ├── LICENSE ├── README.md ├── assets │ └── footer.css ├── index.js └── package.json 1 directory, 5 files $ 为了基本看懂项目文件作用,特意去看了下 gitbook 插件开发文档,目标锁定在 index.js . 截取重要片段,原来是电子书构建前动态增加了 html 片段啊,这就好办了! hooks: { 'page:before': function(page) { var _label = '最后更新时间: ', _format = 'YYYY-MM-DD', _copy = 'powered by snowdreams1006' if(this.options.pluginsConfig['tbfed-pagefooter']) { _label = this.options.pluginsConfig['tbfed-pagefooter']['modify_label'] || _label; _format = this.options.pluginsConfig['tbfed-pagefooter']['modify_format'] || _format; var _c = this.options.pluginsConfig['tbfed-pagefooter']['copyright']; _copy = _c ? _c + ' all right reserved，' + _copy : _copy; } var _copy = ''+_copy+''; var str = ' \\n\\n' + _copy + '' + _label + '\\n' + _for26pmt + '\\n'; str += '\\n\\n'+ '\\n\\n'+ '\\n\\n'+ '\\n\\n'; page.content = page.content + str; return page; } } 看懂基本原理后顺便修改了版权说明以及修订时间格式,然后追加了集成 gitalk 的相关代码. 这里为了方便修改 gitalk 配置,特意将相关配置项单独托管到 github 专门的 gitalk-config.js 文件. 至于配置文件的内容,并没什么特殊之处,还是顺便贴一下吧! var gitalk = new Gitalk({ \"clientID\": \"3f62415a283d19cbd696\", \"clientSecret\": \"aed0e1db0620bf5d0e3a3f0225f801997ad74e58\", \"repo\": \"snowdreams1006.github.io\", \"owner\": \"snowdreams1006\", \"admin\": [\"snowdreams1006\"], \"id\": window.location.pathname, \"distractionFreeMode\": false }); gitalk.render(\"gitalk-container\"); 至此,之后再本地构建电子书时(gitbook build),gitbook-plugin-tbfed-pagefooter 自然会顺便帮我们运行集成 gitalk 的相关代码,这才是相对来说比较优雅的做法. 当然也不一定非要借助 gitbook-plugin-tbfed-pagefooter 插件帮忙,也可以借助别的插件进行集成,甚至自己写个更好的插件. 小结 gitalk 插件相对 disqus 插件来说,更符合基本国情,只不过默认的集成方式只能一个页面一个页面去集成,当数量比较多时,工作量不敢想象. 因此,通过 gitbook 插件开发的方式,在源码文件输出为目标文件时加入相关集成代码,相当于手写100条输出语句和循环写100条输出语句. 其实本质上并没有改变什么,仍然是集成到每个页面中,但是简化了人工操作的工作量就是效率的提升. 如果有更高效更优雅的集成方式,欢迎大家一起探讨. edit-link 编辑链接插件 如果希望将网页源码暴露出去并接受公众的监督校准的话,使用edit-link插件可以直接链接到源码文件. 链接地址: https://plugins.gitbook.com/plugin/edit-link 激活插件配置 在 book.json 中配置 edit-link 插件,详细说明请参考 edit-link 插件. 示例: { \"plugins\": [\"edit-link\"], \"pluginsConfig\": { \"edit-link\": { \"base\": \"https://github.com/snowdreams1006/snowdreams1006.github.io/blob/master\", \"label\": \"编辑本页\" } } } 安装 edit-link 插件 示例: $ gitbook install 测试 edit-link 插件 如果不能正常跳转到源码文件,多次试验后重新更改 edit-link.base 节点内容,重新 gitbook serve 即可正常跳转源码文件. 示例: $ gitbook serve github 插件 添加 github 图标链接,方便直接跳转到 github 指定仓库. 链接地址: https://plugins.gitbook.com/plugin/github 激活插件配置 在 book.json 中配置 github 插件,详细说明请参考 github 插件. 示例: { \"plugins\": [\"github\"], \"pluginsConfig\": { \"github\": { \"url\": \"https://github.com/snowdreams1006/snowdreams1006.github.io\" } } } 安装 github 插件 示例: $ gitbook install 测试 github 插件 示例: $ gitbook serve search-plus 中文搜索插件 默认的 search 搜索插件是不支持中文搜索的,而 search-plus 则功能更强大些,两者不能共存,需要禁用或移除 search 插件. 链接地址: https://plugins.gitbook.com/plugin/search-plus 激活插件配置 在 book.json 中配置 github 插件,详细说明请参考 github 插件. 示例: { \"plugins\": [ \"-lunr\", \"-search\", \"search-plus\" ] } 安装 search-plus 插件 示例: $ gitbook install 测试 search-plus 插件 测试是否能够进行中文搜索,如果不能,请确保已移除默认的 \"lunr\" 和 \"search\" 插件. 示例: $ gitbook serve © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"myGitbook/advance/plugin-theme.html":{"url":"myGitbook/advance/plugin-theme.html","title":"主题插件","keywords":"","body":"主题插件 目前 gitbook 提供三类文档: Book 文档,API 文档和 FAQ 文档. 其中,默认的也是最常使用的就是 Book 文档,如果想要了解其他两种文档模式,需要引入相应的主题插件. 官方主题插件文档: https://toolchain.gitbook.com/themes/ Book 文档 theme-default 主题 插件地址: https://plugins.gitbook.com/plugin/theme-default theme-default 是 3.0.0 引入的默认主题,大多数插件针对的都是默认主题,如果切换到其他主题或者自定义主题,可能会造成某些情况下不兼容,甚至报错. 默认情况下,左侧菜单不显示层级属性,如果将 showLevel 属性设置为 true 可以显示层级数字. 示例: \"pluginsConfig\": { \"theme-default\": { \"showLevel\": true } } 效果: 默认情况下左侧菜单树不显示目录层级 开启层级显示设置后,左侧菜单树显示当前目录层级 theme-comscore 主题 插件地址: https://plugins.gitbook.com/plugin/theme-comscore default 默认主题是黑白的,而 comscore 主题是彩色的,即标题和正文颜色有所区分. 示例: \"plugins\": [ \"theme-comscore\" ] 效果: 默认情况下各级标题颜色均是黑色,不同级别的标题仅仅是大小区别. 设置 comscore 主题后,各级标题颜色不同,不仅仅是大小不同. API 文档 theme-api 插件 插件地址: https://plugins.gitbook.com/plugin/theme-api 如果文档本身是普普通文档模式,切换成 api 文档模式后并不会有太大变化,除非一开始就是接口文档,那样使用 theme-api 插件才能看出效果. 示例: { \"plugins\": [\"theme-api\"], \"pluginsConfig\": { \"theme-api\": { \"theme\": \"dark\" } } } 语法: 方法区 语法区 示例: 效果: 添加 api 相关方法后的文档效果,正常会两列显示并在右上角增加语言切换工具. FAQ 文档 theme-faq 插件 插件地址: https://plugins.gitbook.com/plugin/theme-faq theme-faq 可以帮助我们构建问答中心,预设好常见问题以及相应答案模式,同时为了方便搜索到问题或答案,一般需要搜索插件的配合. 示例: { \"plugins\": [ \"theme-faq\", \"-fontsettings\", \"-sharing\", \"-search\", \"search-plus\" ] } 帮助中心没有工具栏,因此涉及到工具类的插件一律失效或主动移除,同时默认搜索插件也会失效. 语法: 增加文章间的关联 --- related: - some/other/page.md - another_related_article.md --- Content of my article! 在当前页面底部显示延伸阅读,支持 yaml 语法关联到其他页面. 增加头部 logo 新建 _layouts/website/page.html 文件,用于扩展当前主题插件来增加自定义 logo. 增加导航栏链接 新建 _layouts/website/page.html 文件,用于扩展当前主题插件来增加自定义导航栏链接. 示例: 新建 _layouts/website/page.html 文件,增加自定义 logo 和导航栏链接. 效果: 小结 本节主要讲解了常用的三种文档模式,其中 default 主题插件,适合一般的博客类网站或静态网站,api 主题插件适合接口文档的编写,faq 主题插件则适合帮助中心. 三种主题插件分别对应不同的应用场景,默认情况下使用的是 default 主题插件,平时介绍的大多数功能插件也大多适合这种主题,另外两种主题可能就不能很好兼容第三方插件,需要亲身体验. © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"myGitbook/advance/export.html":{"url":"myGitbook/advance/export.html","title":"导出电子书","keywords":"","body":"导出电子书 gitbook 既可以将源码文件单独输出,也可以仅输出单个文件,常见的导出电子书格式主要有三种(ePub, Mobi, PDF),而这三种格式都依赖于系统本身提供的 ebook-convert 工具. 安装依赖 如果直接运行 gitbook pdf 相关命令,可能会报错,提示需要安装 ebook-convert 插件,根据提示本地需要安装 calibre 软件,这样 gitbook 才能正常导出电子书. calibre 官网: https://calibre-ebook.com/ linux 系统 下载地址: https://calibre-ebook.com/download_linux 下载应用 $ sudo -v && wget -nv -O- https://download.calibre-ebook.com/linux-installer.sh | sudo sh /dev/stdin 配置软链接 $ sudo ln -s /usr/bin/nodejs /usr/bin/node mac 系统 下载地址: https://calibre-ebook.com/download_osx 下载应用 将 calibre.app 移动到应用程序文件,然后尝试是否能正常打开应用. 配置软链接 $ sudo ln -s ~/Applications/calibre.app/Contents/MacOS/ebook-convert /usr/bin 测试命令 $ ebook-convert --version 如果没有输出 ebook-convert 版本信息,可能需要配置环境变量. 配置封面 所有格式的电子书都可以配置自定义封面,在项目的根目录下提供 cover.jpg 和 cover_small.jpg 两种封面图片时,生成电子书会自动增加封面页. 当然你也可以使用 autocover 插件 自动生成封面,不过本人才疏学浅,几经尝试始终没有成功,如果有人成功了记得给我留言下哈! 封面的基本要求: cover.jpg 尺寸大小: 1800X2360 px,cover_small.jpg 尺寸大小: 200x262 px; 无边界 清晰可见的书名 任何重要的文字在小版本封面图片中也要清晰可见 更多封面相关规范请参考 https://toolchain.gitbook.com/ebook.html 基本命令 语法格式: gitbook pdf 或 gitbook epub 或 gitbook mobi 示例: # 生成 `pdf` 文件并输出 `debug` 级别日志 $ gitbook pdf ./ ./myBook.pdf --log=debug # 生成 `epub` 文件并输出 `debug` 级别日志 $ gitbook epub ./ ./myBook.epub --log=debug # 生成 `mobi` 文件并输出 `debug` 级别日志 $ gitbook mobi ./ ./myBook.mobi --log=debug 相信大家对 PDF 格式比较熟悉,其余两种格式只是不同电子书格式,因而需要相应软件支持. 生成 PDF 文件 示例: $ gitbook pdf 默认在当前项目的根目录下生成 book.pdf 文件名,如果配有封面,则首页显示封面,否则无封面. 生成 ePub 文件 示例: $ gitbook epub 默认在当前项目的根目录下生成 book.epub 文件名,如果配有封面,则首页显示封面,否则无封面. 生成 mobi 文件 示例: $ gitbook mobi 默认在当前项目的根目录下生成 book.mobi 文件名,如果配有封面,则首页显示封面,否则无封面. 小结 本节主要介绍了如何导出电子书,概括来说,首先系统需要安装 ebook-convert 工具,然后配置电子书封面,最后直接导出为目标格式(ePub, Mobi, PDF)进行输出. 随着电子书内容越来越多,生成电子书所花费的时间也越来越久,实属正常,耐心等待即可. 输出 PDF 文件并输出 debug 日志: gitbook pdf --log=debug © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"myGitbook/advance/publish.html":{"url":"myGitbook/advance/publish.html","title":"发布电子书","keywords":"","body":"发布电子书 输出目标文件 语法格式: gitbook build [book] [output] 默认情况下,gitbook 输出方式是静态网站,其实 gitbook 的输出方式有三种: website, json,和 ebook. 只不过另外两种不是很常用,更多情况下我们是使用静态网页搭建个人官网,或托管到第三方平台,或部署到私有云服务器,但不管怎么样,还是离不开生成这一步. 示例: # 默认输出格式: `website` $ gitbook build --format=website # 更改输出格式: `json` $ gitbook build --format=json # 更改输出格式: `ebook` $ gitbook build --format=ebook 默认情况下输出目录: _book/,整个项目的入口文件是: index.html 集成 github 网站 本教程的电子书源码和输出文件均托管到 github 网站,所以这里介绍下如何利用 Github Pages 静态网页服务与 gitbook 进行集成. 什么是 GitHub Pages ? Github Pages 是 github 网站推出的一种免费的静态网页托管服务,适合搭建静态的项目主页或个人官网. 其中,网站项目的源码直接托管在 github 仓库中,当仓库文件更新后,该仓库所关联的网站自动更新,从而实现了源码与官网的联动更新. 如果想了解更多详情,请参考官网: https://pages.github.com/ 怎么做 GitHub Pages ? 每个账号有且只有一个主页站点,但允许无限制多的项目站点. 啥是主页站点,项目站点又是啥? 别急,让我先举个例子看一下最终效果. 假如用户名: zhangsan 名下有四个公开仓库,一个仓库名叫做: zhangsan.github.io,另外三种分别是: project01,project02,project03 . 如果想要对外暴露上述四个仓库作为我们的静态网站,那么最终效果就是下面这样的. 主页站点: https://zhangsan.github.io 项目01站点: https://zhangsan.github.io/project01 项目02站点: https://zhangsan.github.io/project02 项目03站点: https://zhangsan.github.io/project03 注意将 zhangsan 替换成自己的 github 用户名,否则八成是打不开网站,除非真的有 zhangsan 这个用户. 其实上述规则很好理解,github 网站作为一个托管中心,有成千上万的用户在使用 github 并且每个用户的用户名都是唯一并且不同的,因此 *.github.io 通配符域名刚好充当命名空间. 可以预料的是,不仅仅有 .github.io 这种二级域名,说不定还有 api.github.io,docs.github.io 等等,毕竟只需要购买 *.github.io 通配符域名证书就可以支持任意多的二级域名了,感谢 github 赠送我们免费的 https 网站. 说到这里,不得不吐槽下 gitbook 的命名空间策略了,gitbook 也有自己的电子书托管服务,但访问地址是 .gitbook.io/ . 很显然,gitbook 没有区分主页站点和项目站点,相当于全部都是项目站点,缺少主次之分. 闲言少叙,既然知道了输入内容和输出效果,那么接下来的任务就是了解中间过程了,让我们一起探讨下怎么发布网站吧! 主页站点 创建 .github.io 公开仓库 前往 https://github.com/ 网站创建名为 .github.io 的公开仓库. 比如我的用户名是: snowdreams1006 ,那么我的主页站点仓库就是: snowdreams1006.github.io 创建首页 index.html 文件 不管是在线直接创建 index.html 还是克隆到本地创建 index.html ,最终的 .github.io 仓库一定要有 index.html 首页文件. 示例: # 克隆到本地 $ git clone https://github.com/username/username.github.io # 切换到项目 $ cd username.github.io # 创建 `index.html` 文件 $ echo \"Hello World\" > index.html # 推送到远程仓库 $ git add --all $ git commit -m \"Initial commit\" $ git push -u origin master 访问主页站点 https://username.github.io 打开浏览器,输入网址: https://username.github.io 访问主页站点,显示的内容正是我们刚刚提交的 index.html 文件内容. 如果没有正常显示,清除浏览器缓存强制刷新试试看! 项目站点 相比主页站点来说,项目站点命名比较随意了,作为静态网站不可或缺的文件仍然是 index.html. 创建首页 index.html 文件 创建首页文件并添加测试内容,方便待会在线访问项目站点测试是否部署成功. 设置 GitHub Pages 选项 点击仓库首页右上方设置(Settings)选项卡,往下翻到 GitHub Pages 选项,选择源码目录,根据实际情况选择源码来源于 master 分支还是其他分支或者docs/ 目录. 方便起见,选择第一个 master 分支即可,注意下面的主题和这一步的来源只能两者选其一,否则主题优先级更高! 访问主页站点 https://username.github.io/ 打开浏览器,输入网址: https://username.github.io/repository 访问项目站点,显示的内容正是我们刚刚提交的 index.html 文件内容. 如果没有正常显示,清除浏览器缓存强制刷新试试看! 如何集成 gitbook ? 我们已经知道 Github Pages 是提供静态网站的免费托管,而 gitbook 默认生成的内容就是静态网站,两者如何结合自然不用我多说了吧? gitbook 默认输出目录 _book/ 包括了静态网站所需的全部资源,其中就包括 index.html 首页文件. 因此我们只需要每次生成后将 _book/ 整个目录复制到项目根目录,那么推送到远程仓库时自然就是输出后静态网站了啊! 示例: # 生成静态网站 $ gitbook build # 复制到项目根目录 $ cp -r _book/* . # 添加到本地版本库 $ git add . $ git commit -m \"publish\" # 推送到远程仓库 $ git push origin master 现在登录 github 网站看一下静态网站是否成功上传以及访问主页站点或项目站点看一下最新内容是否成功渲染吧! 小结 本节我们学习 gitbook 有三种输出方式,其中默认的网页输出最为常用. 除此之外,还讲解了如何与 github pages 进行结合,从而实现源码和网站的自动更新维护. 如果源码没有托管到 github 这种第三方服务商,你也可以搭建自己的服务器,比如将 _book/ 目录全部扔到 nginx 服务器做静态资源服务器等. 毕竟,源码和输出内容都在你手中,想怎么玩还不是自己说了算? © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"java8/":{"url":"java8/","title":"java8新特性","keywords":"","body":"java8新特性 java8作为 java的一个重要版本,目前为大多数企业和个人所接受,了解其本身为我们提供了哪些改变有助于我们去解决实际问题,窥探其今后可能的发展方向. 接下来本教程将从java语言本身入手,结合笔者实际经验,带你了解常用的新特性以及日常工作中如何应用. 最好拥有一定的java基础,只有经历过痛苦的折磨才能感受到新特性的愉快 © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"java8/lambda.html":{"url":"java8/lambda.html","title":"lambda表达式","keywords":"","body":"lambda表达式 下面通过对比 java8 之前的普通实现和 java8 引入lambda 表达式的实现,帮助读者快速了解代码差异性,眼见为实,赶紧开始吧! 求给定数组最小值 public static void main(String[] args) { // 方法1: jdk8以前的实现 int[] nums = {33, 55, -55, 90, -666, 90}; int min = Integer.MAX_VALUE; for (int i : nums) { if (i 方法1体现的是命令式编程的思维,需要明确编程细节,如果细节拿捏不准,那么结果自然不对. 而方法2则是函数式编程,只关注目标和结果,忽略过程,思路清晰更容易理解. 小结 命令式编程 强调过程,注重如何实现的细节,一步错,满盘皆输! 函数式编程 关注结果,不在乎实现细节,分配任务让下属去处理! lambda 表达式 是函数式编程 的重要体现,简洁易于理解. 创建线程运行任务 public static void main(String[] args) { // 方法1: jdk8以前一般写法 new Thread(new Runnable() { @Override public void run() { System.out.println(\"ok\"); } }).start(); // 方法2: jdk8采用 lambda 表达式写法 new Thread(() -> System.out.println(\"ok\")).start(); } 从上例可以看出,这里的lambda 表达式 返回的是实现了指定接口的对象实例. 小结 lambda 表达式 实现指定接口方法并返回该接口实例对象 lambda 表达式 由输入和输出以及实现过程三部分组成,不在乎方法名. 初体验 // 定义只有一个方法的接口 interface TestInterface { int doubleNum(int i); } public static void main(String[] args) { // 方法1: 实现doubleNum方法,实现过程是输入i返回 i*2,最终得到实现了该接口的实例对象 TestInterface i1 = i -> i * 2; System.out.println(i1.doubleNum(1)); // 方法2: 多个入参时需要用()包围起来,只有一个入参时可省略,见方法1 TestInterface i2 = (i) -> i * 2; System.out.println(i2.doubleNum(1)); // 方法3: 入参可指定类型,没有明确指定类型时自动推断,如方法1和方法2均未指定入参类型 TestInterface i3 = (int i) -> i * 2; System.out.println(i3.doubleNum(1)); // 方法4: 实现体不止一句代码时,需要用{}包围起来,并在实现体内部处理出参,当然实际情况中也可能并没有返回值 TestInterface i4 = (int i) -> { System.out.println(\"regular lambda expression\"); return i * 2; }; System.out.println(i4.doubleNum(1)); } lambda 表达式 实现的接口有且仅有一个要实现的接口,体现了 java 的单一职责原则. 这一点也很好理解,如果不止一个接口需要实现,那实现的具体是哪一个方法呢?所以这样的情况在 ide 中一般都会有相应的提示. 此外,java8 引入新的注解 @FunctionInterface 来支持lambda 表达式,也可用于ide 自动提示. 而上例中,我们的接口并没有标注过该注解,不是也能正常工作吗?是的,确实是这样的,所以@FunctionInterface 只是声明式注解,并没有实际作用,不过实际工作中最好加上@FunctionInterface 该注解,万一以后有用呢? 小结 lambda 表达式 实现的接口需要有 @FunctionInterface 注解,并且要实现的方法有且仅有一个. 日常工作中也应该学习单一职责原则,接口设计要足够细,方便使用lambda 表达式,术业有专攻. 利用接口多继承特性,做到接口的集大成者. © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"java8/functionInterface.html":{"url":"java8/functionInterface.html","title":"函数式接口","keywords":"","body":"函数式接口 接口允许有默认实现 @FunctionalInterface interface TestInterface { // 要实现的方法 int doubleNum(int i); // 默认实现方法 default int add(int x, int y) { return x + y; } } public static void main(String[] args) { // lambda 表达式实现doubleNum方法并返回该接口的实例对象 TestInterface interface1 = i -> i * 2; // 调用接口的doubleNum方法和add方法 System.out.println(interface1.doubleNum(1)); System.out.println(interface1.add(1,2)); } 小结 值得说明的是,默认接口实现应该是对所有的实现类来说有价值的默认实现,接口是对行为的规范,对接口的定义必须相当谨慎.那我们熟悉的 List 来说,查询源码,搜索@since发现,大多 api 是1.2,1.3,1.4...竟然没有,而1.8新增的也是 default 接口,为什么? 因为增加接口就需要实现,所以轻易不会新增接口,但是 jdk8允许有默认接口实现,这就解决了需要重新实现接口方法的问题,这也是为什么我们认为这是 jdk8的重大更新; 这里需要说明下 jdk8新增了默认接口实现方法,我们称之为默认接口实现方法,而 lambda 表达式实现的接口方法,我们称之为默认方法吧; 默认接口实现方法可以认为是内部实现类,也可以使用 this; @FunctionalInterface interface Interface1 { int doubleNum(int i); default int add(int x, int y) { System.out.println(this.doubleNum(1)); return x + y; } } public static void main(String[] args) { Interface1 interface1 = i -> i * 2; System.out.println(interface1.add(1, 2)); } 接口多继承时,需要指明具体覆盖哪一个默认实现方法 @FunctionalInterface interface Interface1 { int doubleNum(int i); default int add(int x, int y) { System.out.println(\"Interface1 add\"); return x + y; } } @FunctionalInterface interface Interface2 { int doubleNum(int i); default int add(int x, int y) { System.out.println(\"Interface2 add\"); return x + y; } } @FunctionalInterface interface Interface3 extends Interface2, Interface1 { @Override default int add(int x, int y) { System.out.println(\"Interface3 add\"); return Interface1.super.add(x, y); } } public static void main(String[] args) { Interface3 interface3 = i -> i * 2; System.out.println(interface3.add(1, 2)); } 接口真的需要吗,有没有更简洁的方法 public class MyMoneyDemo { public static void main(String[] args) { MyMoney myMoney = new MyMoney(9999999); myMoney.printMoney(i -> new DecimalFormat(\"#,###\").format(i)); } } interface IMoneyFormat { String format(int money); } class MyMoney { private final int money; public MyMoney(int money) { this.money = money; } public void printMoney(IMoneyFormat moneyFormat) { System.out.println(\"MyMoney is \" + moneyFormat.format(this.money)); } } 以上例子,定义一个接口,然后 lambda 表达式生成接口的实现类,从而实现接口功能; 其实不难发现,lambda 表达式实现的过程中,我们并不关心接口的参数以及方法名,我们仅仅关心入参和出参,那让我们进一步简化吧; public class MyMoneyDemo { public static void main(String[] args) { MyMoney myMoney = new MyMoney(9999999); myMoney.printMoney(i -> new DecimalFormat(\"#,###\").format(i)); } } class MyMoney { private final int money; public MyMoney(int money) { this.money = money; } public void printMoney(Function moneyFormat) { System.out.println(\"MyMoney is \" + moneyFormat.apply(this.money)); } } 这就是函数式编程,不必定义那么多接口,此外函数式接口还支持链式操作; public class MyMoneyDemo { public static void main(String[] args) { MyMoney myMoney = new MyMoney(9999999); Function moneyFormat = i -> new DecimalFormat(\"#,###\").format(i); myMoney.printMoney(moneyFormat.andThen(s -> \"RMB: \" + s)); } } class MyMoney { private final int money; public MyMoney(int money) { this.money = money; } public void printMoney(Function moneyFormat) { System.out.println(\"MyMoney is \" + moneyFormat.apply(this.money)); } } 小结 接口 输入参数 返回类型 说明 Predicate T boolean 断言 Consumer T / 消费一个数据 Function T R 输入T输出R的函数 Supplier / R 提供一个数据 UnaryOperator T T 一元函数(输出输入类型相同) BiFunction R 两个输入的函数 BinaryOperator T 两元函数(输出输入类型相同) © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"tools/":{"url":"tools/","title":"工具资源","keywords":"","body":"工具资源 总结记录下使用过程中值得推荐的软件,正所谓\"授人以鱼不如授人以渔\",有些博主总结的更加全面有用,在此也分享下. 工具资源 快典小报 快典小报，每周不定期精选优质内容！ Chrome插件英雄榜 Chrome插件英雄榜, 为优秀的Chrome插件写一本中文说明书, 让Chrome插件英雄们造福人类~ Github星聚弃疗榜(Github星爆沙雕榜) 为Github创意项目写一本推荐书，让Github优秀项目造福人类~ IRM Markdowner | 微信排版编辑器 微信公众号格式化工具: https://github.com/hadeshe93/irm-markdowner WeChat Format | 微信公众号排版编辑器 微信公众号排版编辑器: https://github.com/lyricat/wechat-format 微信公众号格式化工具 在线Markdown转换器: https://github.com/dyc87112/online-markdown/ -图表秀帮助文档 最好用的在线图表制作网站: https://www.tubiaoxiu.com/ Learning Git Branching | 闯关游戏顺便学 git 游戏闯关中学习 git 常用技巧: https://github.com/pcottle/learnGitBranching carbon | 源码转图片 将源码转成图片分享出去! https://github.com/dawnlabs/carbon GPSspg | 在线地图经度纬度查询 基于Google谷歌地图、百度地图、腾讯地图QQ地图、高德地图、图吧地图在线地图技术，可实现经度纬度查询地名位置、地名查询经度纬度位置、任意地图位置解析经纬度。海拔高度查询。 Regexper | 正则表达式可视化工具 正则表达式可视化工具: https://gitlab.com/javallone/regexper-static 博客主页 八一菜刀 有志者,事竟成!苦心人,天不负!加油吧~！！！ Lyric 歌词经理,是一名产品经理. 程序猿DD 《Spring Cloud微服务实战》作者，SpringCloud中文社区创始人（bbs.springcloud.com.cn），Spring4All社区联合发起人（spring4all.com) © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"tools/mac-install-vmware.html":{"url":"tools/mac-install-vmware.html","title":"给mac装个虚拟机","keywords":"","body":"给mac装个虚拟机 mac 系统安装虚拟机目前有两种主流软件,一种是 Parallels Desktop ,另一种是 vmware. 本教程选用的是 vmware ,因为我之前 windows 上安装的虚拟机软件就是vmware,所以当然选择熟悉的方式鼓捣 mac 虚拟机了啊! 如果你没听说过虚拟机,可能你走错门了,不太适合看这篇教程.如果你执意要了解一下新知识,那我只能用自己浅薄的知识简单介绍下虚拟机的基本概念,一家之言,仅供参考哟! 正常来说,我们当前使用的电脑一般只有一个系统,比如你买的是 mac 笔记本,那么电脑系统就是 mac 操作系统,肯定不会是 windows 操作系统,所以你在 mac 电脑上看不到 windows 的办公软件三件套(word,excel,ppt). 当然你的电脑如果是 联想,戴尔,华硕,神舟 等等品牌的话 ,操作系统一般都是 windows,自然也不会是看到 mac 电脑上的 xcode 软件. 这一点很好理解,每种电脑与生俱来自带特定的操作系统,但是,竟然有一种方法能够突破这层限制! 什么是虚拟机 虚拟机（Virtual Machine）指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。 虚拟机,顾名思义是虚拟的机器.虚拟意味着不是真实的,机器意味着功能像是一台机器. 所以,我们能够理解上述百度百科的定义,虚拟机就是通过软件模拟实现真实机器功能. 软件模拟硬件是手段,实现机器功能是目的,既然如此理论上应该能够模拟任何操作系统,从而实现一台真实的物理机可以有多种不同的操作系统! 这样一来是不是很神奇?一台 mac 可以模拟出 Windows 电脑,也可以模拟出 linux 电脑. 换言之,只要有一台真实的物理机,通过软件我们就可以模拟出任意操作系统,这种软件就是我们接下来要介绍的 vmware . 虚拟机的使用场景 作为软件开发者,尽管很多语言支持跨平台运行,但是为了检验真实效果,我们需要运行到不同的环境中,比如windows 和 linux 系统的差异就不是一星半点! 或者为了教程的完整性,需要在各个平台测试运行后才能放心讲解某个知识点,不然别人按照教程发现运行不了,既浪费了别人的时间,又惹得人家不高兴,好心办坏事,大家都不好受. 所以,多个系统是刚需,如果真实环境中能够提供的话,那么自然不需要虚拟机. 只有实际情况下,不能提供真实的多种操作系统的情况下,我们才使用虚拟机技术来模拟不同的操作系统. 为什么是 vmware 通过软件模拟实现虚拟机目标,关键在于软件能力如何,所以选择哪一款软件直接决定了我们的虚拟机性能如何. 市面上,这种软件并不是唯一一家,至少目前我了解的就有 vmware ,Parallels Desktop 和 virtualbox .那么为什么选择 vmware 呢? 没有为什么,因为我之前用过 vmware 而已,对于小白的我,并没研究过三者软件有什么区别,哪一种更好,只要操作足够简单,市面上足够流行就可以了. 快速体验 vmware 本教程使用的是 mac 电脑,利用虚拟机安装了三种不同系统,分别是 win7旗舰版 , centos7.5 和 Ubuntu18. windows 虚拟机 启动 windows7 旗舰版 虚拟机,并且打开 chrome 浏览器测试. centos 虚拟机 启动 centos7.5 虚拟机,并且输入 pwd 命令测试. ubuntu 虚拟机 启动 ubuntu18 虚拟机,并且输入 pwd 命令测试. 如何安装 vmware 需要实现准备好下载工具以及留下足够的内存空间,因为虚拟机和镜像毕竟都挺大,下载挺费时间,安装也比较占内存,毕竟是完整的虚拟机. 下载软件以及序列号生成工具 链接: https://pan.baidu.com/s/1D0LL_muZ_YEbmgS4A6l3pw 提取码: ti8v 复制这段内容后打开百度网盘手机App，操作更方便哦 VMware-Fusion-11.0.3-12992109.dmg [必选] 安装软件 vmware 软件是收费软件,有一段时间的试用期,这里采用序列号激活方式,有条件的话,建议支持下正版. KeyMaker.app [可选] 序列号生成工具 如果是选择官网试用版或者已购买正版,自然不需要序列号生成功能. 安装 VMware-Fusion 软件 双击安装 VMware-Fusion-11.0.3-12992109.dmg 软件,接下来一路允许按照提示操作即可. 双击安装,因为软件源不是从 App Store 下载的,所以苹果默认策略不允许安装第三方来源. 既然询问是否打开软件,当然打开,不然怎么安装呢? 然而,还是太年轻,尽管刚才已经选择打开软件,然而苹果怕是担心我们不小心安装了有害应用吧?还是需要再问我们一遍,你确定要安装吗?我确定!我怎么知道是你本人?你输入管理员密码试试,密码正确我就让你安装. 千呼万呼使出来,你终于相信我是我了,安装进行中... 安装到一定程度时,会让我们输入产品密钥进行激活,否则只能试用30天,到期会再次提醒输入密钥,接下来我们来获取序列号. 打开 KeyMaker 软件 双击运行 KeyMaker.app ,弹出一系列序列号,随意选择某一行的序列号复制到上一步安装VMware-Fusion 的产品密钥并验证. Some good serial numbers.. KGLWE-VA5KZ-D1QHT-2R51Q-ZKQVV VTZMD-ZYTKX-D1ZCR-C6QCZ-QZZEV GQZX9-ZFX3T-Z1Z6Y-AFPCW-ZZ5GZ THQQR-00TZQ-81L0R-10LEG-G2ZTZ P1VXR-GFNGC-R1JJR-JXG3T-PQ7XT ZXYXY-VMTKZ-Y1YCX-7MQ9X-MQQ6V Here another one GK9QC-9KEM4-V1VAQ-P8JEP-MK77V Greets to Corby 随便复制一个序列号,继续正常安装. 输入产品密钥后基本上就是 vmware 用户,除非你不同意它的产品协议,当然同意了! 本以为安装到此结束,没想到还想要获取辅助功能权限,没办法,既然你想要,那我就给你啊,保不齐缺胳膊少腿的. 和安装相同,不是你选择允许苹果就允许,仍然需要你提供管理员密码以此确保主观操作意愿. 授予辅助功能权限,并再次锁定该项操作,可以与想的是,以后有应用想要申请辅助功能,必须经过管理员同意才可以,为了安全需要这么多步骤,好吧. 我只想安安静静使用 vmware 产品,不希望使用数据被上传收集,当然也有点小担心,毕竟也不是正儿八经的用户,所以才不加入体验计划呢! 验证 vmware 软件 在访达或启动台中找到 VMware-Fusion 软件单击启动,测试能否正常运行软件. 小结 本节主要介绍了什么是虚拟机,虚拟机的使用场景以及如何安装虚拟机,下一节我们将介绍如何给虚拟机加点料,让虚拟机派上练武之地! © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"tools/vmware-install-windows.html":{"url":"tools/vmware-install-windows.html","title":"给虚拟机装个windows","keywords":"","body":"给虚拟机装个windows 前面我们介绍了如何在 mac 宿主机安装 VMware 虚拟机软件,本节我们将继续介绍如何给虚拟机安装 windows 镜像,切换不同的操作系统. VMware 软件是容器,镜像是内核,这里的镜像指的是操作系统. 下载镜像 windows 操作系统下载: https://msdn.itellyou.cn/ 按照实际需要选择适合自己的操作系统,这里选择的是 win7 旗舰版 ,然后选择详情会弹出下载链接. 一般需要使用迅雷等第三方工具下载种子链接,大小一般在 3g 多,下载时间稍微比较久! ed2k://|file|cn_windows_7_ultimate_x64_dvd_x15-66043.iso|3341268992|7DD7FA757CE6D2DB78B6901F81A6907A|/ 配置镜像 准备好已下载的镜像文件: cn_windows_7_ultimate_x64_dvd_x15-66043.iso 打开 VMware 软件,选择 文件->新建 选项开始安装镜像文件. 弹出安装配置界面,选择 从光盘或镜像中安装 选项,然后将已下载的镜像文件拖动到安装区进行识别. 识别到镜像文件后选中该文件,点击 继续 准备下一步安装. 配置账号信息以及产品密钥等信息,暂时不需要激活的话,也可以不填写产品密钥. 集成方式选择 更加独立 ,然后点击 继续. 提示下载 VMware Tools 工具,如果可以的话,最好还是先下载,也可以安装完毕后再手动下载. 确认配置信息无误后,点击 完成 ,等待镜像安装,,, 安装镜像 人生若只如初见,远远望见熟悉的背影,便确定了你就是我要安装的操作系统. 期待花开,耐心等待你的文件复制进程. 花开花落又是一年,你说重启才能遇到最美的季节,那我便等待你的凤凰涅槃. 见证你的凤凰涅槃,期待你的浴火重生. 浴火重生后的操作系统,还差最后一步就能欣赏你的容颜. 千呼万唤始出来,犹抱琵琶半遮面,正在进行最后的准备桌面. 终于等到你,还好我没放弃! 小结 总体来说,mac 系统安装 windows 镜像配置比较简单,基本上按照默认配置即可. 下载镜像时文件一般比较大,需要利用专门的第三方工具下载,比如本文提供的下载链接是种子文件,选择的第三方工具就是迅雷. © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"tools/vmware-install-centos.html":{"url":"tools/vmware-install-centos.html","title":"给虚拟机装个centos","keywords":"","body":"给虚拟机装个centos 前文我们已经讲解了如何在 mac 系统上安装虚拟机软件,这节我们接着讲解如何利用虚拟机安装 centos 镜像. 安装镜像的大致步骤基本相同,只不过是配置项略显不同而已,如果需要安装其他系统镜像,请参考另外两篇教程. 下载镜像 centos 操作系统下载: https://www.centos.org/download/ DVD ISO 和 Minimal ISO 两种类型,普通用户推荐选择前一种标准版,开发用户建议选择后一种最小版. 标准版功能比较齐全,最小版保证最小依赖,后续缺啥填啥,比较灵活节省空间内存. 按照实际需要选择适合自己的操作系统,这里选择的是 centos7.6 ,然后选择合适的下载方式(直接下载或下载种子链接). 建议选择镜像服务器下载,如果直接下载官网的地址,速度感人,时间有点长. 依次选择 list of current mirrors -> http://mirrors.aliyun.com/centos/ -> 7.6.1810/ -> isos/ -> x86_64/ -> CentOS-7-x86_64-Minimal-1810.iso 选择合适的版本点击下载. 配置镜像 准备好已下载的镜像文件: CentOS-7-x86_64-Minimal-1804.iso 打开 VMware 软件,选择 文件->新建 选项开始安装镜像文件. 弹出安装配置界面,选择 从光盘或镜像中安装 选项,然后将已下载的镜像文件拖动到安装区进行识别. 识别到镜像文件后选中该文件,点击 继续 准备下一步安装. 选择固件类型,默认方式 传统 BIOS .然后点击 继续 . 确认配置信息无误后,点击 完成 ,等待镜像安装,,, 安装镜像 只因在人群中看见了 centos ,便确定了你就是我要安装的操作系统. 阅览安装摘要信息,等待继续安装. 设置用户信息,包括设置 root 用户密码和创建初始用户账号信息. 花开花落又是一年,你说重启才能遇到最美的季节,那我便等待你的凤凰涅槃. 终于等到你,还好我没放弃! 按照之前配置的用户信息登录系统,打印出当前路径,证明安装成功. 小结 总体来说,mac 系统安装 centos 镜像配置比较简单,基本上按照默认配置即可. 下载镜像时文件一般比较大,需要利用专门的第三方工具下载,既可以选择下载种子链接也可以直接下载. © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"tools/vmware-install-ubuntu.html":{"url":"tools/vmware-install-ubuntu.html","title":"给虚拟机装个ubantu","keywords":"","body":"给虚拟机装个ubantu 前文我们已经讲解了如何在 mac 系统上安装虚拟机软件,这节我们接着讲解如何利用虚拟机安装 Ubuntu 镜像. 安装镜像的大致步骤基本相同,只不过是配置项略显不同而已,如果需要安装其他系统镜像,请参考另外两篇教程. 下载镜像 Ubuntu 操作系统下载: https://www.ubuntu.com/download 这里我们选择桌面版(Ubuntu Desktop),接着选择 LTS 长期支持版进行下载安装. 按照实际需要选择适合自己的操作系统,这里选择的是 Ubuntu18 LTS ,然后选择下载. 配置镜像 准备好已下载的镜像文件: ubuntu-18.04.2-desktop-amd64.iso 打开 VMware 软件,选择 文件->新建 选项开始安装镜像文件. 弹出安装配置界面,选择 从光盘或镜像中安装 选项,然后将已下载的镜像文件拖动到安装区进行识别. 识别到镜像文件后选中该文件,点击 继续 准备下一步安装. linux 快捷安装选项中配置用户信息,点击 继续 . 确认配置信息无误后,点击 完成 ,等待镜像安装... 安装镜像 只因在人群中看见了 Ubuntu ,便确定了你就是我要安装的操作系统. 惊鸿一瞥,容颜出现,安装进行时. 熟悉的命令行,成功只差一步. 现在输入之前配置的账号信息,开始登陆系统,见证奇迹的时刻即将来临... 终于等到你,还好我没放弃! 小结 总体来说,mac 系统安装 Ubuntu 镜像配置比较简单,基本上按照默认配置即可. 下载镜像时文件一般比较大,需要利用专门的第三方工具下载,既可以选择下载种子链接也可以直接下载. © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"write/":{"url":"write/","title":"如何写作","keywords":"","body":"如何写作 越来越多的人想写个人博客或者打算做自媒体,笔者也是一样. 最近在学习如何写博客,分享下创作经历,避免走弯路. 首先在于定位,不同的定位决定了不同的平台.由于笔者分享的大多是技术类博客,所以主战场是各大主流的技术类博客论坛,当然还搭建了自己的官网. 考虑到前期仅仅是分享技术博客,无需购买专门的服务器,因此寻求免费的解决方案. 笔者采用的是 github 搭建个人项目官网,优点是不花一分钱,就能免费开启 https 服务,缺点是国内访问速度慢. 下面分为两部分介绍博客的创作平台,一部分是个人官网,另一部分是第三方平台. 个人官网 首先注册 github 账号(例如:用户名 snowdreams1006),然后新建特定规则的项目(例如:项目名 snowdreams1006.github.io),最后在项目下创建首页 index.html .现在访问 https://用户名.github.io/ (https://snowdreams1006.github.io/)即可. 个人官网的基本流程和特点如下: 利用 gitbook 技术将 markdown 源码文件输出为 html 静态网页. 将项目按照特定规则上传到 github 网站公开托管,生成免费网站. 源代码更新后再生成输出文件,然后一起上传到 github,个人官网自动更新. 项目源码 snowdreams1006.github.io,项目官网 https://snowdreams1006.github.io/ 点击图片会自动跳转到 https://snowdreams1006.github.io/ 第三方平台 这里列举了常逛的第三方平台,将从新手视觉看待各家平台特点,试图分析各家平台特点从而决定是否适合自身. 一家之言,仅供各位参考. 排名不分顺序,只是笔者文章依次同步的顺序而已. 1. CSDN https://www.csdn.net/ SEO 优化不错,阅读量稳定,网页端阅读体验一般,手机端干净清爽,阅读量相对稳定. 不限制作者本人点赞,重复统计本人浏览记录,突出阅读数,其次是评论数和点赞数. 2. 博客园 https://www.cnblogs.com/ SEO 优化不错,博客开通需审核,支持发布首页,但也可能因质量不达标而被移除.页面风格满满的时代感,目前暂无手机端. 限制作者本人推荐,不统计本人浏览记录,突出推荐数,其次是阅读量和评论数. 3. 开源中国 https://www.oschina.net/ 国内版 github ,高质量文章可能会被推荐至首页,否则阅读量几乎为零. 限制作者本人点赞,不统计本人浏览记录,突出访问量,其次评论数和点赞数. 4. 简书 https://www.jianshu.com/ 文艺范的自媒体平台,简洁优美文艺性十足,SEO 优化不错,日更活动鼓励持续更新,简书钻和简书贝等虚拟货币增添写作乐趣! 不限制作者本人喜欢,不统计本人浏览记录,突出简书钻,其次阅读量,评论数和点赞数. 5. 思否 https://segmentfault.com/ 国内版Stack OverFlow,专注于技术问答,界面风格绿色清新,SEO 优化不错,但忽略阅读量. 限制作者本人点赞,不统计本人浏览记录,首次发布专栏需要审核,突出投票数,其次是收藏数,最后是阅读数. 6. 掘金 https://juejin.im/timeline 异军突起,风头正盛,时间流布局,掘金小册子是一大亮点,但SEO 很差! 不限制作者本人点赞,不重复统计本人浏览记录,突出点赞数,其次是评论数,最后是阅读量. 7. 慕课网手记 https://www.imooc.com/article 丰富的免费教学视频,正所谓\"成也萧何败萧何\",手记模块相比其他专业平台还有着不少的差距,SEO 一般. 不限制作者本人点赞,重复统计本人浏览记录,文章需要审核,手记功能更像是配套教学视频而诞生的笔记,不太像专门博客. 8. 微信公众号 https://mp.weixin.qq.com/ 目前仅支持富文本编辑器,依靠粉丝流量,碎片化阅读体验,SEO 几乎没有. 需要花费精力运营公众号,限定当天阅读量和\"在看\"数,如果没有粉丝,那肯定没有阅读量. 9. B站专栏 https://www.bilibili.com/ 弹幕视频网站,开通专栏投稿,目前仅支持富文本编辑器,不适合博客,SEO 可忽略. 适合视频教程,暂不适合博客且投稿专栏限制较多,毕竟不是专业做博客的平台,谁让我误入了呢! 总结 大多数平台都有阅读量,评论,点赞等维度数据统计,但不同平台有着不同的推荐策略,优缺点如下: csdn : SEO 不错,阅读量稳定,适合新手积累信心. 博客园 : SEO 不错,阅读量有保障,适合新手提高自信. 开源中国 : SEO 一般,阅读量有挑战,适合优质文章博取官方推荐. 简书 : SEO 不错,阅读量很少,日更活动和简书钻奖励等形式鼓励持续创作,适合自我督促. 思否 : SEO 一般,阅读量一般,适合技术问答. 掘金 : SEO 很差,阅读量一般,适合优质文章. 慕课网手记 : SEO 一般,适合教学视频的配套笔记. 微信公众号 : SEO 很差,适合粉丝用户. B站 : SEO 很差,适合教学视频. 从以上分析中可以看出,只要是优质文章无论到哪都受欢迎,然而\"罗马并非一日建成\",优质文章的诞生不在一朝一夕,所以新手期应该选择适合自己的平台发展,积累到一定程度后方能\"春风得意马蹄疾,一日看遍长安花\". 个人建议: 选择简书平台,保持日更,同步到CSDN积累自信,推送到博客园,提高自信. 官网保持更新,运营公众号慢慢积累粉丝,最后再考虑开源中国,掘金和思否. © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"write/markdownOrRichText.html":{"url":"write/markdownOrRichText.html","title":"markdown和富文本","keywords":"","body":"markdown和富文本 不知道你是否留意过平时写作时的编辑器,有的是 markdown 编辑器,有的是各种富文本编辑器,到底选择哪一个相信你有自己的判断. 如果只是在某一家平台上写作,哪一种编辑器都无所谓,只要你喜欢就好. 可是如果你需要同时发布到各个平台呢?此时,真的需要停下来思考一下,我该使用哪一种编辑器了? 各家的编辑器的界面设计风格迥然不同,不仅按钮排序顺序不一样,而且最终输出效果也不尽相同. 这就给我们带来了一个问题,明明已经排好版的文章,复制到另外一家平台样式不一样了,或者格式被清除了?! 心中一万只羊驼呼啸而过,尽管如此,还是在心里告诉自己要冷静,要冷静! 既然我们追求的一处编写,到处复制,那么我就有必要郑重向你推荐 markdown 编辑器. 简单地说,markdown 编辑器是一种标记语言,写的是源码,输出的是 html. 所以很多情况下, markdown 更适合技术人员写文章,不用关心排版布局,回归写作本质,而富文本格式适合文学工作者,强调布局美观,重视审美体验. 两者看似相互独立,实际上最终展示效果几乎太大差别, markdown 格式和富文本格式最终都输出 html 格式,毕竟绝大多数阅读媒介还是各种浏览器. markdown 语法支持嵌套 html 语法,从而可以实现较为复杂的排版布局. markdown 格式 如果使用的是 markdown 格式编写文章,首先需要记忆常用的基本语法,半个小时足够入门写博客了,比txt 高级,比 html 简洁,取代 word 地位! 正是因为 markdown 语法规范,所以可以说是跨平台的写作语言,基本上各大主流的博客平台均支持 markdown 格式,保证了\"一处编写,到处复制\"的优良特性. 值得注意的是,不同平台对 markdown 格式的渲染结果稍有差异,甚至语法支持度不同,这要求我们尽量写通用语法或者因地制宜有针对性编写文章. ## markdown 二号标题 - markdown 无序列表1 - markdown 无序列表2 - markdown 无序列表3 **markdown 加粗文字效果** [markdown 超链接文字](https://snowdreams1006.github.io/markdown/) ![markdown 图片文字](./images/markdown-preview.png) markdown 快速入门 富文本格式 平常熟悉的 word 编辑器可以理解为一种富文本格式,布局,标题,超链接,图片等均以控件的形式展示,需要填写标题了点一下按钮,需要加粗效果再点一下按钮,效果直观,不需要二次渲染,但不同的平台自然是不同的布局. 一家平台的布局还不一定能够完美复制到另一家平台,虽然适合大多数人,但可移植性差! 如果需要同时发布到多家平台,简直不敢相信,复制不了样式,需要重新排版等问题绝对是一种折磨. 小结 markdown : 拥有编程经验,不关心排版布局,专注写作多家平台发表首选 markdown 编辑器,\"一处编写,到处复制\",可移植性好,最值渲染效果也不错! 富文本格式: 可视化书写文章,无需编程经验的话,首选富文本编辑器,调整鼠标就能搞定页面布局还是很轻松的,同步更新到多家平台时,页面布局格式差强人意,后期维护难度大! © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"write/markdown2richText.html":{"url":"write/markdown2richText.html","title":"markdown转富文本","keywords":"","body":"markdown转富文本 正常情况下不太希望你能看到这篇文章,可天不遂人愿, 总有些平台至今不支持 markdown 语言,没办法只能迁就它! 现在遇到的问题是,部分平台仅支持富文本格式,不支持 markdown 格式.既然想要在这些平台上发表文章,不得不按照他们的规定做事. 下面总结下笔者在用的一些方法: 1. markdown转富文本 适合已有 markdown 格式的文章,想要优雅转换成富文本格式,这种情况下我们只要能够获取到渲染后的富文本内容,然后复制到平台的编辑器即可. 不少 markdown 编辑器支持实时预览,一边是 markdown 源码,另一边是 富文本 预览,选中富文本然后复制,相当简单. 或者,将 markdown 源码上传到第三方平台在线转换成富文本格式,推荐 Markdown Here 插件或 在线工具. Markdown Here chrome插件的使用方法: 下载安装 Markdown Here 插件 各大浏览器基本上都有相应插件,如需翻墙,请自行解决. 配置插件并重启浏览器 支持自定义css样式,内嵌多套主题可供选择. 使用快捷键或命令面板转换 默认快捷键CTRL + ALT + M,或者复制到插件的预览窗口,点击Markdown 转换 目标富文本内容拷贝回富文本编辑器 选中渲染后的富文本内容拷贝到目标编辑器 online-markdown 在线工具的使用方法: 复制源 markdown 内容转换成目标富文本格式 将源 markdown 内容复制到左侧代码区,右侧可实时预览富文本效果 目标富文本内容拷贝回富文本编辑器 点击复制后到目标编辑器选择粘贴 2. 截图分享 适合懒癌晚期的作者,第一种方法转换后的富文本可能无法完美移植到某些平台时,而笔者又懒得重新编辑富文本,因此选择截图分享方式发布在该平台,只不过这种体验上稍差些,毕竟图片加载速度比文字相对来说还是慢很多! 简书和开源中国的 app 均支持截长图保存分享,网页端的话滚动截屏插件很多,目前在用fireshot还不错. 3. 重新编辑 适合认真负责的完美主义者,既然不支持 markdown 语言,那就用富文本编辑器重新编辑一份,素材和效果都有参考,再写一遍应该也不至于特别耗费时间,如果需要重写多份的话,那就另当别论了! © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"write/static-semi-manual-with-csv.html":{"url":"write/static-semi-manual-with-csv.html","title":"csv半手动数据统计","keywords":"","body":"csv半手动数据统计 背景 作为正在探索如何写作并发表到各大博客平台的新人,目前虽然已基本弄清写作和发表的基本流程,但是离打造个人知名度还差很大很大一段距离. 尤其处于新手阶段,需要的更是自信与外界的积极反馈,看着各平台日益增长的阅读量和粉丝量,心中自然不甚欣喜. 但是,持续的技术输出能否坚持下去很大程度上靠的是外界的积极反馈,如果写的文章基本没人看,或者反映并不理想,估计也很难再坚持创作了. 所以笔者每天晚上都会统计一下各个平台的数据,看一下有哪些收获,只有看得见的数据才能给我安全感和自信心. 下面简单展示一下每日数据统计效果: 每日数据统计 这里列出的平台默认是没有提供数据分析功能,而有些平台已经提供数据分析,说不定还要丰富图表分析功能,自然不用像下面这般复杂操作. 所以,针对没有提供数据分析的平台,只好采用人工方式进行每日数据统计,一开始文章比较少,用肉眼加计算器就能很轻松得到阅读量和粉丝数等数据. 但是,随着文章的每日更新,不断累加的文章越来越多,人工方式简直让我崩溃,比如昨晚在统计慕课网手记相关数据时就意外被一旁的小侄子打断三次! 简直不可忍受,穷则思变,懒则想法偷懒,所以是时候探索新的方式解决纯手动的弊端了! 全网汇总数据 慕课手记 简书 博客园 腾讯云社区 图表渲染效果来自 gitbook 的 chart 插件,详情请参考 官网文档 懒则想法偷懒 回顾操作流程 要想解放重复劳动量,必须先知道问题瓶颈,现在先回顾一下手动操作流程. 登录各大博客平台后台,找到文章列表. 打开计算器按照阅读量等指标累加每篇文章的相关数据. 更新统计页面数据,利用 chart 插件渲染图标. 修改 chart 渲染数据语法,截图渲染效果. 确认渲染效果并推送到 github 网站 本来不必利用截图表示图表的,只是无奈 github 不支持 chart 插件语法,只好用截图代替了. 思考问题瓶颈 分析上述流程后不难发现,最复杂也是最费时费力的便是第二步的数据统计,由于要肉眼统计文章并用计算器累加,简直是手脑并用,只有高度专注才能保证统计数据的准确性和可靠性. 这也就解释了被打断三次后的崩溃了,找到问题的根源了,想办法如何解决吧! 最容易想到的解决办法是手动复制文章列表数据,然后程序分析提取关键数据,最后再统计数据. 又是三步操作,再分解一下步骤,看看目前能够解决哪部分. 手动复制文章列表数据 程序分析提取关键数据 统计指标数据 在这三步中,只有第二步最为关键,也是目前我能做到的事情,因为第一步可能需要爬虫技术或模拟接口调用,总体来说,总体来说还是比较麻烦的,以后再继续优化吧. 梳理操作流程 因此,现在先着手如何将复制后的文章列表转化成程序能够处理的文件格式,进而调用程序统计. 下面以慕课网手记文章为例,简单介绍下处理流程. 手动复制文章 现在文章已复制到文件,应该保存成什么格式呢?这又是一个思考点. 由于文件内容最终需要被程序处理,而程序处理要求数据需要具备一定的格式,因此自然不能是 txt 或 word 这类文档,平常接触比较多的文档数据处理一般就是 excel 或者 json 类型的文档. 这里需要 excel 这种格式文档,但是 excel 比较笨重,还需要相关软件才能打开 excel 文件,好像并不是很适合,怎么办呢? 但是我真的需要这种一行一行的数据格式啊,有没有折中的处理方案? 当然有!轻量级的 csv 格式不是巧合适合简单文档处理吗? csv 和 excel 具有类似的特征,大体上都是一行一行一列一列地存储数据,最适合统计数据了. 看着乱七八糟的文章列表,csv 也无法处理这种复杂数据啊,接下来还是要手动格式化数据,整理一下数据. 程序分析提取 至此,我们已经完成数据分析的第一步了,接下来是如何读取 csv 文件,由于本人是 java 程序员,所以我要看一下 java 如何处理 csv 文件. 需求很简单,编写一个 csv 工具类并实现基本的写入和读取操作即可. 说到工具类当然首选现成的开源工具了,毕竟小小的需求不值得造轮子. 寻求解决方案 说到开源工具,脑海中第一个闪现的是 Apache Commons 工具类,所以先去 maven 上搜一下有没有 csv 相关的工具类. 在线搜索 commons-csv 天不负我!果然有 csv 相关工具类,下面就开始研究如何调用吧! 集成 commons-csv 工具类 org.apache.commons commons-csv 1.6 编写工具类 /** * 写入csv文件 * * @param data 数据内容 * @param filePath 文件路径 * @throws IOException **/ public static void writeCsv(List data, String filePath) throws IOException { FileWriter fw = new FileWriter(new File(filePath)); final CSVPrinter printer = CSVFormat.EXCEL.print(fw); printer.printRecords(data); printer.flush(); printer.close(); } /** * 读取csv文件 * * @param filePath 文件路径 * @return CSVRecord 迭代对象 * @throws IOException **/ public static Iterable readCSV(String filePath) throws IOException { InputStream inputStream = new FileInputStream(filePath); InputStreamReader isr = new InputStreamReader(inputStream); Iterable records = CSVFormat.EXCEL.parse(isr); return records; } /** * 测试写入并读取csv 文件 */ private static void testWriteAndRead() throws IOException { //写入数据 List data = new ArrayList(); data.add(new String[]{\"张三\", \"18\", \"3000\"}); data.add(new String[]{\"李四\", \"20\", \"4000\"}); data.add(new String[]{\"王二\", \"25\", \"5000\"}); //写入文件路径 String path = \"/Users/sunpo/Downloads/testWriteAndRead.csv\"; //写入 csv 文件 writeCsv(data, path); //读取文件 Iterable records = readCSV(path); for (CSVRecord record : records) { for (String string : record) { System.out.print(string); System.out.print(\" \"); } System.out.println(); } } 测试写入并读取功能 测试结果真实可用,工具类基本功能编写完成. 制定解决方案 已经有了 csv 工具类,那么现在就要想办法解决实际问题,再看一下当前慕课网手记的内容格式吧! 148浏览 2推荐 0评论 204浏览 2推荐 0评论 181浏览 2推荐 0评论 分析上述内容格式有以下特点: 内容数据一行一条数据,可能需要换行符问题 每一行数据以空格分割,可分割成数组或列表再处理 已分割后的列表项包括了有效数据和文字说明,可能需要过滤出有效数据 按照上述分析结果,开始 coding 逐个解决,下面展示下关键代码. 按照空格将每一行数据分割成列表 List row = StringTools.splitToListString(string, \" \"); StringTools.splitToListString 方式是笔者封装的分割字符串方法,目的将字符串按照指定分隔符分割成字符串列表 处理分割后字符串列表并过来出有效数据 String readCountWithDescString = row.get(0); String readCountString = StringUtils.substringBefore(readCountWithDescString, \"浏览\"); String recommendCountWithDescString = row.get(1); String recommendCountString = StringUtils.substringBefore(recommendCountWithDescString, \"推荐\"); String commentCountWithDescString = row.get(2); String commentCountString = StringUtils.substringBefore(commentCountWithDescString, \"评论\"); StringUtils.substringBefore 方法也是Apache Commons 工具类,具体来源于 org.apache.commons.lang3 ,下述涉及到的 StringUtils 静态方法 也是,不再单独说明. 最后一步即统计分析 //浏览数 int readCount = 0; //推荐数 int recommendCount = 0; //评论数 int commentCount = 0; readCount += Integer.parseInt(readCountString); recommendCount += Integer.parseInt(recommendCountString); commentCount += Integer.parseInt(commentCountString); 实施解决方案 如此一来,三步均已解决,现在运行以下统计方法,看一下真实效果如何. /** * 统计慕课手记 * * @throws IOException */ private static void countImooc() throws IOException { //昨日统计数据 String yesterday = DateFormatUtils.format(DateUtils.addDays(new Date(), -1), \"yyyyMMdd\"); String path = String.format(\"/Users/sunpo/Documents/workspace/count/imooc-%s.csv\", yesterday); //总行数 int allRows = 0; //有效行数 int allValidRows = 0; //当前行是否有效 boolean isValidRow = true; //浏览数 int readCount = 0; //推荐数 int recommendCount = 0; //评论数 int commentCount = 0; Iterable records = readCSV(path); for (CSVRecord record : records) { allRows++; for (String string : record) { System.out.println(string); if (StringUtils.isBlank(string)) { isValidRow = false; break; } List row = StringTools.splitToListString(string, \" \"); String readCountWithDescString = row.get(0); String readCountString = StringUtils.substringBefore(readCountWithDescString, \"浏览\"); String recommendCountWithDescString = row.get(1); String recommendCountString = StringUtils.substringBefore(recommendCountWithDescString, \"推荐\"); String commentCountWithDescString = row.get(2); String commentCountString = StringUtils.substringBefore(commentCountWithDescString, \"评论\"); readCount += Integer.parseInt(readCountString); recommendCount += Integer.parseInt(recommendCountString); commentCount += Integer.parseInt(commentCountString); } if (isValidRow) { allValidRows++; } isValidRow = true; } System.out.println(); System.out.println(String.format(\"[慕课手记] 一共读取%d行,有效行: allValidRows = %d ,其中浏览数: readCount = %d ,推荐数: recommendCount = %d ,评论数: commentCount = %d\", allRows, allValidRows, readCount, recommendCount, commentCount)); System.out.println(); } 很完美,终于不必再肉眼统计数据了,虽然很长程度上仍然依赖人工整理好 csv 文件,但是目前已经解决了纯手动的弊端. 因此,上述解决方案是半手动的方式,仍然还有很多可以优化的地方,等下次忍受不了这种方案时再解决! 小结 本文主要介绍了纯手工统计报表遇到的诸多问题,寻求一种相对简单的解决方案. 基本流程大致可以分为下述流程: 手动复制文章列表(包括阅读量,评论量和点赞数),并整理成标准的 csv 格式文件. 编写各个平台的 csv 工具处理类,解析并统计 csv 文件内容. 运行工具类得到最终统计数据,大功告成! 本文主要介绍的是解决问题的思路,对于其中涉及到的相关技术点并未深入展开,关键源码已经贴上,如果还想要更详细的完整源码,可以留言回复. © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"write/static-semi-manual-with-js.html":{"url":"write/static-semi-manual-with-js.html","title":"js半手动数据统计","keywords":"","body":"js半手动数据统计 在日常文章数据统计的过程中,纯手动方式已经难以应付,于是乎,逐步开始了程序介入方式进行统计. 在上一节中,探索利用 csv 文件格式进行文章数据统计,本来以为能够应付一阵子,没想到仅仅一天我就放弃了. 原因还不是因为我懒,需要复制文章内容,然后整理成特定的 csv 格式,最后利用已编写的 java 工具类进行统计. 在这三步操作中,第一步复制文章内容最简单,第二步整理文章格式最麻烦,第三步编写 csv 工具类最技术. 因此,能不能再简单点?懒癌晚期,必须继续寻求新的解决方案. 关于如何利用 csv 文件处理统计数据,可以参考 https://snowdreams1006.github.io/static-semi-manual-with-csv.html 实现效果 慕课手记 慕课手记 : https://www.imooc.com/u/5224488/articles c3.generate({\"bindto\":\"#plugin-chart-1\",\r \"data\": {\r \"x\": \"x\",\r \"columns\": [\r [\r \"x\",\r \"2019-04-01\",\r \"2019-04-02\",\r \"2019-04-03\",\r \"2019-04-04\",\r \"2019-04-05\",\r \"2019-04-06\",\r \"2019-04-07\",\r \"2019-04-08\",\r \"2019-04-09\",\r \"2019-04-10\",\r \"2019-04-11\",\r \"2019-04-12\"\r ],\r [\r \"粉丝\",\r 8,\r 8,\r 8,\r 9,\r 9,\r 9,\r 9,\r 9,\r 9,\r 9,\r 9,\r 9\r ],\r [\r \"阅读量\",\r 3508,\r 3645,\r 3650,\r 4356,\r 4528,\r 4864,\r 5276,\r 5593,\r 5872,\r 5912,\r 6271,\r 6400\r ],\r [\r \"手记\",\r 32,\r 33,\r 34,\r 36,\r 38,\r 39,\r 40,\r 41,\r 42,\r 42,\r 44,\r 44\r ],\r [\r \"推荐\",\r 36,\r 36,\r 37,\r 39,\r 41,\r 42,\r 48,\r 49,\r 50,\r 50,\r 52,\r 52\r ],\r [\r \"积分\",\r 107,\r 118,\r 118,\r 130,\r 130,\r 141,\r 152,\r 173,\r 173,\r 173,\r 194,\r 195\r ]\r ],\r \"axes\": {\r \"粉丝\": \"y2\"\r },\r \"types\": {\r \"粉丝\": \"bar\"\r }\r },\r \"axis\": {\r \"x\": {\r \"type\": \"timeseries\",\r \"tick\": {\r \"format\": \"%Y-%m-%d\"\r }\r },\r \"y2\": {\r \"show\": \"true\",\r \"label\": { \r \"text\": \"粉丝\",\r \"position\": \"outer-middle\"\r }\r } \r }\r }); 简书 简书 : https://www.jianshu.com/u/577b0d76ab87 c3.generate({\"bindto\":\"#plugin-chart-2\",\r \"data\": {\r \"x\": \"x\",\r \"columns\": [\r [\r \"x\",\r \"2019-04-01\",\r \"2019-04-02\",\r \"2019-04-03\",\r \"2019-04-04\",\r \"2019-04-05\",\r \"2019-04-06\",\r \"2019-04-07\",\r \"2019-04-08\",\r \"2019-04-09\",\r \"2019-04-10\",\r \"2019-04-11\",\r \"2019-04-12\"\r ],\r [\r \"粉丝\",\r 7,\r 7,\r 6,\r 7,\r 6,\r 5,\r 5,\r 5,\r 5,\r 5,\r 5,\r 5\r ],\r [\r \"阅读量\",\r 343,\r 335,\r 342,\r 358,\r 374,\r 443,\r 468,\r 512,\r 548,\r 552,\r 611,\r 624\r ],\r [\r \"文章\",\r 33,\r 34,\r 35,\r 37,\r 39,\r 40,\r 41,\r 42,\r 43,\r 43,\r 46,\r 46\r ],\r [\r \"喜欢\",\r 57,\r 58,\r 59,\r 60,\r 62,\r 64,\r 65,\r 67,\r 68,\r 68,\r 68,\r 71,\r 71\r ],\r [\r \"简书钻\",\r 27,\r 28,\r 28,\r 9,9\r ,9,\r 10,\r 10,\r 10,\r 10,\r 11,\r 11\r ]\r ],\r \"axes\": {\r \"粉丝\": \"y2\"\r },\r \"types\": {\r \"粉丝\": \"bar\"\r }\r },\r \"axis\": {\r \"x\": {\r \"type\": \"timeseries\",\r \"tick\": {\r \"format\": \"%Y-%m-%d\"\r }\r },\r \"y2\": {\r \"show\": \"true\",\r \"label\": { \r \"text\": \"粉丝\",\r \"position\": \"outer-middle\"\r }\r }\r }\r }); 博客园 博客园 : https://www.cnblogs.com/snowdreams1006/ c3.generate({\"bindto\":\"#plugin-chart-3\",\r \"data\": {\r \"x\": \"x\",\r \"columns\": [\r [\r \"x\",\r \"2019-04-01\",\r \"2019-04-02\",\r \"2019-04-03\",\r \"2019-04-04\",\r \"2019-04-05\",\r \"2019-04-06\",\r \"2019-04-07\",\r \"2019-04-08\",\r \"2019-04-09\",\r \"2019-04-10\",\r \"2019-04-11\",\r \"2019-04-12\"\r ],\r [\r \"粉丝\",\r 17,\r 17,\r 17,\r 18,\r 18,\r 18,\r 18,\r 18,\r 18,\r 18,\r 18,\r 18\r ],\r [\r \"阅读数\",\r 3889,\r 4096,\r 4207,\r 4388,\r 4411,\r 4435,\r 4471,\r 4728,\r 4866,\r 4867,\r 5189,\r 5274\r ],\r [\r \"随笔\",\r 31,\r 32,\r 33,\r 34,\r 36,\r 38,\r 39,\r 41,\r 41,\r 41,\r 43,\r 43\r ],\r [\r \"评论数\",\r 16,\r 16,\r 16,\r 16,\r 16,\r 16,\r 16,\r 16,\r 16,\r 16,\r 16,\r 16\r ]\r ],\r \"axes\": {\r \"粉丝\": \"y2\"\r },\r \"types\": {\r \"粉丝\": \"bar\"\r }\r },\r \"axis\": {\r \"x\": {\r \"type\": \"timeseries\",\r \"tick\": {\r \"format\": \"%Y-%m-%d\"\r }\r },\r \"y2\": {\r \"show\": \"true\",\r \"label\": {\r \"text\": \"粉丝\",\r \"position\": \"outer-middle\"\r }\r }\r }\r }); 腾讯云社区 腾讯云社区 : https://cloud.tencent.com/developer/user/2952369/activities c3.generate({\"bindto\":\"#plugin-chart-4\",\r \"data\": {\r \"x\": \"x\",\r \"columns\": [\r [\r \"x\",\r \"2019-04-04\",\r \"2019-04-05\",\r \"2019-04-06\",\r \"2019-04-07\",\r \"2019-04-08\",\r \"2019-04-09\",\r \"2019-04-10\",\r \"2019-04-11\",\r \"2019-04-12\"\r ],\r [\r \"粉丝\",\r 13,\r 13,\r 13,\r 13,\r 13,\r 13,\r 13,\r 13,\r 13\r ],\r [\r \"阅读量\",\r 1192,\r 1561,\r 2131,\r 2144,\r 2149,\r 2158,\r 2159,\r 2163,\r 2165\r ],\r [\r \"文章\",\r 34,\r 34,\r 34,\r 34,\r 34,\r 34,\r 34,\r 34,\r 34\r ],\r [\r \"点赞\",\r 107,\r 108,\r 110,\r 107,\r 107,\r 107,\r 107,\r 107,\r 107\r ]\r ],\r \"axes\": {\r \"粉丝\": \"y2\"\r },\r \"types\": {\r \"粉丝\": \"bar\"\r }\r },\r \"axis\": {\r \"x\": {\r \"type\": \"timeseries\",\r \"tick\": {\r \"format\": \"%Y-%m-%d\"\r }\r },\r \"y2\": {\r \"show\": \"true\",\r \"label\": {\r \"text\": \"粉丝\",\r \"position\": \"outer-middle\"\r }\r }\r }\r }); js 抓取分析数据 下面以 chrome 浏览器为例,说明如何利用默认控制台抓取关键数据,本文需要一定的 jQuery 基础. 慕课手记 在目标页面右键选择检查选项,打开默认开发者控制台,点击最左侧的小鼠标箭头,然后选中关键数据,比如浏览量. 此时,开发者控制台自动滚动到元素(Elements)选项卡,在目标数据上右键点击复制(Copy),接着点击复制选择器(Copy selector),现在已经定位到阅读量的节点. 点击控制台(Console)选项卡,并且将选择器更改成 jQuery 选择器,即$(\"复制的选择器\").text(),现在在控制台直接输出内容,看一下能否抓取到浏览量吧! 现在已经成功定位到指定元素,而我们要统计的是全部文章的阅读量,因此需要定位到全部元素. $(\"#articlesList > div:nth-child(1) > div.item-btm.clearfix > div > div:nth-child(1) > em\").text(); 简单分析下文章结构结合选择器分析,可以得知, 浏览,推荐和评论三者文档基本一致,唯一不同之处就是排列顺序而已,因此想要准确定位到浏览数,需要定位到第一个元素,推荐量则是第二个元素,因此类推. 83浏览 1推荐 0评论 弄清楚基本文档结构后,开始着手改造选择器使其定位到全部文章的浏览量,我们做如下改造. $(\"#articlesList div:nth-child(1) > em\").text(); 仅仅保留头部和尾部,再去掉中间部分 > div:nth-child(1) > div.item-btm.clearfix > div > ,这样就轻松定位到全部元素的浏览量了,是不是很简单? 看到控制台输出结果,心里瞬间踏实了,这不刚好是第一页全部文章的浏览量吗?观察输出内容格式可知,我们需要将整个字符串按照空格分割成字符串数组. 需要注意的是,行首还有一个空格哟,因此在分割成字符串数组前,我们先将行首的空格去除掉. // 去除空格前:\" 83浏览 91浏览 114浏览 150浏览 129浏览 175浏览 222浏览 173浏览 225浏览 200浏览 201浏览 217浏览 291浏览 202浏览 229浏览 184浏览 226浏览 155浏览 153浏览 211浏览\" $(\"#articlesList div:nth-child(1) > em\").text().trim(); // 去除空格后: \"83浏览 91浏览 114浏览 150浏览 129浏览 175浏览 222浏览 173浏览 225浏览 200浏览 201浏览 217浏览 291浏览 202浏览 229浏览 184浏览 226浏览 155浏览 153浏览 211浏览\" 现在我们再将这整个字符串按照空格分割成字符串数组. // 分割字符串前: \"83浏览 91浏览 114浏览 150浏览 129浏览 175浏览 222浏览 173浏览 225浏览 200浏览 201浏览 217浏览 291浏览 202浏览 229浏览 184浏览 226浏览 155浏览 153浏览 211浏览\" $(\"#articlesList div:nth-child(1) > em\").text().trim().split(\" \"); // 分割字符串后: [\"83浏览\", \"91浏览\", \"114浏览\", \"150浏览\", \"129浏览\", \"175浏览\", \"222浏览\", \"173浏览\", \"225浏览\", \"200浏览\", \"201浏览\", \"217浏览\", \"291浏览\", \"202浏览\", \"229浏览\", \"184浏览\", \"226浏览\", \"155浏览\", \"153浏览\", \"211浏览\"] 现在我们已经够将整个字符串分割成一个个小的字符串,下面需要再将83浏览中的浏览去掉,仅仅保留数字83. $.each($(\"#articlesList div:nth-child(1) > em\").text().trim().split(\" \"),function(idx,ele){ console.log(ele.substr(0,ele.lastIndexOf(\"浏览\"))); }); 现在我们已经抓取到真正的浏览量,接下来就比较简单了,直接将这些浏览量进行累加即可,需要注意的是,这里的浏览数还是字符串类型,需要转换成数字类型才能进行累加运算哟! //阅读量 var readCount = 0; $.each($(\"#articlesList div:nth-child(1) > em\").text().trim().split(\" \"),function(idx,ele){ readCount += parseInt(ele.substr(0,ele.lastIndexOf(\"浏览\"))); }); console.log(\"阅读量: \" + readCount); 小结 我们以 chrome 浏览器为例,讲解了如何利用自带的控制台工具抓取关键数据,从页面结构分析入口,一步一个脚印提取有效数据,最终从一条数据变成多条数据,进而实现数据的累加统计. 总体来说,还是比较简单的,并不需要太多的基础知识,但还是稍微总结其中涉及到的 jQuery 知识点吧! 定位到具体元素: $(\"这里是复制的选择器\") 定位到具体元素内容: $(\"这里是复制的选择器\").text() 去除字符串首尾空格: $(\"这里是复制的选择器\").text().trim() 将字符串按照空格分割成字符串数组: $(\"这里是复制的选择器\").text().trim().split(\" \") 截取字符串指定部分: ele.substr(0,ele.lastIndexOf(\"浏览\") 将字符串转化成数字类型: parseInt(ele.substr(0,ele.lastIndexOf(\"浏览\"))); 变量累加求和: readCount += parseInt(ele.substr(0,ele.lastIndexOf(\"浏览\"))); 完整示例: //阅读量 var readCount = 0; $.each($(\"#articlesList div:nth-child(1) > em\").text().trim().split(\" \"),function(idx,ele){ readCount += parseInt(ele.substr(0,ele.lastIndexOf(\"浏览\"))); }); console.log(\"阅读量: \" + readCount); //推荐量 var recommendCount = 0; $.each($(\"#articlesList div:nth-child(2) > em\").text().trim().split(\" \"),function(idx,ele){ recommendCount += parseInt(ele.substr(0,ele.lastIndexOf(\"推荐\"))); }); console.log(\"推荐量: \" + recommendCount); //评论量 var commendCount = 0; $.each($(\"#articlesList div:nth-child(3) > em\").text().trim().split(\" \"),function(idx,ele){ commendCount += parseInt(ele.substr(0,ele.lastIndexOf(\"评论\"))); }); console.log(\"评论量: \" + commendCount); 简书 简书的文章数据不一定很规整,比如有的发布文章还没有简书钻,所以阅读量的排列顺序就是不确定的,这一点不像前面介绍的慕课手记,但是简书的关键数据前面是有小图标的,因此我们可以利用图标定位到旁边的数据. 按照前面介绍的步骤,我们仍然定位到阅读量,然而 #note-44847909 > div > div > a:nth-child(2) > i 却不能直接使用,因为我们刚刚分析了,简书不能利用顺序定位只能用图标辅助定位. 所以,还是先看看文档结构,尝试着直接定位到全部的阅读量小图标. 经过分析文章结构,我们可以很轻松定位到全部阅读小图标,当然这是一个元素数组,并不是字符串数组哟! $(\"#list-container .ic-list-read\") 接下来我们看一下能否正确定位到每一个小图标,进而定位到小图标左侧的阅读量. 现在我们已经能够定位到全部的阅读量小图标,现在思考如何定位到旁边的真正阅读量呢? 0.2 2 0 1 昨天 10:39 分析文章结构,我们发现阅读量是小图标的父节点的内容,这一下就简单了,我们顺藤摸瓜定位到父节点自然就能定位到阅读量了! $(\"#list-container .ic-list-read\").each(function(idx,ele){ console.log($(ele).parent().text().trim()); }); 现在既然已经能够定位到阅读量,那么首先累加求和就很简单了. //阅读量 var readCount = 0; $(\"#list-container .ic-list-read\").each(function(idx,ele){ readCount += parseInt($(ele).parent().text().trim()); }); console.log(\"阅读量: \" + readCount); 小结 首先分析文章基本结构发现,简书的阅读量需要定位到阅读量小图标,进而定位到父节点,然后父节点的内容才是真正的阅读量. 定位到真正的阅读量后,一切问题迎刃而解,总结一下新增 jQuery 知识点. 定位到当前节点的父节点: $(ele).parent() 完整示例: //阅读量 var readCount = 0; $(\"#list-container .ic-list-read\").each(function(idx,ele){ readCount += parseInt($(ele).parent().text().trim()); }); console.log(\"阅读量: \" + readCount); //评论量 var commendCount = 0; $(\"#list-container .ic-list-comments\").each(function(idx,ele){ commendCount += parseInt($(ele).parent().text().trim()); }); console.log(\"评论量: \" + commendCount); //喜欢量 var recommendCount = 0; $(\"#list-container .ic-list-like\").each(function(idx,ele){ recommendCount += parseInt($(ele).parent().text().trim()); }); console.log(\"喜欢量: \" + recommendCount); 博客园 博客园的文章列表比较复古,传统的 table 布局,是这几个平台中最简单的,基本上不同怎么介绍. 复制到阅读量选择器: #post-row-10694598 > td:nth-child(4) 此时再结合文章结构,因此我们可以得到全部文章的阅读量选择器. $(\"#post_list td:nth-child(4)\") 接下来需要遍历数组,看看能否抓取到当前页面全部文章的阅读量. $(\"#post_list td:nth-child(4)\").each(function(idx,ele){ console.log($(ele).text().trim()); }); 成功抓取到阅读量,现在开始累加当前页面全部文章的阅读量. //阅读数 var readCount = 0; $(\"#post_list td:nth-child(4)\").each(function(idx,ele){ readCount += parseInt($(ele).text().trim()); }); console.log(\"阅读数: \" + readCount); 小结 中规中矩的传统 table 布局,只需要顺序定位到具体的元素即可,需要注意的是,博客园文章页面采用了分页,如果需要统计全部文章的阅读量,需要将每页的阅读量手动累加计算. 完整示例: //评论数 var commendCount = 0; $(\"#post_list td:nth-child(3)\").each(function(idx,ele){ commendCount += parseInt($(ele).text().trim()); }); console.log(\"评论数: \" + commendCount); //阅读数 var readCount = 0; $(\"#post_list td:nth-child(4)\").each(function(idx,ele){ readCount += parseInt($(ele).text().trim()); }); console.log(\"阅读数: \" + readCount); 腾讯云社区 大致分析腾讯云社区的文章结构,基本上和简书结构差不多,既可以像简书那种采用图标定位方式,也可以像慕课网和博客园那种直接顺序定位. 为了较为精准的定位,现在采用图标定位方式来获取阅读量. #react-root > div:nth-child(1) > div.J-body.com-body.with-bg > section > div > section > div > div.com-log-list > section:nth-child(1) > section > div > div > span > span 既然要根据图标定位,我们需要分析图标和阅读量的关系. 76 3 因此,我们需要做如下改造才能定位到与阅读量. $(\"#react-root .com-i-view\").each(function(idx,ele){ console.log($(ele).next().text().trim()); }); 定位到阅读量,接下来就是简单的数据累加求和了. //阅读量 var readCount = 0; $(\"#react-root .com-i-view\").each(function(idx,ele){ readCount += parseInt($(ele).next().text().trim()); }); console.log(\"阅读量: \" + readCount); 小结 腾讯云社区和简书一样,采用的分页叠加模式,因此需要统计全部文章的话,只需要一直滚动直到加载出全部文章即可. 总结一下涉及到的新增 jQuery 知识点: 获取当前节点的下一个节点: $(ele).next() 完整示例: //阅读量 var readCount = 0; $(\"#react-root .com-i-view\").each(function(idx,ele){ readCount += parseInt($(ele).next().text().trim()); }); console.log(\"阅读量: \" + readCount); //点赞量 var recommendCount = 0; $(\"#react-root .com-i-like\").each(function(idx,ele){ recommendCount += parseInt($(ele).next().text().trim()); }); console.log(\"点赞量: \" + recommendCount); 小结 本文通过 jQuery 方式直接抓取文章数据,简单方便,学习成本低,能够快速上手. 慕课网和博客园的文章列表存在分页,如果需要统计全部文章浏览量,需要将每一页的文章累加,直到最后一页. 简书和腾讯云社区的文章列表虽然也有分支,但会自动累加,所以统计全部文章时只需要先等全部文章加载完毕,再利用 js 脚本一次性统计即可. 好了,本次分享到此结束,如果你觉得本文对你有所帮助,欢迎分享让更多人看到哦,对了,上一篇文章也是解决统计问题的,不过使用的是 java 读取 csv 文件方式,如果有兴趣,也可以看一看. © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"write/faq.html":{"url":"write/faq.html","title":"常见问题","keywords":"","body":"常见问题 The page build failed for the master branch with the following error 问题描述 看到这封邮件,一脸懵逼,本地运行 gitbook 服务是正常渲染的,控制台并没有任何报错,谁知道推送到 github 时就报错了! 登录到 github 网站查看网站源码已经同步过来了,但是静态网站无法同步,本地实在找不到任何报错信息,这让我如何是好? 再看 github 反馈用的邮件中说道,如有问题可以回复邮件(If you have any questions you can contact us by replying to this email.). 然后死马当活马医,尝试阐释了我的问题,请求帮助定位错误日志,没想到当天下午就收到 github 的回复邮件,提供了解决办法! 问题是由于 Liquid Warning: Liquid syntax error (line 334) 错误,然而我确定这部分代码是没有任何问题的,因为这是我改造 gitbook-plugin-tbfed-pagefooter 插件时的一段代码,反复确认后发现并没有复制粘贴出错啊! var moment = require('moment'); module.exports = { book: { assets: './assets', css: [ 'footer.css' ], }, hooks: { 'page:before': function(page) { var _label = '最后更新时间: ', _format = 'YYYY-MM-DD', _copy = 'powered by snowdreams1006' if(this.options.pluginsConfig['tbfed-pagefooter']) { _label = this.options.pluginsConfig['tbfed-pagefooter']['modify_label'] || _label; _format = this.options.pluginsConfig['tbfed-pagefooter']['modify_format'] || _format; var _c = this.options.pluginsConfig['tbfed-pagefooter']['copyright']; _copy = _c ? _c + ' all right reserved，' + _copy : _copy; } var _copy = ''+_copy+''; var str = ' \\n\\n' + _copy + '' + _label + '\\n{{file.mtime | date(\"' + _format + '\")}}\\n'; str += '\\n\\n'+ '\\n\\n'+ '\\n\\n'+ '\\n\\n'; page.content = page.content + str; return page; } }, filters: { date: function(d, format) { return moment(d).format(format) } } }; 来源于 gitbook-plugin-tbfed-pagefooter 插件的 index.js 文件,这里为了兼容 gitalk 插件而集成了相关代码,详情请参考 gitalk 评论插件 解决方案 根据邮件回复,定位到出错代码片段,真的没发现有什么问题啊? 既然已经确定不是我的问题,那很可能就是 github 的问题了,邮件中推荐我使用 Jekyll 进行构建网站,不不不! 既然已经选择 gitbook 搭建静态网站,那就没必要再使用 Jekyll ,我可不想那么麻烦! If you are not using Jekyll you can disable it by including a .nojekyll file in the root of your repository. 所以我不妨试试新增 .nojekyll 文件,说不定就好使了呢! $ touch .nojekyll $ git add .nojekyll $ git commit -m \"add .nojekyll\" $ git push 天不负我!竟然真的好使了,再也没有收到 github 的报错邮件反馈了,源码和网站都正常更新了! 小结 据我推测,可能是 github 误认为我的网站是使用 Jekyll 工具构建的,实际上,是使用 gitbook 构建的! 因此,增加 .nojekyll 文件禁用 Jekyll 工具,自然不会再受相关语法限制而报错了. 所以,遇到问题时,不仅要多思考,更应该寻求官方人员的帮助,即使不回你,你也要尝试一下! © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"other/":{"url":"other/","title":"其他","keywords":"","body":"其他 © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"other/transformation.html":{"url":"other/transformation.html","title":"程序员转型之路","keywords":"","body":"程序员转型之路 视频来自腾讯课堂: 程序员转型之路 如何学习?什么叫理财? 01.如何正确认识学习? 知识: 靠记忆 (20%) 技能: 靠练习 (30%) 态度: 靠发心 (50%) 纸上谈兵一万次,不如战场来一遍 02.谈转型 graph LR product((产品)) -.- management((管理)) management -.- freelance((自由职业)) freelance -.- market((市场)) market -.- entrepreneurship((创业)) 03.如何更高效学习与运用 保持持续性学习 学会跳出自己的\"舒适区\" 思维转变,换个角度看世界 04.学习思路 graph LR empty_cup_mentality[空杯心态] --- closing_comments[关闭评论] closing_comments --- know_and_use[知用合一] know_and_use --- timely_output[及时输出] 如何让自己快速拥有10万+流量,并且快速变现 各大平台特点 抖音 今日头条 微信公众号 知乎 新浪博客 简书 大鱼号 百家号 搜狐自媒体 熊掌号 一点资讯 抖音分为商家版和个人版,成立专门团队,越专业越成功! 到底如何写内容 标题的重要性 字数在20字以内 出乎意料 带数字 给人感觉像故事或干货 人格化定位 引导转发和分享 如何把流量快速变现 如何写出可以直接收钱的文案 如何30分钟学会演讲,客服种种心里障碍 如何复制转型成功的程序员称为自有职业者,月收入是5万+ © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"other/static.html":{"url":"other/static.html","title":"历史统计","keywords":"","body":"历史统计 2019年04月 全网统计 c3.generate({\"bindto\":\"#plugin-chart-5\",\r \"data\": {\r \"x\": \"x\",\r \"columns\": [\r [\r \"x\",\r \"2019-04-01\",\r \"2019-04-02\",\r \"2019-04-03\",\r \"2019-04-04\",\r \"2019-04-05\",\r \"2019-04-06\",\r \"2019-04-07\",\r \"2019-04-08\",\r \"2019-04-09\",\r \"2019-04-10\",\r \"2019-04-11\",\r \"2019-04-12\",\r \"2019-04-13\",\r \"2019-04-14\",\r \"2019-04-15\",\r \"2019-04-16\",\r \"2019-04-17\",\r \"2019-04-18\",\r \"2019-04-19\",\r \"2019-04-20\",\r \"2019-04-21\",\r \"2019-04-22\",\r \"2019-04-23\",\r \"2019-04-24\",\r \"2019-04-25\"\r ],\r [\r \"粉丝\",\r 58,\r 60,\r 59,\r 69,\r 68,\r 68,\r 68,\r 69,\r 71,\r 71,\r 71,\r 72,\r 74,\r 77,\r 80,\r 80,\r 80,\r 80,\r 80,\r 81,\r 83,\r 84,\r 84,\r 84,\r 85\r ],\r [\r \"阅读\",\r 13809,\r 14757,\r 15707,\r 18521,\r 19268,\r 20532,\r 21328,\r 22418,\r 22933,\r 23118,\r 24139,\r 24490,\r 24970,\r 25806,\r 26505,\r 27300,\r 27300,\r 27814,\r 28286,\r 28881,\r 29226,\r 29938,\r 30262,\r 30616,\r 30844\r ]\r ],\r \"axes\": {\r \"粉丝\": \"y2\"\r },\r \"types\": {\r \"粉丝\": \"bar\"\r }\r },\r \"axis\": {\r \"x\": {\r \"type\": \"timeseries\",\r \"tick\": {\r \"format\": \"%Y-%m-%d\"\r }\r },\r \"y2\": {\r \"show\": \"true\",\r \"label\": {\r \"text\": \"粉丝\",\r \"position\": \"outer-middle\"\r }\r }\r }\r }); 平台统计 慕课手记 慕课手记 : https://www.imooc.com/u/5224488/articles c3.generate({\"bindto\":\"#plugin-chart-6\",\r \"data\": {\r \"x\": \"x\",\r \"columns\": [\r [\r \"x\",\r \"2019-04-01\",\r \"2019-04-02\",\r \"2019-04-03\",\r \"2019-04-04\",\r \"2019-04-05\",\r \"2019-04-06\",\r \"2019-04-07\",\r \"2019-04-08\",\r \"2019-04-09\",\r \"2019-04-10\",\r \"2019-04-11\",\r \"2019-04-12\",\r \"2019-04-13\",\r \"2019-04-14\",\r \"2019-04-15\",\r \"2019-04-16\",\r \"2019-04-17\",\r \"2019-04-18\",\r \"2019-04-19\",\r \"2019-04-20\",\r \"2019-04-21\",\r \"2019-04-22\",\r \"2019-04-23\",\r \"2019-04-24\",\r \"2019-04-25\"\r ],\r [\r \"粉丝\",\r 8,\r 8,\r 8,\r 9,\r 9,\r 9,\r 9,\r 9,\r 9,\r 9,\r 9,\r 9,\r 9,\r 10,\r 12,\r 12,\r 12,\r 12,\r 12,\r 12,\r 12,\r 12,\r 12,\r 12,\r 12\r ],\r [\r \"阅读量\",\r 3508,\r 3645,\r 3650,\r 4356,\r 4528,\r 4864,\r 5276,\r 5593,\r 5872,\r 5912,\r 6271,\r 6400,\r 6621,\r 6880,\r 7195,\r 7516,\r 7516,\r 7647,\r 7758,\r 7913,\r 8065,\r 8379,\r 8483,\r 8559,\r 8633\r ],\r [\r \"手记\",\r 32,\r 33,\r 34,\r 36,\r 38,\r 39,\r 40,\r 41,\r 42,\r 42,\r 44,\r 44,\r 45,\r 46,\r 47,\r 47,\r 47,\r 47,\r 47,\r 49,\r 51,\r 51,\r 51,\r 51,\r 51\r ],\r [\r \"推荐\",\r 36,\r 36,\r 37,\r 39,\r 41,\r 42,\r 48,\r 49,\r 50,\r 50,\r 52,\r 52,\r 53,\r 54,\r 55,\r 55,\r 55,\r 55,\r 55,\r 57,\r 59,\r 59,\r 59,\r 59,\r 59\r ],\r [\r \"积分\",\r 107,\r 118,\r 118,\r 130,\r 130,\r 141,\r 152,\r 173,\r 173,\r 173,\r 194,\r 195,\r 196,\r 206,\r 217,\r 219,\r 219,\r 220,\r 218,\r 228,\r 234,\r 246,\r 246,\r 246,\r 247\r ]\r ],\r \"axes\": {\r \"粉丝\": \"y2\"\r },\r \"types\": {\r \"粉丝\": \"bar\"\r }\r },\r \"axis\": {\r \"x\": {\r \"type\": \"timeseries\",\r \"tick\": {\r \"format\": \"%Y-%m-%d\"\r }\r },\r \"y2\": {\r \"show\": \"true\",\r \"label\": { \r \"text\": \"粉丝\",\r \"position\": \"outer-middle\"\r }\r } \r }\r }); 简书 简书 : https://www.jianshu.com/u/577b0d76ab87 c3.generate({\"bindto\":\"#plugin-chart-7\",\r \"data\": {\r \"x\": \"x\",\r \"columns\": [\r [\r \"x\",\r \"2019-04-01\",\r \"2019-04-02\",\r \"2019-04-03\",\r \"2019-04-04\",\r \"2019-04-05\",\r \"2019-04-06\",\r \"2019-04-07\",\r \"2019-04-08\",\r \"2019-04-09\",\r \"2019-04-10\",\r \"2019-04-11\",\r \"2019-04-12\",\r \"2019-04-13\",\r \"2019-04-14\",\r \"2019-04-15\",\r \"2019-04-16\",\r \"2019-04-17\",\r \"2019-04-18\",\r \"2019-04-19\",\r \"2019-04-20\",\r \"2019-04-21\",\r \"2019-04-22\",\r \"2019-04-23\",\r \"2019-04-24\",\r \"2019-04-25\"\r ],\r [\r \"粉丝\",\r 7,\r 7,\r 6,\r 7,\r 6,\r 5,\r 5,\r 5,\r 5,\r 5,\r 5,\r 5,\r 7,\r 7,\r 7,\r 7,\r 7,\r 7,\r 7,\r 8,\r 9,\r 10,\r 10,\r 10,\r 12\r ],\r [\r \"阅读量\",\r 343,\r 335,\r 342,\r 358,\r 374,\r 443,\r 468,\r 512,\r 548,\r 552,\r 611,\r 624,\r 655,\r 697,\r 712,\r 758,\r 758,\r 824,\r 846,\r 878,\r 891,\r 922,\r 948,\r 1017,\r 1083\r ],\r [\r \"文章\",\r 33,\r 34,\r 35,\r 37,\r 39,\r 40,\r 41,\r 42,\r 43,\r 43,\r 46,\r 46,\r 47,\r 48,\r 49,\r 49,\r 49,\r 49,\r 49,\r 50,\r 52,\r 52,\r 52,\r 52,\r 52\r ],\r [\r \"喜欢\",\r 57,\r 58,\r 59,\r 60,\r 62,\r 64,\r 65,\r 67,\r 68,\r 68,\r 68,\r 71,\r 71,\r 72,\r 73,\r 74,\r 78,\r 78,\r 78,\r 78,\r 80,\r 82,\r 82,\r 85,\r 86,\r 86\r ],\r [\r \"简书钻\",\r 27,\r 28,\r 28,\r 9,9\r ,9,\r 10,\r 10,\r 10,\r 10,\r 11,\r 11,\r 25,\r 26,\r 58,\r 60,\r 60,\r 61,\r 48,\r 61,\r 62,\r 34,\r 34,\r 42,\r 40\r ]\r ],\r \"axes\": {\r \"粉丝\": \"y2\"\r },\r \"types\": {\r \"粉丝\": \"bar\"\r }\r },\r \"axis\": {\r \"x\": {\r \"type\": \"timeseries\",\r \"tick\": {\r \"format\": \"%Y-%m-%d\"\r }\r },\r \"y2\": {\r \"show\": \"true\",\r \"label\": { \r \"text\": \"粉丝\",\r \"position\": \"outer-middle\"\r }\r }\r }\r }); CSDN CSDN : https://blog.csdn.net/weixin_38171180 c3.generate({\"bindto\":\"#plugin-chart-8\",\r \"data\": {\r \"x\": \"x\",\r \"columns\": [\r [\r \"x\",\r \"2019-04-01\",\r \"2019-04-02\",\r \"2019-04-03\",\r \"2019-04-04\",\r \"2019-04-05\",\r \"2019-04-06\",\r \"2019-04-07\",\r \"2019-04-08\",\r \"2019-04-09\",\r \"2019-04-10\",\r \"2019-04-11\",\r \"2019-04-12\",\r \"2019-04-13\",\r \"2019-04-14\",\r \"2019-04-15\",\r \"2019-04-16\",\r \"2019-04-17\",\r \"2019-04-18\",\r \"2019-04-19\",\r \"2019-04-20\",\r \"2019-04-21\",\r \"2019-04-22\",\r \"2019-04-23\",\r \"2019-04-24\",\r \"2019-04-25\"\r ],\r [\r \"粉丝\",\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 0\r ],\r [\r \"访问量\",\r 1565,\r 1634,\r 1665,\r 1705,\r 1723,\r 1769,\r 1829,\r 1867,\r 1907,\r 1911,\r 1950,\r 1962,\r 1981,\r 2061,\r 2246,\r 2311,\r 2311,\r 2321,\r 2335,\r 2351,\r 2363,\r 2394,\r 2412,\r 2420,\r 2424\r ],\r [\r \"原创\",\r 31,\r 32,\r 33,\r 34,\r 36,\r 38,\r 39,\r 40,\r 41,\r 41,\r 43,\r 43,\r 44,\r 45,\r 46,\r 46,\r 46,\r 46,\r 46,\r 48,\r 50,\r 50,\r 50,\r 50,\r 50\r ],\r [\r \"喜欢\",\r 31,\r 32,\r 33,\r 34,\r 36,\r 37,\r 37,\r 38,\r 38,\r 38,\r 39,\r 39,\r 40,\r 41,\r 42,\r 42,\r 42,\r 42,\r 42,\r 44,\r 46,\r 46,\r 46,\r 46,\r 46\r ], \r [\r \"积分\",\r 353,\r 364,\r 376,\r 397,\r 419,\r 430,\r 440,\r 450,\r 461,\r 461,\r 482,\r 482,\r 493,\r 504,\r 516,\r 516,\r 516,\r 516,\r 516,\r 538,\r 560,\r 560,\r 560,\r 560\r ]\r ],\r \"axes\": {\r \"粉丝\": \"y2\"\r },\r \"types\": {\r \"粉丝\": \"bar\"\r }\r },\r \"axis\": {\r \"x\": {\r \"type\": \"timeseries\",\r \"tick\": {\r \"format\": \"%Y-%m-%d\"\r }\r },\r \"y2\": {\r \"show\": \"true\",\r \"label\": {\r \"text\": \"粉丝\",\r \"position\": \"outer-middle\"\r }\r }\r }\r }); 博客园 博客园 : https://www.cnblogs.com/snowdreams1006/ c3.generate({\"bindto\":\"#plugin-chart-9\",\r \"data\": {\r \"x\": \"x\",\r \"columns\": [\r [\r \"x\",\r \"2019-04-01\",\r \"2019-04-02\",\r \"2019-04-03\",\r \"2019-04-04\",\r \"2019-04-05\",\r \"2019-04-06\",\r \"2019-04-07\",\r \"2019-04-08\",\r \"2019-04-09\",\r \"2019-04-10\",\r \"2019-04-11\",\r \"2019-04-12\",\r \"2019-04-13\",\r \"2019-04-14\",\r \"2019-04-15\",\r \"2019-04-16\",\r \"2019-04-17\",\r \"2019-04-18\",\r \"2019-04-19\",\r \"2019-04-20\",\r \"2019-04-21\",\r \"2019-04-22\",\r \"2019-04-23\",\r \"2019-04-24\",\r \"2019-04-25\"\r ],\r [\r \"粉丝\",\r 17,\r 17,\r 17,\r 18,\r 18,\r 18,\r 18,\r 18,\r 18,\r 18,\r 18,\r 18,\r 18,\r 19,\r 19,\r 19,\r 19,\r 19,\r 19,\r 19,\r 20,\r 20,\r 20,\r 20,\r 20\r ],\r [\r \"阅读数\",\r 3889,\r 4096,\r 4207,\r 4388,\r 4411,\r 4435,\r 4471,\r 4728,\r 4866,\r 4867,\r 5189,\r 5274,\r 5359,\r 5448,\r 5503,\r 5562,\r 5562,\r 5588,\r 5609,\r 5706,\r 5802,\r 5887,\r 5909,\r 5941,\r 5962\r ],\r [\r \"随笔\",\r 31,\r 32,\r 33,\r 34,\r 36,\r 38,\r 39,\r 41,\r 41,\r 41,\r 43,\r 43,\r 44,\r 45,\r 47,\r 47,\r 47,\r 47,\r 47,\r 47,\r 47,\r 51,\r 51,\r 51,\r 51\r ],\r [\r \"评论数\",\r 16,\r 16,\r 16,\r 16,\r 16,\r 16,\r 16,\r 16,\r 16,\r 16,\r 16,\r 16,\r 16,\r 18,\r 18,\r 18,\r 18,\r 18,\r 18,\r 18,\r 18,\r 18,\r 18,\r 18,\r 18\r ]\r ],\r \"axes\": {\r \"粉丝\": \"y2\"\r },\r \"types\": {\r \"粉丝\": \"bar\"\r }\r },\r \"axis\": {\r \"x\": {\r \"type\": \"timeseries\",\r \"tick\": {\r \"format\": \"%Y-%m-%d\"\r }\r },\r \"y2\": {\r \"show\": \"true\",\r \"label\": {\r \"text\": \"粉丝\",\r \"position\": \"outer-middle\"\r }\r }\r }\r }); 掘金 掘金 : https://juejin.im/user/582d5cb667f356006331e586 c3.generate({\"bindto\":\"#plugin-chart-10\",\r \"data\": {\r \"x\": \"x\",\r \"columns\": [\r [\r \"x\",\r \"2019-04-01\",\r \"2019-04-02\",\r \"2019-04-03\",\r \"2019-04-04\",\r \"2019-04-05\",\r \"2019-04-06\",\r \"2019-04-07\",\r \"2019-04-08\",\r \"2019-04-09\",\r \"2019-04-10\",\r \"2019-04-11\",\r \"2019-04-12\",\r \"2019-04-13\",\r \"2019-04-14\",\r \"2019-04-15\",\r \"2019-04-16\",\r \"2019-04-17\",\r \"2019-04-18\",\r \"2019-04-19\",\r \"2019-04-20\",\r \"2019-04-21\",\r \"2019-04-22\",\r \"2019-04-23\",\r \"2019-04-24\",\r \"2019-04-25\" \r ],\r [\r \"关注者\",\r 4,\r 5,\r 5,\r 6,\r 6,\r 6,\r 6,\r 6,\r 7,\r 7,\r 7,\r 7,\r 7,\r 8,\r 8,\r 8,\r 8,\r 8,\r 8,\r 8,\r 8,\r 8,\r 8,\r 8,\r 8\r ],\r [\r \"阅读数\",\r 402,\r 500,\r 562,\r 703,\r 712,\r 725,\r 745,\r 766,\r 813,\r 813,\r 881,\r 920,\r 932,\r 987,\r 1048,\r 1079,\r 1079,\r 1084,\r 1096,\r 1123,\r 1139,\r 1166,\r 1174,\r 1195,\r 1218\r ],\r [\r \"原创\",\r 31,\r 32,\r 33,\r 35,\r 37,\r 38,\r 39,\r 40,\r 41,\r 41,\r 43,\r 43,\r 44,\r 45,\r 46,\r 46,\r 46,\r 46,\r 46,\r 48,\r 50,\r 50,\r 50,\r 50,\r 50\r ],\r [\r \"点赞数\",\r 36,\r 38,\r 40,\r 47,\r 50,\r 51,\r 52,\r 56,\r 57,\r 57,\r 59,\r 59,\r 60,\r 64,\r 65,\r 65,\r 65,\r 65,\r 65,\r 67,\r 69,\r 70,\r 70,\r 72,\r 72\r ]\r ],\r \"axes\": {\r \"关注者\": \"y2\"\r },\r \"types\": {\r \"关注者\": \"bar\"\r }\r },\r \"axis\": {\r \"x\": {\r \"type\": \"timeseries\",\r \"tick\": {\r \"format\": \"%Y-%m-%d\"\r }\r },\r \"y2\": {\r \"show\": \"true\",\r \"label\": {\r \"text\": \"关注者\",\r \"position\": \"outer-middle\"\r }\r }\r }\r }); 思否 思否 : https://segmentfault.com/blog/snowdreams1006 c3.generate({\"bindto\":\"#plugin-chart-11\",\r \"data\": {\r \"x\": \"x\",\r \"columns\": [\r [\r \"x\",\r \"2019-04-01\",\r \"2019-04-02\",\r \"2019-04-03\",\r \"2019-04-04\",\r \"2019-04-05\",\r \"2019-04-06\",\r \"2019-04-07\",\r \"2019-04-08\",\r \"2019-04-09\",\r \"2019-04-10\",\r \"2019-04-11\",\r \"2019-04-12\",\r \"2019-04-13\",\r \"2019-04-14\",\r \"2019-04-15\",\r \"2019-04-16\",\r \"2019-04-17\",\r \"2019-04-18\",\r \"2019-04-19\",\r \"2019-04-20\",\r \"2019-04-21\",\r \"2019-04-22\",\r \"2019-04-23\",\r \"2019-04-24\",\r \"2019-04-25\"\r ],\r [\r \"粉丝\",\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1\r ],\r [\r \"阅读量\",\r 1382,\r 1483,\r 1548,\r 1676,\r 1770,\r 1891,\r 2004,\r 2087,\r 2133,\r 2223,\r 2341,\r 2378,\r 2446,\r 2645,\r 2697,\r 2810,\r 2810,\r 2862,\r 2926,\r 3006,\r 3057,\r 3171,\r 3236,\r 3296,\r 3340\r ],\r [\r \"文章\",\r 33,\r 34,\r 35,\r 36,\r 39,\r 40,\r 41,\r 42,\r 43,\r 43,\r 45,\r 45,\r 46,\r 47,\r 48,\r 48,\r 48,\r 48,\r 48,\r 50,\r 52,\r 52,\r 52,\r 52,\r 52\r ],\r [\r \"点赞数\",\r 12,\r 12,\r 13,\r 13,\r 13,\r 13,\r 15,\r 16,\r 17,\r 17,\r 17,\r 17,\r 17,\r 17,\r 17,\r 17,\r 17,\r 17,\r 17,\r 17,\r 17,\r 17,\r 17,\r 17,\r 17\r ],\r [\r \"声望\",\r 43,\r 43,\r 43,\r 43,\r 43,\r 43,\r 49,\r 52,\r 55,\r 55,\r 55,\r 55,\r 55,\r 55,\r 55,\r 55,\r 55,\r 55,\r 55,\r 55,\r 55,\r 55,\r 55,\r 55,\r 55\r ]\r ],\r \"axes\": {\r \"粉丝\": \"y2\"\r },\r \"types\": {\r \"粉丝\": \"bar\"\r }\r },\r \"axis\": {\r \"x\": {\r \"type\": \"timeseries\",\r \"tick\": {\r \"format\": \"%Y-%m-%d\"\r }\r },\r \"y2\": {\r \"show\": \"true\",\r \"label\": {\r \"text\": \"粉丝\",\r \"position\": \"outer-middle\"\r }\r }\r }\r }); 开源中国 开源中国 : https://my.oschina.net/snowdreams1006 c3.generate({\"bindto\":\"#plugin-chart-12\",\r \"data\": {\r \"x\": \"x\",\r \"columns\": [\r [\r \"x\",\r \"2019-04-01\",\r \"2019-04-02\",\r \"2019-04-03\",\r \"2019-04-04\",\r \"2019-04-05\",\r \"2019-04-06\",\r \"2019-04-07\",\r \"2019-04-08\",\r \"2019-04-09\",\r \"2019-04-10\",\r \"2019-04-11\",\r \"2019-04-12\",\r \"2019-04-13\",\r \"2019-04-14\",\r \"2019-04-15\",\r \"2019-04-16\",\r \"2019-04-17\",\r \"2019-04-18\",\r \"2019-04-19\",\r \"2019-04-20\",\r \"2019-04-21\",\r \"2019-04-22\",\r \"2019-04-23\",\r \"2019-04-24\",\r \"2019-04-25\"\r ],\r [\r \"粉丝\",\r 12,\r 13,\r 13,\r 13,\r 13,\r 13,\r 13,\r 14,\r 15,\r 15,\r 15,\r 15,\r 15,\r 15,\r 16,\r 16,\r 16,\r 16,\r 16,\r 16,\r 16,\r 16,\r 16,\r 16,\r 16,\r 16\r ],\r [\r \"访问量\",\r 2496,\r 2831,\r 3490,\r 3947,\r 3993,\r 4066,\r 4174,\r 4391,\r 4410,\r 4455,\r 4507,\r 4535,\r 4579,\r 4582,\r 4692,\r 4749,\r 4749,\r 4768,\r 4790,\r 4800,\r 4802,\r 4823,\r 4837,\r 4850,\r 4860\r ],\r [\r \"博文\",\r 33,\r 34,\r 35,\r 37,\r 39,\r 40,\r 41,\r 42,\r 43,\r 43,\r 44,\r 44,\r 45,\r 46,\r 47,\r 47,\r 47,\r 47,\r 47,\r 49,\r 51,\r 51,\r 51,\r 51,\r 51\r ],\r [\r \"推荐\",\r 6,\r 7,\r 7,\r 7,\r 7,\r 7,\r 8,\r 8,\r 8,\r 8,\r 8,\r 8,\r 9,\r 11,\r 11,\r 11,\r 11,\r 11,\r 11,\r 11,\r 11,\r 11,\r 11,\r 11,\r 11\r ],\r [\r \"积分\",\r 5,\r 5,\r 6,\r 6,\r 7,\r 7,\r 7,\r 7,\r 7,\r 7,\r 8,\r 8,\r 8,\r 9,\r 9,\r 9,\r 9,\r 9,\r 9,\r 9,\r 9,\r 9,\r 9,\r 9,\r 9\r ]\r ],\r \"axes\": {\r \"粉丝\": \"y2\"\r },\r \"types\": {\r \"粉丝\": \"bar\"\r }\r },\r \"axis\": {\r \"x\": {\r \"type\": \"timeseries\",\r \"tick\": {\r \"format\": \"%Y-%m-%d\"\r }\r },\r \"y2\": {\r \"show\": \"true\",\r \"label\": {\r \"text\": \"粉丝\",\r \"position\": \"outer-middle\"\r }\r }\r }\r }); 腾讯云社区 腾讯云社区 : https://cloud.tencent.com/developer/user/2952369/activities c3.generate({\"bindto\":\"#plugin-chart-13\",\r \"data\": {\r \"x\": \"x\",\r \"columns\": [\r [\r \"x\",\r \"2019-04-04\",\r \"2019-04-05\",\r \"2019-04-06\",\r \"2019-04-07\",\r \"2019-04-08\",\r \"2019-04-09\",\r \"2019-04-10\",\r \"2019-04-11\",\r \"2019-04-12\",\r \"2019-04-13\",\r \"2019-04-14\",\r \"2019-04-15\",\r \"2019-04-16\",\r \"2019-04-17\",\r \"2019-04-18\",\r \"2019-04-19\",\r \"2019-04-20\",\r \"2019-04-21\",\r \"2019-04-22\",\r \"2019-04-23\",\r \"2019-04-24\",\r \"2019-04-25\"\r ],\r [\r \"粉丝\",\r 13,\r 13,\r 13,\r 13,\r 13,\r 13,\r 13,\r 13,\r 13,\r 13,\r 13,\r 13,\r 13,\r 13,\r 13,\r 13,\r 13,\r 13,\r 13,\r 13,\r 13,\r 13\r ],\r [\r \"阅读量\",\r 1192,\r 1561,\r 2131,\r 2144,\r 2149,\r 2158,\r 2159,\r 2163,\r 2165,\r 2165,\r 2174,\r 2180,\r 2283,\r 2283,\r 2487,\r 2691,\r 2869,\r 2872,\r 2959,\r 3022,\r 3095,\r 3107\r ],\r [\r \"文章\",\r 34,\r 34,\r 34,\r 34,\r 34,\r 34,\r 34,\r 34,\r 34,\r 34,\r 34,\r 34,\r 40,\r 40,\r 44,\r 44,\r 44,\r 44,\r 47,\r 47,\r 47,\r 47\r ],\r [\r \"点赞\",\r 107,\r 108,\r 110,\r 107,\r 107,\r 107,\r 107,\r 107,\r 107,\r 107,\r 107,\r 107,\r 126,\r 126,\r 130,\r 130,\r 130,\r 130,\r 141,\r 141,\r 141,\r 141\r ]\r ],\r \"axes\": {\r \"粉丝\": \"y2\"\r },\r \"types\": {\r \"粉丝\": \"bar\"\r }\r },\r \"axis\": {\r \"x\": {\r \"type\": \"timeseries\",\r \"tick\": {\r \"format\": \"%Y-%m-%d\"\r }\r },\r \"y2\": {\r \"show\": \"true\",\r \"label\": {\r \"text\": \"粉丝\",\r \"position\": \"outer-middle\"\r }\r }\r }\r }); B站专栏 B站专栏 : https://member.bilibili.com/v2#/upload-manager/text c3.generate({\"bindto\":\"#plugin-chart-14\",\r \"data\": {\r \"x\": \"x\",\r \"columns\": [\r [\r \"x\",\r \"2019-04-01\",\r \"2019-04-02\",\r \"2019-04-03\",\r \"2019-04-04\",\r \"2019-04-05\",\r \"2019-04-06\",\r \"2019-04-07\",\r \"2019-04-08\",\r \"2019-04-09\",\r \"2019-04-10\",\r \"2019-04-11\",\r \"2019-04-12\",\r \"2019-04-13\",\r \"2019-04-14\",\r \"2019-04-15\",\r \"2019-04-16\", \r \"2019-04-17\",\r \"2019-04-18\", \"2019-04-19\",\r \"2019-04-20\",\r \"2019-04-21\",\r \"2019-04-22\",\r \"2019-04-23\",\r \"2019-04-24\",\r \"2019-04-25\" \r ],\r [\r \"粉丝\",\r 1,\r 1,\r 1,\r 1,\r 1,\r 2,\r 2,\r 2,\r 2,\r 2,\r 2,\r 3,\r 3,\r 3,\r 3,\r 3,\r 3,\r 3,\r 3,\r 3,\r 3,\r 3,\r 3,\r 3,\r 3\r ],\r [\r \"阅读量\",\r 179,\r 184,\r 190,\r 196,\r 196,\r 208,\r 217,\r 225,\r 226,\r 226,\r 226,\r 232,\r 232,\r 232,\r 232,\r 232,\r 232,\r 235,\r 235,\r 235,\r 235,\r 237,\r 241,\r 243,\r 244\r ],\r [\r \"投稿\",\r 32,\r 33,\r 34,\r 36,\r 38,\r 39,\r 40,\r 41,\r 41,\r 41,\r 42,\r 42,\r 42,\r 42,\r 42,\r 42,\r 42,\r 42,\r 42,\r 42,\r 42,\r 42,\r 42,\r 42,\r 42\r ],\r [\r \"点赞\",\r 32,\r 33,\r 34,\r 36,\r 38,\r 38,\r 39,\r 40,\r 40,\r 40,\r 41,\r 41,\r 41,\r 41,\r 41,\r 41,\r 41,\r 41,\r 41,\r 41,\r 41,\r 41,\r 41,\r 41,\r 42\r ],\r [\r \"收藏\",\r 6,\r 6,\r 6,\r 6,\r 6,\r 6,\r 6,\r 7,\r 7,\r 7,\r 7,\r 7,\r 7,\r 7,\r 7,\r 7,\r 7,\r 7,\r 7,\r 7,\r 7,\r 7,\r 8,\r 8,\r 9\r ],\r [\r \"投币\",\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1,\r 1\r ]\r ],\r \"axes\": {\r \"粉丝\": \"y2\"\r },\r \"types\": {\r \"粉丝\": \"bar\"\r }\r },\r \"axis\": {\r \"x\": {\r \"type\": \"timeseries\",\r \"tick\": {\r \"format\": \"%Y-%m-%d\"\r }\r },\r \"y2\": {\r \"show\": \"true\",\r \"label\": {\r \"text\": \"粉丝\",\r \"position\": \"outer-middle\"\r }\r }\r }\r }); 2019年03月 2019-03-31 简书 : 5粉丝,32文章,32755字数,56收获喜欢,27简书钻. CSDN : 30原创,1粉丝,30喜欢,0评论,1399访问,342积分,28万+排名. 博客园 : 30随笔,0文章,17粉丝,16评论. 掘金 : 30原创,4关注者,35点赞数,396阅读数. 开源中国 : 32博文,6推荐,11粉丝,4积分,123访问. segmentfault : 32文章,1粉丝,43声望,1217阅读量,13点赞数. 慕课手记 : 31手记,42165经验,88积分,8粉丝. B站专栏 : 172阅读量+7,2评论0,31点赞+0,6收藏+0,1投币0. 微信公众号 : 25阅读,0转发,0收藏,7用户,1新增,0取关. 2019-03-30 简书 : 5粉丝,31文章,31653字数,55收获喜欢,27简书钻. CSDN : 29原创,1粉丝,29喜欢,0评论,1384访问,331积分,29万+排名. 博客园 : 28随笔,0文章,16粉丝,16评论. 掘金 : 29原创,4关注者,34点赞数,393阅读数,0评论数. 开源中国 : 31博文,6推荐,11粉丝,4积分,212访问. segmentfault : 31文章,1粉丝,40声望,1174阅读量,12点赞数. 慕课手记 : 30手记,42165经验,87积分,7粉丝. B站专栏 : 172阅读量+7,2评论0,31点赞+0,6收藏+1,1投币0. 微信公众号 : 25阅读,0转发,0收藏,6用户,0新增,0取关. 2019-03-29 简书 : 4粉丝,29文章,28905字数,53收获喜欢,26简书钻. CSDN : 28原创,1粉丝,27喜欢,0评论,1348访问,309积分,29万+排名. 博客园 : 27随笔,0文章,16粉丝,16评论. 掘金 : 28原创,4关注者,32点赞数,388阅读数,0评论数. 开源中国 : 29博文,6推荐,10粉丝,4积分,378访问. segmentfault : 29文章,1粉丝,40声望,1094阅读量,12点赞数. 慕课手记 : 28手记,42165经验,76积分,6粉丝. B站专栏 : 165阅读量+13,2评论0,31点赞+4,6收藏+1,1投币0. 微信公众号 : 38阅读,0转发,0收藏,6用户,0新增,0取关. 2019-03-28 简书 : 1粉丝,28文章,28170字数,52收获喜欢,25简书钻. CSDN : 27原创,1粉丝,26喜欢,0评论,1300访问,297积分,31万+排名. 博客园 : 27随笔,0文章,16粉丝,16评论. 掘金 : 25原创,4关注者,29点赞数,383阅读数,0评论数. 开源中国 : 26博文,5推荐,10粉丝,4积分,282访问. segmentfault : 26文章,1粉丝,28声望,971阅读量,8点赞数. 慕课手记 : 25手记,42085经验,56积分,6粉丝. B站专栏 : 152阅读量+7,2评论0,27点赞+1,5收藏+1,1投币0. 微信公众号 : 22阅读,0转发,0收藏,6用户,0新增,0取关. 2019-03-27 简书 : 1粉丝,27文章,27348字数,50收获喜欢,25简书钻. CSDN : 26原创,1粉丝,25喜欢,0评论,1267访问,287积分,32万+排名. 博客园 : 25随笔,0文章,16粉丝,16评论. 掘金 : 24原创,4关注者,28点赞数,382阅读数,0评论数. 开源中国 : 25博文,5推荐,10粉丝,4积分,196访问. segmentfault : 25文章,1粉丝,14声望,893阅读量,5点赞数. 慕课手记 : 24手记,41985经验,55积分,6粉丝. B站专栏 : 145阅读量+7,2评论0,26点赞+1,4收藏0,1投币0. 微信公众号 : 16阅读,0转发,0收藏,6用户,0新增,0取关. 2019-03-26 简书 : 1粉丝,26文章,26658字数,49收获喜欢,24简书钻. CSDN : 25原创,1粉丝,23喜欢,0评论,1219访问,275积分,35万+排名. 博客园 : 24随笔,0文章,12粉丝,14评论. 掘金 : 23原创,4关注者,27点赞数,375阅读数,0评论数. 开源中国 : 24博文,3推荐,6粉丝,4积分,123访问. segmentfault : 24文章,0粉丝,14声望,817阅读量,4点赞数. 慕课手记 : 23手记,41895经验,45积分,4粉丝. B站专栏 : 138阅读量+34,2评论0,25点赞+2,4收藏0,1投币0. 微信公众号 : 20文章,36阅读,0转发,0收藏,6用户,2新增,0取关. 2019-03-25 简书 : 0粉丝,25文章,26075字数,28收获喜欢,24简书钻. CSDN : 24原创,1粉丝,23喜欢,0评论,1188访问,265积分,35万+排名. 博客园 : 23随笔,0文章,11粉丝,14评论. 掘金 : 22原创,4关注者,26点赞数,367阅读数,0评论数. 开源中国 : 23博文,3推荐,5粉丝,2积分,45访问. segmentfault : 23文章,0粉丝,14声望,779阅读量,4点赞数. 慕课手记 : 22手记,41855经验,33积分,4粉丝. B站专栏 : 98阅读量+12,2评论2,22点赞+2,3收藏+0,1投币+1. 2019-03-24 简书 : 0粉丝,24文章,23850字数,27收获喜欢,24简书钻. CSDN : 23原创,1粉丝,23喜欢,0评论,1151访问,255积分,36万+排名. 博客园 : 22随笔,0文章,10粉丝,14评论. 掘金 : 21原创,4关注者,25点赞数,361阅读数,0评论数. 开源中国 : 22博文,2推荐,4粉丝,2积分,34访问. segmentfault : 22文章,0粉丝,11声望,747阅读量,3点赞数. 慕课手记 : 21手记,41835经验,19积分,2粉丝. B站专栏 : 86阅读量+4,0评论0,20点赞0,3收藏+0,0投币0. 2019-03-23 简书 : 0粉丝,23文章,21331字数,26收获喜欢,24简书钻. CSDN : 22原创,1粉丝,21喜欢,0评论,1123访问,243积分,37万+排名. 博客园 : 21随笔,0文章,9粉丝,14评论. 掘金 : 20原创,4关注者,24点赞数,356阅读数,0评论数. 开源中国 : 21博文,2推荐,4粉丝,2积分,180访问. segmentfault : 21文章,0粉丝,5声望. 慕课手记 : 20手记,41835经验,19积分,2粉丝. B站专栏 : 82阅读量+23,0评论0,20点赞+5,3收藏+0,0投币0. 2019-03-22 简书 : 0粉丝,22文章,20543字数,25收获喜欢,24简书钻. CSDN : 21原创,1粉丝,21喜欢,0评论,1078访问,233积分,38万+排名. 博客园 : 20随笔,0文章,9粉丝,12评论. 掘金 : 19原创,4关注者,23点赞数,352阅读数,0评论数. 开源中国 : 20博文,2推荐,4粉丝,1积分,178访问. segmentfault : 19文章,0粉丝,5声望. 慕课手记 : 18手记,41645经验,18积分,1粉丝. B站专栏 : 59阅读量+20,0评论0,15点赞+8,3收藏+1,0投币0. 2019-03-21 简书 : 0粉丝,20文章,18420字数,23收获喜欢,23简书钻. CSDN : 19原创,1粉丝,19喜欢,0评论,974访问,211积分,96万+排名. 博客园 : 18随笔,0文章,5粉丝,4评论. 掘金 : 17原创,4关注者,20点赞数,295阅读数,0评论数. 开源中国 : 18博文,1推荐,3粉丝,0积分,160访问. segmentfault : 18文章,0粉丝,5声望. 慕课手记 : 16手记,41615经验,14积分,1粉丝. © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"other/me.html":{"url":"other/me.html","title":"关于作者","keywords":"","body":"关于作者 申请认证慕课网作者 个人简介 慕课网昵称是雪之梦技术驿站,真实姓名孙坡,目前工作于浙江省宁波市慈溪市,16年本科毕业距今近3年,就职于宁波米联物联科技有限公司(慈溪赛科软件有限公司)公司担任java 后台软件开发工程师,负责最物流系列产品研发管理. 联系方式 微信: vae5731 (枫林无归) 开发或者设计经验 入职初期主要负责手机 App 开发,采用 Dcloud 公司的Html5+ 技术实现一套代码跨平台运行,包括 android 和 ios 两大主流平台. 入门前端开发后逐步向后端开发方向演进,由最初单纯为手机端编写 api 接口到搭建后台项目,再到独当一面重新设计后台框架,逐步演变成全栈工程师. 作为前端工程师: 擅长 js,css,html5 等前端基础,熟练使用 vue.js,webpack 等技术栈,能够独立编写跨多端运行的 app. 作为后端工程师: 擅长 java 技术栈,了解 php 和 go 等其他后端语言,熟练使用 ssm 框架完成企业级项目开发流程,同时熟悉 springboot 和 springcloud 等最新技术. 去年开始,致力于项目框架的升级重构,由原来的 ssm 组合重构成 springboot 自由搭配第三方框架,实现技术迭代的大跨步,引入一系列的新功能特定弥补了旧框架的不足,简化了开发流程,提高了开发效率,经过一年多的努力,框架已经成熟,目前已推广到全公司各个项目团队一起使用,进入版本升级维护阶段! 前端和后端的同时推进让我具备一定的全栈开发能力,系统的重构为我的下一次架构师设定了目标. 写作经验介绍 今年3月份刚刚打算尝试写作,主要想整理下这一段时间的收获和自己的一些思考,当时刚巧看到简书有日更活动便开始了写作,今天刚好是日更的第20天,因此暂时没有取得比较大的成就. 主要的投稿平台的历史统计如下(每天更新): 简书 : 0粉丝,24文章,23850字数,27收获喜欢,24简书钻. CSDN : 23原创,1粉丝,23喜欢,0评论,1151访问,255积分,36万+排名. 博客园 : 22随笔,0文章,10粉丝,14评论. 掘金 : 21原创,4关注者,25点赞数,361阅读数,0评论数. 开源中国 : 22博文,2推荐,4粉丝,2积分,34访问. segmentfault : 22文章,0粉丝,11声望,747阅读量,3点赞数. 慕课手记 : 21手记,41835经验,19积分,2粉丝. B站专栏 : 86阅读量+4,0评论0,20点赞0,3收藏+0,0投币0. 简书 基本上没什么阅读量,偶尔一两个阅读点赞,创作的动力在于日更活动督促自己不要断更,还有就是每天的简书钻收益提醒见证自己的成长. csdn 阅读量稳定,积累到一定数量的原创文章后可开通专栏,创作动力在于搜索引擎优化很多,增添自信. 博客园 默认自动发表到首页但会有审核,一旦质量不过关随时可能被移出首页,并且有推荐和反对两种方式,保证了质量的同时,带来了一两百的阅读量,粉丝增长明显,已经10个粉丝啦! 掘金 markdown 编辑器很漂亮,页面风格像是朋友圈一样,比简书一个等级但稍微好点,4 个粉丝. 开源中国 文章质量普遍较高,刚开始没自信自荐故而无缘首页,后来见其他平台的几百阅读量还不错,因此鼓起勇气自荐. 一旦自荐通过审核,上了博客首页,阅读量至少上百,而且还能顺便吸引几个粉丝和收藏,目前保持在两天一推荐. 思否 和掘金一个等级,重点是技术问答社区,专栏文章被收藏后会增加威望值,目前3篇被收藏. 慕课手记 零起点入门教程,生于斯死于斯,和csdn一个等级,没它seo做得好,粉丝增加了2个呢! B站专栏 纯属意外发现B站竟然有专栏,毕竟不是做技术的就不苛刻了,不支持markdown,阅读量和掘金,思否一个等级,至今没有粉丝. 微信公众号 闭环没流量,没必要做统计,权当自娱自乐了! 以上平台的账号几乎都是雪之梦技术驿站(snowdreams1006) 个人主页 昵称: 雪之梦技术驿站 主页: 5224488 © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"other/donate.html":{"url":"other/donate.html","title":"捐赠支持","keywords":"","body":"捐赠支持 © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-29 17:26:34 "},"GLOSSARY.html":{"url":"GLOSSARY.html","keywords":"","body":"markdown 简洁优雅的排版语言,简化版的 HTML,加强版的 TXT,详情请参考 https://snowdreams1006.github.io/markdown/ git 分布式版本控制系统,详情请参考 https://snowdreams1006.github.io/git/ © snowdreams1006 all right reserved，powered by snowdreams1006文件修订时间： 2019-04-28 10:07:12 "}}